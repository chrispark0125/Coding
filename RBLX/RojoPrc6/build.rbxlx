<roblox xmlns:xmime="http://www.w3.org/2005/05/xmlmime" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://www.roblox.com/roblox.xsd" version="4">
	<External>null</External>
	<External>nil</External>
	<Item class="Workspace" referent="6">
		<Properties>
			<bool name="AllowThirdPartySales">false</bool>
			<token name="AnimationWeightedBlendFix">0</token>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<token name="ClientAnimatorThrottling">0</token>
			<string name="CollisionGroups">Default^0^-1</string>
			<Ref name="CurrentCamera">RBX82F3F712862F45A9904ECFE548E5C2DA</Ref>
			<double name="DistributedGameTime">1445.4917423888109624</double>
			<bool name="ExplicitAutoJoints">true</bool>
			<float name="FallenPartsDestroyHeight">-500</float>
			<float name="Gravity">196.199997</float>
			<token name="HumanoidOnlySetCollisionsOnStateChange">0</token>
			<token name="InterpolationThrottling">0</token>
			<token name="LevelOfDetail">0</token>
			<token name="MeshPartHeadsAndAccessories">0</token>
			<CoordinateFrame name="ModelMeshCFrame">
				<X>0</X>
				<Y>0</Y>
				<Z>0</Z>
				<R00>1</R00>
				<R01>0</R01>
				<R02>0</R02>
				<R10>0</R10>
				<R11>1</R11>
				<R12>0</R12>
				<R20>0</R20>
				<R21>0</R21>
				<R22>1</R22>
			</CoordinateFrame>
			<SharedString name="ModelMeshData">yuZpQdnvvUBOTYh1jqZ2cA==</SharedString>
			<Vector3 name="ModelMeshSize">
				<X>0</X>
				<Y>0</Y>
				<Z>0</Z>
			</Vector3>
			<string name="Name">Workspace</string>
			<bool name="NeedsPivotMigration">false</bool>
			<token name="PhysicsSteppingMethod">0</token>
			<Ref name="PrimaryPart">null</Ref>
			<token name="SignalBehavior">0</token>
			<int64 name="SourceAssetId">-1</int64>
			<token name="StreamOutBehavior">0</token>
			<bool name="StreamingEnabled">false</bool>
			<int name="StreamingMinRadius">64</int>
			<token name="StreamingPauseMode">0</token>
			<int name="StreamingTargetRadius">1024</int>
			<BinaryString name="Tags"></BinaryString>
			<bool name="TerrainWeldsFixed">true</bool>
			<bool name="TouchesUseCollisionGroups">false</bool>
			<OptionalCoordinateFrame name="WorldPivotData">
				<CFrame>
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CFrame>
			</OptionalCoordinateFrame>
		</Properties>
		<Item class="Camera" referent="RBX82F3F712862F45A9904ECFE548E5C2DA">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<CoordinateFrame name="CFrame">
					<X>51.9961548</X>
					<Y>24.1850605</Y>
					<Z>76.5687332</Z>
					<R00>0.999478459</R00>
					<R01>-0.0171800088</R01>
					<R02>0.0273438059</R02>
					<R10>-9.31322575e-10</R10>
					<R11>0.846741557</R11>
					<R12>0.532004476</R12>
					<R20>-0.032292977</R20>
					<R21>-0.531727016</R21>
					<R22>0.846299946</R22>
				</CoordinateFrame>
				<Ref name="CameraSubject">null</Ref>
				<token name="CameraType">0</token>
				<float name="FieldOfView">70</float>
				<token name="FieldOfViewMode">0</token>
				<CoordinateFrame name="Focus">
					<X>51.9414673</X>
					<Y>23.1210537</Y>
					<Z>74.8761368</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<bool name="HeadLocked">true</bool>
				<float name="HeadScale">1</float>
				<string name="Name">Camera</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
		<Item class="Terrain" referent="RBXD46E5D29AA844AF2BF1750803F5007D6">
			<Properties>
				<token name="AcquisitionMethod">0</token>
				<bool name="Anchored">true</bool>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<float name="BackParamA">-0.5</float>
				<float name="BackParamB">0.5</float>
				<token name="BackSurface">0</token>
				<token name="BackSurfaceInput">0</token>
				<float name="BottomParamA">-0.5</float>
				<float name="BottomParamB">0.5</float>
				<token name="BottomSurface">4</token>
				<token name="BottomSurfaceInput">0</token>
				<CoordinateFrame name="CFrame">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<bool name="CanCollide">true</bool>
				<bool name="CanQuery">true</bool>
				<bool name="CanTouch">true</bool>
				<bool name="CastShadow">true</bool>
				<int name="CollisionGroupId">0</int>
				<Color3uint8 name="Color3uint8">4288914085</Color3uint8>
				<PhysicalProperties name="CustomPhysicalProperties">
					<CustomPhysics>false</CustomPhysics>
				</PhysicalProperties>
				<bool name="Decoration">false</bool>
				<float name="FrontParamA">-0.5</float>
				<float name="FrontParamB">0.5</float>
				<token name="FrontSurface">0</token>
				<token name="FrontSurfaceInput">0</token>
				<float name="LeftParamA">-0.5</float>
				<float name="LeftParamB">0.5</float>
				<token name="LeftSurface">0</token>
				<token name="LeftSurfaceInput">0</token>
				<bool name="Locked">true</bool>
				<bool name="Massless">false</bool>
				<token name="Material">256</token>
				<BinaryString name="MaterialColors"><![CDATA[AAAAAAAAan8/P39rf2Y/ilY+j35fi21PZmxvZbDqw8faiVpHOi4kHh4lZlw76JxKc3trhHta
gcLgc4RKxr21zq2UlJSM]]></BinaryString>
				<string name="Name">Terrain</string>
				<BinaryString name="PhysicsGrid">AgMAAAAAAAAAAAAAAAA=</BinaryString>
				<CoordinateFrame name="PivotOffset">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<float name="Reflectance">0</float>
				<float name="RightParamA">-0.5</float>
				<float name="RightParamB">0.5</float>
				<token name="RightSurface">0</token>
				<token name="RightSurfaceInput">0</token>
				<int name="RootPriority">0</int>
				<Vector3 name="RotVelocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<BinaryString name="SmoothGrid">AQU=</BinaryString>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<float name="TopParamA">-0.5</float>
				<float name="TopParamB">0.5</float>
				<token name="TopSurface">3</token>
				<token name="TopSurfaceInput">0</token>
				<float name="Transparency">0</float>
				<Vector3 name="Velocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<Color3 name="WaterColor">
					<R>0.0500000007</R>
					<G>0.330000013</G>
					<B>0.360000014</B>
				</Color3>
				<float name="WaterReflectance">1</float>
				<float name="WaterTransparency">0.300000012</float>
				<float name="WaterWaveSize">0.150000006</float>
				<float name="WaterWaveSpeed">10</float>
				<Vector3 name="size">
					<X>2044</X>
					<Y>252</Y>
					<Z>2044</Z>
				</Vector3>
			</Properties>
		</Item>
		<Item class="SpawnLocation" referent="RBXF0EF88611B254C5B83B31DA121E75ED1">
			<Properties>
				<bool name="AllowTeamChangeOnTouch">false</bool>
				<bool name="Anchored">true</bool>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<float name="BackParamA">-0.5</float>
				<float name="BackParamB">0.5</float>
				<token name="BackSurface">0</token>
				<token name="BackSurfaceInput">0</token>
				<float name="BottomParamA">-0.5</float>
				<float name="BottomParamB">0.5</float>
				<token name="BottomSurface">0</token>
				<token name="BottomSurfaceInput">0</token>
				<CoordinateFrame name="CFrame">
					<X>2.68262482</X>
					<Y>-14</Y>
					<Z>10.0649414</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<bool name="CanCollide">true</bool>
				<bool name="CanQuery">true</bool>
				<bool name="CanTouch">true</bool>
				<bool name="CastShadow">true</bool>
				<int name="CollisionGroupId">0</int>
				<Color3uint8 name="Color3uint8">4288914085</Color3uint8>
				<PhysicalProperties name="CustomPhysicalProperties">
					<CustomPhysics>false</CustomPhysics>
				</PhysicalProperties>
				<int name="Duration">10</int>
				<bool name="Enabled">true</bool>
				<float name="FrontParamA">-0.5</float>
				<float name="FrontParamB">0.5</float>
				<token name="FrontSurface">0</token>
				<token name="FrontSurfaceInput">0</token>
				<float name="LeftParamA">-0.5</float>
				<float name="LeftParamB">0.5</float>
				<token name="LeftSurface">0</token>
				<token name="LeftSurfaceInput">0</token>
				<bool name="Locked">false</bool>
				<bool name="Massless">false</bool>
				<token name="Material">256</token>
				<string name="Name">SpawnLocation</string>
				<bool name="Neutral">true</bool>
				<CoordinateFrame name="PivotOffset">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<float name="Reflectance">0</float>
				<float name="RightParamA">-0.5</float>
				<float name="RightParamB">0.5</float>
				<token name="RightSurface">0</token>
				<token name="RightSurfaceInput">0</token>
				<int name="RootPriority">0</int>
				<Vector3 name="RotVelocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<int name="TeamColor">194</int>
				<float name="TopParamA">-0.5</float>
				<float name="TopParamB">0.5</float>
				<token name="TopSurface">0</token>
				<token name="TopSurfaceInput">0</token>
				<float name="Transparency">0</float>
				<Vector3 name="Velocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<token name="formFactorRaw">1</token>
				<token name="shape">1</token>
				<Vector3 name="size">
					<X>12</X>
					<Y>1</Y>
					<Z>12</Z>
				</Vector3>
			</Properties>
			<Item class="Decal" referent="RBXEE149F65E3014C0BA12D0E8D0D12FFBD">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<Color3 name="Color3">
						<R>1</R>
						<G>1</G>
						<B>1</B>
					</Color3>
					<token name="Face">1</token>
					<string name="Name">Decal</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<Content name="Texture"><url>rbxasset://textures/SpawnLocation.png</url></Content>
					<float name="Transparency">0</float>
					<int name="ZIndex">1</int>
				</Properties>
			</Item>
		</Item>
		<Item class="Part" referent="RBX10A9D76A55DB4EF682112C9666B2BF8C">
			<Properties>
				<bool name="Anchored">true</bool>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<float name="BackParamA">-0.5</float>
				<float name="BackParamB">0.5</float>
				<token name="BackSurface">0</token>
				<token name="BackSurfaceInput">0</token>
				<float name="BottomParamA">-0.5</float>
				<float name="BottomParamB">0.5</float>
				<token name="BottomSurface">0</token>
				<token name="BottomSurfaceInput">0</token>
				<CoordinateFrame name="CFrame">
					<X>0</X>
					<Y>-15</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<bool name="CanCollide">true</bool>
				<bool name="CanQuery">true</bool>
				<bool name="CanTouch">true</bool>
				<bool name="CastShadow">true</bool>
				<int name="CollisionGroupId">0</int>
				<Color3uint8 name="Color3uint8">4286414205</Color3uint8>
				<PhysicalProperties name="CustomPhysicalProperties">
					<CustomPhysics>false</CustomPhysics>
				</PhysicalProperties>
				<float name="FrontParamA">-0.5</float>
				<float name="FrontParamB">0.5</float>
				<token name="FrontSurface">0</token>
				<token name="FrontSurfaceInput">0</token>
				<float name="LeftParamA">-0.5</float>
				<float name="LeftParamB">0.5</float>
				<token name="LeftSurface">0</token>
				<token name="LeftSurfaceInput">0</token>
				<bool name="Locked">false</bool>
				<bool name="Massless">false</bool>
				<token name="Material">784</token>
				<string name="Name">Part</string>
				<CoordinateFrame name="PivotOffset">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<float name="Reflectance">0</float>
				<float name="RightParamA">-0.5</float>
				<float name="RightParamB">0.5</float>
				<token name="RightSurface">0</token>
				<token name="RightSurfaceInput">0</token>
				<int name="RootPriority">0</int>
				<Vector3 name="RotVelocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<float name="TopParamA">-0.5</float>
				<float name="TopParamB">0.5</float>
				<token name="TopSurface">0</token>
				<token name="TopSurfaceInput">0</token>
				<float name="Transparency">0</float>
				<Vector3 name="Velocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<token name="formFactorRaw">1</token>
				<token name="shape">1</token>
				<Vector3 name="size">
					<X>250</X>
					<Y>1</Y>
					<Z>250</Z>
				</Vector3>
			</Properties>
		</Item>
		<Item class="Model" referent="RBXE96867051A594E87B66FF4B25E35A145">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<token name="LevelOfDetail">0</token>
				<CoordinateFrame name="ModelMeshCFrame">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<SharedString name="ModelMeshData">yuZpQdnvvUBOTYh1jqZ2cA==</SharedString>
				<Vector3 name="ModelMeshSize">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<string name="Name">Table</string>
				<bool name="NeedsPivotMigration">false</bool>
				<Ref name="PrimaryPart">RBX552CEECF39FA4B0CA18F2B665D68B670</Ref>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<OptionalCoordinateFrame name="WorldPivotData"></OptionalCoordinateFrame>
			</Properties>
			<Item class="MeshPart" referent="RBX552CEECF39FA4B0CA18F2B665D68B670">
				<Properties>
					<bool name="Anchored">false</bool>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<float name="BackParamA">-0.5</float>
					<float name="BackParamB">0.5</float>
					<token name="BackSurface">0</token>
					<token name="BackSurfaceInput">0</token>
					<float name="BottomParamA">-0.5</float>
					<float name="BottomParamB">0.5</float>
					<token name="BottomSurface">0</token>
					<token name="BottomSurfaceInput">0</token>
					<CoordinateFrame name="CFrame">
						<X>45.6534348</X>
						<Y>0</Y>
						<Z>0</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<bool name="CanCollide">true</bool>
					<bool name="CanQuery">true</bool>
					<bool name="CanTouch">true</bool>
					<bool name="CastShadow">true</bool>
					<int name="CollisionGroupId">0</int>
					<Color3uint8 name="Color3uint8">4288914085</Color3uint8>
					<PhysicalProperties name="CustomPhysicalProperties">
						<CustomPhysics>false</CustomPhysics>
					</PhysicalProperties>
					<bool name="DoubleSided">false</bool>
					<float name="FrontParamA">-0.5</float>
					<float name="FrontParamB">0.5</float>
					<token name="FrontSurface">0</token>
					<token name="FrontSurfaceInput">0</token>
					<bool name="HasJointOffset">false</bool>
					<bool name="HasSkinnedMesh">false</bool>
					<Vector3 name="InitialSize">
						<X>35.5803146</X>
						<Y>18.7247047</Y>
						<Z>35.5803185</Z>
					</Vector3>
					<Vector3 name="JointOffset">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<BinaryString name="LODData"></BinaryString>
					<float name="LeftParamA">-0.5</float>
					<float name="LeftParamB">0.5</float>
					<token name="LeftSurface">0</token>
					<token name="LeftSurfaceInput">0</token>
					<bool name="Locked">false</bool>
					<bool name="Massless">false</bool>
					<token name="Material">256</token>
					<Content name="MeshID"><url>rbxassetid://7402483824</url></Content>
					<Content name="MeshId"><url>rbxassetid://7402483824</url></Content>
					<string name="Name">Main</string>
					<SharedString name="PhysicalConfigData">FSjZieUXNuAHM4qeNl45ag==</SharedString>
					<BinaryString name="PhysicsData"></BinaryString>
					<CoordinateFrame name="PivotOffset">
						<X>-0.27946049</X>
						<Y>2.50771928</Y>
						<Z>0.742670119</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<float name="Reflectance">0</float>
					<token name="RenderFidelity">0</token>
					<float name="RightParamA">-0.5</float>
					<float name="RightParamB">0.5</float>
					<token name="RightSurface">0</token>
					<token name="RightSurfaceInput">0</token>
					<int name="RootPriority">0</int>
					<Vector3 name="RotVelocity">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<Content name="TextureID"><url>rbxassetid://7402484012</url></Content>
					<float name="TopParamA">-0.5</float>
					<float name="TopParamB">0.5</float>
					<token name="TopSurface">0</token>
					<token name="TopSurfaceInput">0</token>
					<float name="Transparency">0</float>
					<Vector3 name="Velocity">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<Vector3 name="size">
						<X>14</X>
						<Y>7</Y>
						<Z>14</Z>
					</Vector3>
				</Properties>
			</Item>
		</Item>
	</Item>
	<Item class="SoundService" referent="RBXA75A523268694B6AA70648411269D8C3">
		<Properties>
			<token name="AmbientReverb">0</token>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<float name="DistanceFactor">3.32999992</float>
			<float name="DopplerScale">1</float>
			<string name="Name">SoundService</string>
			<bool name="RespectFilteringEnabled">false</bool>
			<float name="RolloffScale">1</float>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="NonReplicatedCSGDictionaryService" referent="RBX1E404B6CF13C478488C8F4C8287CD3DC">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">NonReplicatedCSGDictionaryService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="CSGDictionaryService" referent="RBX25932DBF41BC455DA1DD795923A9FA2F">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">CSGDictionaryService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="Chat" referent="RBX18274778A5FF4521A48E848296F6A126">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<bool name="BubbleChatEnabled">false</bool>
			<bool name="LoadDefaultChat">true</bool>
			<string name="Name">Chat</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="TimerService" referent="RBX7A7E12060A5A4E749377D863202EC607">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">Instance</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="Players" referent="RBXA20F45BD4CBC43F5B2589F51101E0784">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<bool name="CharacterAutoLoads">true</bool>
			<int name="MaxPlayersInternal">12</int>
			<string name="Name">Players</string>
			<int name="PreferredPlayersInternal">0</int>
			<float name="RespawnTime">5</float>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="ReplicatedFirst" referent="RBX45F80B1150114CC184B58756E7A55AE1">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">ReplicatedFirst</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="TweenService" referent="RBX47B36E29A36B44249B5A03CF1D227120">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">TweenService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="PermissionsService" referent="RBX24F486E40D094E878814897E24592C58">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">PermissionsService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="PlayerEmulatorService" referent="RBX85B567689AE442A4A004E1A6F6E6AA7B">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<bool name="CustomPoliciesEnabled">false</bool>
			<string name="DEPRECATED_SerializedEmulatedPolicyInfo"></string>
			<string name="EmulatedCountryCode"></string>
			<string name="EmulatedGameLocale"></string>
			<string name="Name">PlayerEmulatorService</string>
			<bool name="PlayerEmulationEnabled">false</bool>
			<BinaryString name="SerializedEmulatedPolicyInfo"></BinaryString>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="StudioData" referent="RBXE8ABAFF5115145728D5AAB955F01DE42">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<int64 name="CommitInflightAuthorId">0</int64>
			<string name="CommitInflightGuid"></string>
			<int name="CommitInflightPlaceVersion">0</int>
			<bool name="EnableScriptCollabByDefaultOnLoad">false</bool>
			<string name="Name">StudioData</string>
			<int64 name="SourceAssetId">-1</int64>
			<int64 name="SrcPlaceId">0</int64>
			<int64 name="SrcUniverseId">0</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="StarterPlayer" referent="3">
		<Properties>
			<bool name="AllowCustomAnimations">true</bool>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<bool name="AutoJumpEnabled">true</bool>
			<float name="CameraMaxZoomDistance">400</float>
			<float name="CameraMinZoomDistance">0.5</float>
			<token name="CameraMode">0</token>
			<float name="CharacterJumpHeight">7.19999981</float>
			<float name="CharacterJumpPower">50</float>
			<float name="CharacterMaxSlopeAngle">89</float>
			<bool name="CharacterUseJumpPower">true</bool>
			<float name="CharacterWalkSpeed">16</float>
			<token name="DevCameraOcclusionMode">0</token>
			<token name="DevComputerCameraMovementMode">0</token>
			<token name="DevComputerMovementMode">0</token>
			<token name="DevTouchCameraMovementMode">0</token>
			<token name="DevTouchMovementMode">0</token>
			<bool name="EnableMouseLockOption">true</bool>
			<int64 name="GameSettingsAssetIDFace">0</int64>
			<int64 name="GameSettingsAssetIDHead">0</int64>
			<int64 name="GameSettingsAssetIDLeftArm">0</int64>
			<int64 name="GameSettingsAssetIDLeftLeg">0</int64>
			<int64 name="GameSettingsAssetIDPants">0</int64>
			<int64 name="GameSettingsAssetIDRightArm">0</int64>
			<int64 name="GameSettingsAssetIDRightLeg">0</int64>
			<int64 name="GameSettingsAssetIDShirt">0</int64>
			<int64 name="GameSettingsAssetIDTeeShirt">0</int64>
			<int64 name="GameSettingsAssetIDTorso">0</int64>
			<token name="GameSettingsAvatar">1</token>
			<token name="GameSettingsR15Collision">0</token>
			<NumberRange name="GameSettingsScaleRangeBodyType">0 1 </NumberRange>
			<NumberRange name="GameSettingsScaleRangeHead">0.95 1 </NumberRange>
			<NumberRange name="GameSettingsScaleRangeHeight">0.9 1.05 </NumberRange>
			<NumberRange name="GameSettingsScaleRangeProportion">0 1 </NumberRange>
			<NumberRange name="GameSettingsScaleRangeWidth">0.7 1 </NumberRange>
			<float name="HealthDisplayDistance">100</float>
			<bool name="LoadCharacterAppearance">true</bool>
			<token name="LoadCharacterLayeredClothing">0</token>
			<string name="Name">StarterPlayer</string>
			<float name="NameDisplayDistance">100</float>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<bool name="UserEmotesEnabled">true</bool>
		</Properties>
		<Item class="StarterCharacterScripts" referent="4">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<string name="Name">StarterCharacterScripts</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
		<Item class="StarterPlayerScripts" referent="5">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<string name="Name">StarterPlayerScripts</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="LocalScript" referent="RBXFE0E6DF49BEE4168AF2238154B5BD6C4">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">LocalHandler</string>
					<string name="ScriptGuid">{A486A697-DCE4-41BC-91D9-F13320095435}</string>
					<ProtectedString name="Source"><![CDATA[local UIS = game:GetService("UserInputService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local CollectionService = game:GetService("CollectionService")
local AssetFolder = ReplicatedStorage.Assets
local localplayer = game.Players.LocalPlayer
local CurrentCamera = workspace.CurrentCamera


--RunorWalk Func
local runspeed = 25
local normalspd = 16
local key = Enum.KeyCode.LeftShift
local fov = 60
local fovMin = { FieldOfView = fov }
local fovMax = { FieldOfView = fov + runspeed }
local Camera = game.Workspace.CurrentCamera
local TweenSev1 = game.TweenService:Create(Camera, TweenInfo.new(0.4, Enum.EasingStyle.Sine), fovMax)
local TweenSev2 = game.TweenService:Create(Camera, TweenInfo.new(0.4, Enum.EasingStyle.Sine), fovMin)

game:GetService("UserInputService").InputBegan:Connect(function(input, prc)
	if prc then return end
	if input.UserInputType == Enum.UserInputType.Keyboard then
		if input.KeyCode == key then
            if localplayer.Character:FindFirstChild("Humanoid") then
                localplayer.Character:FindFirstChild("Humanoid").WalkSpeed = runspeed
			TweenSev1:Play()
			-- tween starts 1 and stops 2
            end
        end
	end
end)
game:GetService("UserInputService").InputEnded:Connect(function(input, prc)
	if prc then return end
	if input.KeyCode == key then
        if localplayer.Character:FindFirstChild("Humanoid") then
            localplayer.Character:FindFirstChild("Humanoid").WalkSpeed = normalspd
		TweenSev2:Play()
        end
    end
end) 

--Player Mouse Action Detection
UIS.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 then
	end
    if input.UserInputType == Enum.UserInputType.MouseButton2 then
	end
end)

UIS.InputEnded:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 then
	end
    if input.UserInputType == Enum.UserInputType.MouseButton2 then
	end
end)

--Object Action

local userInputService = game:GetService("UserInputService")

local orientation = CFrame.new()

local currentMode = nil
local currentObject = nil
local mouseHitPart = nil
local mouseHitPos = nil
local mouseHitNormal = nil

local player = game:GetService("Players").LocalPlayer
local camera = workspace.CurrentCamera

userInputService.InputBegan:Connect(function(input, inGui)
	if inGui then
		return
	end

	local key = input.KeyCode

	if key == Enum.KeyCode.E then
		if currentObject then
			currentObject:Destroy()
			currentObject = nil
		end

		if currentMode ~= "Build" then
			currentMode = "Build"

			currentObject = workspace.Table:Clone()
			currentObject.Parent = workspace

			CollectionService:AddTag(currentObject,"IgnoreCamera")
		else
			currentMode = nil
		end
	elseif key == Enum.KeyCode.R then
		orientation = CFrame.Angles(0, math.rad(90), 0) * orientation
	end
end)

local function raycast()
	local mousePos = userInputService:GetMouseLocation()

	local params = RaycastParams.new()
	params.FilterDescendantsInstances = {player.Character, currentObject}
	params.FilterType = Enum.RaycastFilterType.Blacklist

	local unitRay = camera:ScreenPointToRay(mousePos.X, mousePos.Y)

	return workspace:Raycast(unitRay.Origin, unitRay.Direction * 200, params)
end

local function getRotatedSize(size)
	local newModelSize = orientation * CFrame.new(size)
	newModelSize = Vector3.new(
		math.abs(newModelSize.X),
		math.abs(newModelSize.Y),
		math.abs(newModelSize.Z)
	)

	return newModelSize
end

local function getPlacementPos(size)
	local newModelSize = getRotatedSize(size)

	return Vector3.new(
		math.floor(mouseHitPos.X / 0.5 + 0.5) * 0.5 + mouseHitNormal.X * (newModelSize.X / 2),
		math.floor(mouseHitPos.Y / 0.5 + 0.5) * 0.5 + mouseHitNormal.Y * (newModelSize.Y / 2),
		math.floor(mouseHitPos.Z / 0.5 + 0.5) * 0.5 + mouseHitNormal.Z * (newModelSize.Z / 2)
	)
end

game:GetService("RunService").Heartbeat:Connect(function()
	local raycastResult = raycast() or {}

	mouseHitPart = raycastResult.Instance
	mouseHitPos = raycastResult.Position
	mouseHitNormal = raycastResult.Normal

	if currentMode == "Build" then
		if mouseHitNormal and mouseHitPos and currentObject then
			currentObject:SetPrimaryPartCFrame(CFrame.new(getPlacementPos(currentObject.PrimaryPart.Size)) * orientation)
			game:GetService("CollectionService"):AddTag(currentObject,"IgnoreCamera")
		end
	end
end)]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBXCBB8965EB79A456EAFFE179BCFBC33FA">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">PlayerModule</string>
					<string name="ScriptGuid">{EE7AA8C5-5FE4-4F1F-9B69-5FCD69CB9BA3}</string>
					<ProtectedString name="Source"><![CDATA[--[[
	PlayerModule - This module requires and instantiates the camera and control modules,
	and provides getters for developers to access methods on these singletons without
	having to modify Roblox-supplied scripts.
	
	2018 PlayerScripts Update - AllYourBlox	
--]]

local PlayerModule = {}
PlayerModule.__index = PlayerModule

function PlayerModule.new()
	local self = setmetatable({},PlayerModule)
	self.cameras = require(script:WaitForChild("CameraModule"))
	self.controls = require(script:WaitForChild("ControlModule"))
	return self
end

function PlayerModule:GetCameras()
	return self.cameras
end

function PlayerModule:GetControls()
	return self.controls
end

return PlayerModule.new()
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBX2B6AEEA42A264DAEBD93B2B91E87759F">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">ControlModule</string>
						<string name="ScriptGuid">{BA56188B-CBE4-4909-B892-FC89CBF3C4B6}</string>
						<ProtectedString name="Source"><![CDATA[--[[
	ControlModule - This ModuleScript implements a singleton class to manage the
	selection, activation, and deactivation of the current character movement controller.
	This script binds to RenderStepped at Input priority and calls the Update() methods
	on the active controller instances.
	
	The character controller ModuleScripts implement classes which are instantiated and
	activated as-needed, they are no longer all instantiated up front as they were in
	the previous generation of PlayerScripts.
	
	2018 PlayerScripts Update - AllYourBlox		
--]]
local ControlModule = {}
ControlModule.__index = ControlModule

--[[ Roblox Services ]]--
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local UserGameSettings = UserSettings():GetService("UserGameSettings")

-- Roblox User Input Control Modules - each returns a new() constructor function used to create controllers as needed
local Keyboard = require(script:WaitForChild("Keyboard"))
local Gamepad = require(script:WaitForChild("Gamepad"))
local TouchDPad = require(script:WaitForChild("TouchDPad"))
local DynamicThumbstick = require(script:WaitForChild("DynamicThumbstick"))

-- These controllers handle only walk/run movement, jumping is handled by the
-- TouchJump controller if any of these are active
local ClickToMove = require(script:WaitForChild("ClickToMoveController"))
local TouchThumbstick = require(script:WaitForChild("TouchThumbstick"))
local TouchThumbpad = require(script:WaitForChild("TouchThumbpad"))
local TouchJump = require(script:WaitForChild("TouchJump"))

local VehicleController = require(script:WaitForChild("VehicleController"))

local CONTROL_ACTION_PRIORITY = Enum.ContextActionPriority.Default.Value

-- Mapping from movement mode and lastInputType enum values to control modules to avoid huge if elseif switching
local movementEnumToModuleMap = {
	[Enum.TouchMovementMode.DPad] = TouchDPad,
	[Enum.DevTouchMovementMode.DPad] = TouchDPad,
	[Enum.TouchMovementMode.Thumbpad] = TouchThumbpad,
	[Enum.DevTouchMovementMode.Thumbpad] = TouchThumbpad,
	[Enum.TouchMovementMode.Thumbstick] = TouchThumbstick,
	[Enum.DevTouchMovementMode.Thumbstick] = TouchThumbstick,
	[Enum.TouchMovementMode.DynamicThumbstick] = DynamicThumbstick,
	[Enum.DevTouchMovementMode.DynamicThumbstick] = DynamicThumbstick,
	[Enum.TouchMovementMode.ClickToMove] = ClickToMove,
	[Enum.DevTouchMovementMode.ClickToMove] = ClickToMove,

	-- Current default
	[Enum.TouchMovementMode.Default] = DynamicThumbstick,

	[Enum.ComputerMovementMode.Default] = Keyboard,
	[Enum.ComputerMovementMode.KeyboardMouse] = Keyboard,
	[Enum.DevComputerMovementMode.KeyboardMouse] = Keyboard,
	[Enum.DevComputerMovementMode.Scriptable] = nil,
	[Enum.ComputerMovementMode.ClickToMove] = ClickToMove,
	[Enum.DevComputerMovementMode.ClickToMove] = ClickToMove,
}

-- Keyboard controller is really keyboard and mouse controller
local computerInputTypeToModuleMap = {
	[Enum.UserInputType.Keyboard] = Keyboard,
	[Enum.UserInputType.MouseButton1] = Keyboard,
	[Enum.UserInputType.MouseButton2] = Keyboard,
	[Enum.UserInputType.MouseButton3] = Keyboard,
	[Enum.UserInputType.MouseWheel] = Keyboard,
	[Enum.UserInputType.MouseMovement] = Keyboard,
	[Enum.UserInputType.Gamepad1] = Gamepad,
	[Enum.UserInputType.Gamepad2] = Gamepad,
	[Enum.UserInputType.Gamepad3] = Gamepad,
	[Enum.UserInputType.Gamepad4] = Gamepad,
}

function ControlModule.new()
	local self = setmetatable({},ControlModule)
	
	-- The Modules above are used to construct controller instances as-needed, and this
	-- table is a map from Module to the instance created from it
	self.controllers = {}

	self.activeControlModule = nil	-- Used to prevent unnecessarily expensive checks on each input event
	self.activeController = nil
	self.touchJumpController = nil
	self.moveFunction = Players.LocalPlayer.Move
	self.humanoid = nil
	self.lastInputType = Enum.UserInputType.None
	self.cameraRelative = true
	
	-- For Roblox self.vehicleController
	self.humanoidSeatedConn = nil
	self.vehicleController = nil
	
	self.touchControlFrame = nil
	
	self.vehicleController = VehicleController.new(CONTROL_ACTION_PRIORITY)
	
	Players.LocalPlayer.CharacterAdded:Connect(function(char) self:OnCharacterAdded(char) end)
	Players.LocalPlayer.CharacterRemoving:Connect(function(char) self:OnCharacterAdded(char) end)
	if Players.LocalPlayer.Character then
		self:OnCharacterAdded(Players.LocalPlayer.Character)
	end
	
	RunService:BindToRenderStep("ControlScriptRenderstep", Enum.RenderPriority.Input.Value, function(dt) self:OnRenderStepped(dt) end)
	
	UserInputService.LastInputTypeChanged:Connect(function(newLastInputType) self:OnLastInputTypeChanged(newLastInputType) end)
	
	local propertyChangeListeners = {
		UserGameSettings:GetPropertyChangedSignal("TouchMovementMode"):Connect(function() self:OnTouchMovementModeChange() end),
		Players.LocalPlayer:GetPropertyChangedSignal("DevTouchMovementMode"):Connect(function() self:OnTouchMovementModeChange() end),
	
		UserGameSettings:GetPropertyChangedSignal("ComputerMovementMode"):Connect(function() self:OnComputerMovementModeChange() end),
		Players.LocalPlayer:GetPropertyChangedSignal("DevComputerMovementMode"):Connect(function() self:OnComputerMovementModeChange() end),
	}
	
	--[[ Touch Device UI ]]--
	self.playerGui = nil
	self.touchGui = nil
	self.playerGuiAddedConn = nil

	if UserInputService.TouchEnabled then
		self.playerGui = Players.LocalPlayer:FindFirstChildOfClass("PlayerGui")
		if self.playerGui then
			self:CreateTouchGuiContainer()
			self:OnLastInputTypeChanged(UserInputService:GetLastInputType())
		else
			self.playerGuiAddedConn = Players.LocalPlayer.ChildAdded:Connect(function(child)
				if child:IsA("PlayerGui") then
					self.playerGui = child
					self:CreateTouchGuiContainer()
					self.playerGuiAddedConn:Disconnect()
					self.playerGuiAddedConn = nil
					self:OnLastInputTypeChanged(UserInputService:GetLastInputType())
				end
			end)
		end
	else
		self:OnLastInputTypeChanged(UserInputService:GetLastInputType())
	end
	
	return self
end

-- Convenience function so that calling code does not have to first get the activeController
-- and then call GetMoveVector on it. When there is no active controller, this function returns
-- nil so that this case can be distinguished from no current movement (which returns zero vector).
function ControlModule:GetMoveVector()
	if self.activeController then
		return self.activeController:GetMoveVector()
	end
	return Vector3.new(0,0,0)
end

function ControlModule:GetActiveController()
	return self.activeController
end

function ControlModule:Enable(enable)
	if not self.activeController then
		return
	end
	
	if enable == nil then
		enable = true
	end
	if enable then
		if self.touchControlFrame then
			self.activeController:Enable(true, self.touchControlFrame)
		else
			if self.activeControlModule == ClickToMove then
				-- For ClickToMove, when it is the player's choice, we also enable the full keyboard controls.
				-- When the developer is forcing click to move, the most keyboard controls (WASD) are not available, only spacebar to jump.
				self.activeController:Enable(true, Players.LocalPlayer.DevComputerMovementMode == Enum.DevComputerMovementMode.UserChoice)
			else				
				self.activeController:Enable(true)
			end
		end
	else
		self:Disable()
	end
end

-- For those who prefer distinct functions
function ControlModule:Disable()
	if self.activeController then
		self.activeController:Enable(false)
	
		if self.moveFunction then
			self.moveFunction(Players.LocalPlayer, Vector3.new(0,0,0), self.cameraRelative)
		end
	end
end


-- Returns module (possibly nil) and success code to differentiate returning nil due to error vs Scriptable
function ControlModule:SelectComputerMovementModule()
	if not (UserInputService.KeyboardEnabled or UserInputService.GamepadEnabled) then
		return nil, false
	end
	
	local computerModule = nil
	local DevMovementMode = Players.LocalPlayer.DevComputerMovementMode
	
	if DevMovementMode == Enum.DevComputerMovementMode.UserChoice then
		computerModule = computerInputTypeToModuleMap[lastInputType]
		if UserGameSettings.ComputerMovementMode == Enum.ComputerMovementMode.ClickToMove and computerModule == Keyboard then
			-- User has ClickToMove set in Settings, prefer ClickToMove controller for keyboard and mouse lastInputTypes
			computerModule = ClickToMove
		end
	else
		-- Developer has selected a mode that must be used.
		computerModule = movementEnumToModuleMap[DevMovementMode]
		
		-- computerModule is expected to be nil here only when developer has selected Scriptable
		if (not computerModule) and DevMovementMode ~= Enum.DevComputerMovementMode.Scriptable then
			warn("No character control module is associated with DevComputerMovementMode ", DevMovementMode)
		end
	end
	
	if computerModule then
		return computerModule, true
	elseif DevMovementMode == Enum.DevComputerMovementMode.Scriptable then
		-- Special case where nil is returned and we actually want to set self.activeController to nil for Scriptable
		return nil, true
	else
		-- This case is for when computerModule is nil because of an error and no suitable control module could
		-- be found.
		return nil, false
	end
end

-- Choose current Touch control module based on settings (user, dev)
-- Returns module (possibly nil) and success code to differentiate returning nil due to error vs Scriptable
function ControlModule:SelectTouchModule()
	if not UserInputService.TouchEnabled then
		return nil, false
	end
	local touchModule = nil
	local DevMovementMode = Players.LocalPlayer.DevTouchMovementMode
	if DevMovementMode == Enum.DevTouchMovementMode.UserChoice then
		touchModule = movementEnumToModuleMap[UserGameSettings.TouchMovementMode]
	elseif DevMovementMode == Enum.DevTouchMovementMode.Scriptable then
		return nil, true	
	else
		touchModule = movementEnumToModuleMap[DevMovementMode]
	end
	return touchModule, true
end

function ControlModule:OnRenderStepped(dt)
	if self.activeController and self.activeController.enabled and self.humanoid then
		local moveVector = self.activeController:GetMoveVector()

		local vehicleConsumedInput = false
		if self.vehicleController then
			moveVector, vehicleConsumedInput = self.vehicleController:Update(moveVector, self.activeControlModule==Gamepad)
		end

		-- User of vehicleConsumedInput is commented out to preserve legacy behavior, in case some game relies on Humanoid.MoveDirection still being set while in a VehicleSeat
		--if not vehicleConsumedInput then
			self.moveFunction(Players.LocalPlayer, moveVector, self.cameraRelative)
		--end

		self.humanoid.Jump = self.activeController:GetIsJumping() or (self.touchJumpController and self.touchJumpController:GetIsJumping())
	end
end

function ControlModule:OnHumanoidSeated(active, currentSeatPart)
	if active then
		if currentSeatPart and currentSeatPart:IsA("VehicleSeat") then
			if not self.vehicleController then
				self.vehicleController = self.vehicleController.new(CONTROL_ACTION_PRIORITY)
			end
			self.vehicleController:Enable(true, currentSeatPart)
		end
	else
		if self.vehicleController then
			self.vehicleController:Enable(false, currentSeatPart)
		end
	end
end

function ControlModule:OnCharacterAdded(char)
	self.humanoid = char:FindFirstChildOfClass("Humanoid")
	while not self.humanoid do
		char.ChildAdded:wait()
		self.humanoid = char:FindFirstChildOfClass("Humanoid")
	end

	if self.humanoidSeatedConn then
		self.humanoidSeatedConn:Disconnect()
		self.humanoidSeatedConn = nil
	end
	self.humanoidSeatedConn = self.humanoid.Seated:Connect(function(active, currentSeatPart) self:OnHumanoidSeated(active, currentSeatPart) end)
end

function ControlModule:OnCharacterRemoving(char)
	self.humanoid = nil
end

-- Helper function to lazily instantiate a controller if it does not yet exist,
-- disable the active controller if it is different from the on being switched to,
-- and then enable the requested controller. The argument to this function must be
-- a reference to one of the control modules, i.e. Keyboard, Gamepad, etc.
function ControlModule:SwitchToController(controlModule)
	if not controlModule then
		if self.activeController then
			self.activeController:Enable(false)
		end
		self.activeController = nil
		self.activeControlModule = nil
	else
		if not self.controllers[controlModule] then
			self.controllers[controlModule] = controlModule.new(CONTROL_ACTION_PRIORITY)
		end

		if self.activeController ~= self.controllers[controlModule] then
			if self.activeController then
				self.activeController:Enable(false)
			end
			self.activeController = self.controllers[controlModule]
			self.activeControlModule = controlModule -- Only used to check if controller switch is necessary
			if self.touchControlFrame then
				self.activeController:Enable(true, self.touchControlFrame)
			else
				if self.activeControlModule == ClickToMove then
					-- For ClickToMove, when it is the player's choice, we also enable the full keyboard controls.
					-- When the developer is forcing click to move, the most keyboard controls (WASD) are not available, only spacebar to jump.
					self.activeController:Enable(true, Players.LocalPlayer.DevComputerMovementMode == Enum.DevComputerMovementMode.UserChoice)
				else				
					self.activeController:Enable(true)
				end
			end
			if self.touchControlFrame and (self.activeControlModule == TouchThumbpad
									or self.activeControlModule == TouchThumbstick
									or self.activeControlModule == ClickToMove
									or self.activeControlModule == DynamicThumbstick) then
				if not self.controllers[TouchJump] then
					self.controllers[TouchJump] = TouchJump.new()
				end
				self.touchJumpController = self.controllers[TouchJump]
				self.touchJumpController:Enable(true, self.touchControlFrame)
			else
				if self.touchJumpController then
					self.touchJumpController:Enable(false)
				end
			end
		end
	end
end

function ControlModule:OnLastInputTypeChanged(newLastInputType)
	if lastInputType == newLastInputType then
		warn("LastInputType Change listener called with current type.")
	end
	lastInputType = newLastInputType

	if lastInputType == Enum.UserInputType.Touch then
		-- TODO: Check if touch module already active
		local touchModule, success = self:SelectTouchModule()
		if success then
			while not self.touchControlFrame do
				wait()
			end
			self:SwitchToController(touchModule)
		end
	elseif computerInputTypeToModuleMap[lastInputType] ~= nil then
		local computerModule = self:SelectComputerMovementModule()
		if computerModule then
			self:SwitchToController(computerModule)
		end
	end
end

-- Called when any relevant values of GameSettings or LocalPlayer change, forcing re-evalulation of
-- current control scheme
function ControlModule:OnComputerMovementModeChange()
	local controlModule, success =  self:SelectComputerMovementModule()
	if success then
		self:SwitchToController(controlModule)
	end
end

function ControlModule:OnTouchMovementModeChange()
	local touchModule, success = self:SelectTouchModule()
	if success then
		while not self.touchControlFrame do
			wait()
		end
		self:SwitchToController(touchModule)
	end
end

function ControlModule:CreateTouchGuiContainer()
	if self.touchGui then self.touchGui:Destroy() end

	-- Container for all touch device guis
	self.touchGui = Instance.new('ScreenGui')
	self.touchGui.Name = "TouchGui"
	self.touchGui.ResetOnSpawn = false

	self.touchControlFrame = Instance.new("Frame")
	self.touchControlFrame.Name = "TouchControlFrame"
	self.touchControlFrame.Size = UDim2.new(1, 0, 1, 0)
	self.touchControlFrame.BackgroundTransparency = 1
	self.touchControlFrame.Parent = self.touchGui

	self.touchGui.Parent = self.playerGui
end

return ControlModule.new()
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBXBD3DB6FF1C6541DBA77E562134F86B5E">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">VRNavigation</string>
							<string name="ScriptGuid">{90E074E6-8D4C-49FA-B187-AE76DB1AFB7C}</string>
							<ProtectedString name="Source"><![CDATA[
--[[
		VRNavigation
--]]

local VRService = game:GetService("VRService")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local PathfindingService = game:GetService("PathfindingService")
local ContextActionService = game:GetService("ContextActionService")
local StarterGui = game:GetService("StarterGui")

--local MasterControl = require(script.Parent)
local PathDisplay = nil
local LocalPlayer = Players.LocalPlayer

local bindAtPriorityFlagExists, bindAtPriorityFlagEnabled = pcall(function()
	return UserSettings():IsUserFeatureEnabled("UserPlayerScriptsBindAtPriority")
end)
local FFlagPlayerScriptsBindAtPriority = bindAtPriorityFlagExists and bindAtPriorityFlagEnabled

--[[ Constants ]]--
local RECALCULATE_PATH_THRESHOLD = 4
local NO_PATH_THRESHOLD = 12
local MAX_PATHING_DISTANCE = 200
local POINT_REACHED_THRESHOLD = 1
local OFFTRACK_TIME_THRESHOLD = 2
local THUMBSTICK_DEADZONE = 0.22

local ZERO_VECTOR3 = Vector3.new(0,0,0)
local XZ_VECTOR3 = Vector3.new(1,0,1)

--[[ Utility Functions ]]--
local function IsFinite(num)
	return num == num and num ~= 1/0 and num ~= -1/0
end

local function IsFiniteVector3(vec3)
	return IsFinite(vec3.x) and IsFinite(vec3.y) and IsFinite(vec3.z)
end

local movementUpdateEvent = Instance.new("BindableEvent")
movementUpdateEvent.Name = "MovementUpdate"
movementUpdateEvent.Parent = script

coroutine.wrap(function()
	local PathDisplayModule = script.Parent:WaitForChild("PathDisplay")
	if PathDisplayModule then
		PathDisplay = require(PathDisplayModule)
	end
end)()


--[[ The Class ]]--
local BaseCharacterController = require(script.Parent:WaitForChild("BaseCharacterController"))
local VRNavigation = setmetatable({}, BaseCharacterController)
VRNavigation.__index = VRNavigation

function VRNavigation.new(CONTROL_ACTION_PRIORITY)
	local self = setmetatable(BaseCharacterController.new(), VRNavigation)
	
	self.CONTROL_ACTION_PRIORITY = CONTROL_ACTION_PRIORITY
	
	self.navigationRequestedConn = nil
	self.heartbeatConn = nil
	
	self.currentDestination = nil
	self.currentPath = nil
	self.currentPoints = nil
	self.currentPointIdx = 0
	
	self.expectedTimeToNextPoint = 0
	self.timeReachedLastPoint = tick()
	self.moving = false
	
	self.isJumpBound = false
	self.moveLatch = false	

	self.userCFrameEnabledConn = nil
	
	return self
end

function VRNavigation:SetLaserPointerMode(mode)
	pcall(function()
		StarterGui:SetCore("VRLaserPointerMode", mode)
	end)
end

function VRNavigation:GetLocalHumanoid()
	local character = LocalPlayer.Character
	if not character then
		return
	end
	
	for _, child in pairs(character:GetChildren()) do
		if child:IsA("Humanoid") then
			return child
		end
	end
	return nil
end

function VRNavigation:HasBothHandControllers()
	return VRService:GetUserCFrameEnabled(Enum.UserCFrame.RightHand) and VRService:GetUserCFrameEnabled(Enum.UserCFrame.LeftHand)
end

function VRNavigation:HasAnyHandControllers()
	return VRService:GetUserCFrameEnabled(Enum.UserCFrame.RightHand) or VRService:GetUserCFrameEnabled(Enum.UserCFrame.LeftHand)
end

function VRNavigation:IsMobileVR()
	return UserInputService.TouchEnabled
end

function VRNavigation:HasGamepad()
	return UserInputService.GamepadEnabled
end

function VRNavigation:ShouldUseNavigationLaser()
	--Places where we use the navigation laser:
	-- mobile VR with any number of hands tracked
	-- desktop VR with only one hand tracked
	-- desktop VR with no hands and no gamepad (i.e. with Oculus remote?)
	--using an Xbox controller with a desktop VR headset means no laser since the user has a thumbstick.
	--in the future, we should query thumbstick presence with a features API
	if self:IsMobileVR() then
		return true		
	else
		if self:HasBothHandControllers() then
			return false
		end
		if not self:HasAnyHandControllers() then
			return not self:HasGamepad()
		end
		return true
	end
end



function VRNavigation:StartFollowingPath(newPath)
	currentPath = newPath
	currentPoints = currentPath:GetPointCoordinates()
	currentPointIdx = 1
	moving = true
	
	timeReachedLastPoint = tick()
	
	local humanoid = self:GetLocalHumanoid()
	if humanoid and humanoid.Torso and #currentPoints >= 1 then
		local dist = (currentPoints[1] - humanoid.Torso.Position).magnitude
		expectedTimeToNextPoint = dist / humanoid.WalkSpeed
	end
	
	movementUpdateEvent:Fire("targetPoint", self.currentDestination)	
end

function VRNavigation:GoToPoint(point)
	currentPath = true
	currentPoints = { point }
	currentPointIdx = 1
	moving = true

	local humanoid = self:GetLocalHumanoid()
	local distance = (humanoid.Torso.Position - point).magnitude	
	local estimatedTimeRemaining = distance / humanoid.WalkSpeed 
	
	timeReachedLastPoint = tick()
	expectedTimeToNextPoint = estimatedTimeRemaining
	
	movementUpdateEvent:Fire("targetPoint", point)
end

function VRNavigation:StopFollowingPath()
	currentPath = nil
	currentPoints = nil
	currentPointIdx = 0
	moving = false
	self.moveVector = ZERO_VECTOR3
end

function VRNavigation:TryComputePath(startPos, destination)
	local numAttempts = 0
	local newPath = nil
	
	while not newPath and numAttempts < 5 do
		newPath = PathfindingService:ComputeSmoothPathAsync(startPos, destination, MAX_PATHING_DISTANCE)
		numAttempts = numAttempts + 1
		
		if newPath.Status == Enum.PathStatus.ClosestNoPath or newPath.Status == Enum.PathStatus.ClosestOutOfRange then
			newPath = nil
			break
		end
		
		if newPath and newPath.Status == Enum.PathStatus.FailStartNotEmpty then
			startPos = startPos + (destination - startPos).unit
			newPath = nil
		end
		
		if newPath and newPath.Status == Enum.PathStatus.FailFinishNotEmpty then
			destination = destination + Vector3.new(0, 1, 0)
			newPath = nil
		end
	end
	
	return newPath
end

function VRNavigation:OnNavigationRequest(destinationCFrame, inputUserCFrame )
	local destinationPosition = destinationCFrame.p
	local lastDestination = self.currentDestination

	if not IsFiniteVector3(destinationPosition) then
		return
	end
	
	self.currentDestination = destinationPosition
		
	local humanoid = self:GetLocalHumanoid()
	if not humanoid or not humanoid.Torso then
		return
	end
		
	local currentPosition = humanoid.Torso.Position
	local distanceToDestination = (self.currentDestination - currentPosition).magnitude
		
	if distanceToDestination < NO_PATH_THRESHOLD then
		self:GoToPoint(self.currentDestination)
		return
	end		
		
	if not lastDestination or (self.currentDestination - lastDestination).magnitude > RECALCULATE_PATH_THRESHOLD then
		local newPath = self:TryComputePath(currentPosition, self.currentDestination)	
		if newPath then
			self:StartFollowingPath(newPath)
			if PathDisplay then
				PathDisplay.setCurrentPoints(self.currentPoints)
				PathDisplay.renderPath()
			end
		else
			self:StopFollowingPath()
			if PathDisplay then
				PathDisplay.clearRenderedPath()
			end
		end
	else
		if moving then
			self.currentPoints[#currentPoints] = self.currentDestination
		else
			self:GoToPoint(self.currentDestination)
		end
	end
end

function VRNavigation:OnJumpAction(actionName, inputState, inputObj)
	if inputState == Enum.UserInputState.Begin then
		self.isJumping = true
	end
	if FFlagPlayerScriptsBindAtPriority then
		return Enum.ContextActionResult.Sink
	end
end
function VRNavigation:BindJumpAction(active)
	if active then
		if not self.isJumpBound then
			self.isJumpBound = true
			if FFlagPlayerScriptsBindAtPriority then
				ContextActionService:BindActionAtPriority("VRJumpAction", (function() return self:OnJumpAction() end), false,
				 self.CONTROL_ACTION_PRIORITY, Enum.KeyCode.ButtonA)
			else
				ContextActionService:BindAction("VRJumpAction", (function() self:OnJumpAction() end), false, Enum.KeyCode.ButtonA)
			end
		end
	else
		if self.isJumpBound then
			self.isJumpBound = false
			ContextActionService:UnbindAction("VRJumpAction")
		end
	end
end

function VRNavigation:ControlCharacterGamepad(actionName, inputState, inputObject)
	if inputObject.KeyCode ~= Enum.KeyCode.Thumbstick1 then return end
	
	if inputState == Enum.UserInputState.Cancel then
		self.moveVector =  ZERO_VECTOR3
		return
	end
	
	if inputState ~= Enum.UserInputState.End then
		self:StopFollowingPath()		
		if PathDisplay then
			PathDisplay.clearRenderedPath()
		end
		
		if self:ShouldUseNavigationLaser() then
			self:BindJumpAction(true)
			self:SetLaserPointerMode("Hidden")
		end
		
		if inputObject.Position.magnitude > THUMBSTICK_DEADZONE then
			self.moveVector = Vector3.new(inputObject.Position.X, 0, -inputObject.Position.Y)
			if self.moveVector.magnitude > 0 then
				self.moveVector = self.moveVector.unit * math.min(1, inputObject.Position.magnitude)
			end

			self.moveLatch = true
		end
	else
		self.moveVector =  ZERO_VECTOR3
		
		if self:ShouldUseNavigationLaser() then
			self:BindJumpAction(false)
			self:SetLaserPointerMode("Navigation")
		end
		
		if self.moveLatch then
			self.moveLatch = false
			movementUpdateEvent:Fire("offtrack")
		end
	end
	if FFlagPlayerScriptsBindAtPriority then
		return Enum.ContextActionResult.Sink
	end
end

function VRNavigation:OnHeartbeat(dt)
	local newMoveVector = self.moveVector
	local humanoid = self:GetLocalHumanoid()
	if not humanoid or not humanoid.Torso then
		return
	end

	if self.moving and self.currentPoints then
		local currentPosition = humanoid.Torso.Position
		local goalPosition = currentPoints[1]
		local vectorToGoal = (goalPosition - currentPosition) * XZ_VECTOR3
		local moveDist = vectorToGoal.magnitude
		local moveDir = vectorToGoal / moveDist
			
		if moveDist < POINT_REACHED_THRESHOLD then
			local estimatedTimeRemaining = 0
			local prevPoint = currentPoints[1]
			for i, point in pairs(currentPoints) do
				if i ~= 1 then
					local dist = (point - prevPoint).magnitude
					prevPoint = point
					estimatedTimeRemaining = estimatedTimeRemaining + (dist / humanoid.WalkSpeed)
				end
			end					
			
			table.remove(currentPoints, 1)
			currentPointIdx = currentPointIdx + 1

			if #currentPoints == 0 then
				self:StopFollowingPath()
				if PathDisplay then
					PathDisplay.clearRenderedPath()
				end
				return
			else
				if PathDisplay then
					PathDisplay.setCurrentPoints(currentPoints)
					PathDisplay.renderPath()
				end
				
				local newGoal = currentPoints[1]
				local distanceToGoal = (newGoal - currentPosition).magnitude
				expectedTimeToNextPoint = distanceToGoal / humanoid.WalkSpeed
				timeReachedLastPoint = tick()
			end
		else
			local ignoreTable = { 
				game.Players.LocalPlayer.Character, 
				workspace.CurrentCamera 
			}
			local obstructRay = Ray.new(currentPosition - Vector3.new(0, 1, 0), moveDir * 3)
			local obstructPart, obstructPoint, obstructNormal = workspace:FindPartOnRayWithIgnoreList(obstructRay, ignoreTable)		
				
			if obstructPart then
				local heightOffset = Vector3.new(0, 100, 0)
				local jumpCheckRay = Ray.new(obstructPoint + moveDir * 0.5 + heightOffset, -heightOffset)
				local jumpCheckPart, jumpCheckPoint, jumpCheckNormal = workspace:FindPartOnRayWithIgnoreList(jumpCheckRay, ignoreTable)		
				
				local heightDifference = jumpCheckPoint.Y - currentPosition.Y
				if heightDifference < 6 and heightDifference > -2 then
					humanoid.Jump = true
				end
			end
			
			local timeSinceLastPoint = tick() - timeReachedLastPoint
			if timeSinceLastPoint > expectedTimeToNextPoint + OFFTRACK_TIME_THRESHOLD then
				self:StopFollowingPath()
				if PathDisplay then
					PathDisplay.clearRenderedPath()
				end
				
				movementUpdateEvent:Fire("offtrack")
			end
				
			newMoveVector = self.moveVector:Lerp(moveDir, dt * 10)
		end
	end
	
	if IsFiniteVector3(newMoveVector) then
		self.moveVector = newMoveVector
	end
end


function VRNavigation:OnUserCFrameEnabled()
	if self:ShouldUseNavigationLaser() then
		self:BindJumpAction(false)
		self:SetLaserPointerMode("Navigation")
	else
		self:BindJumpAction(true)
		self:SetLaserPointerMode("Hidden")
	end
end

function VRNavigation:Enable(enable)
	
	self.moveVector = ZERO_VECTOR3
	self.isJumping = false
	
	if enable then
		self.navigationRequestedConn = VRService.NavigationRequested:Connect(function(destinationCFrame, inputUserCFrame) self:OnNavigationRequest(destinationCFrame, inputUserCFrame) end)
		self.heartbeatConn = RunService.Heartbeat:Connect(function(dt) self:OnHeartbeat(dt) end)
		
		if FFlagPlayerScriptsBindAtPriority then 
			ContextActionService:BindAction("MoveThumbstick", (function(actionName, inputState, inputObject) return self:ControlCharacterGamepad(actionName, inputState, inputObject) end),
				false, self.CONTROL_ACTION_PRIORITY, Enum.KeyCode.Thumbstick1)
		else
			ContextActionService:BindAction("MoveThumbstick", (function(actionName, inputState, inputObject) self:ControlCharacterGamepad(actionName, inputState, inputObject) end), false, Enum.KeyCode.Thumbstick1)
		end
		ContextActionService:BindActivate(Enum.UserInputType.Gamepad1, Enum.KeyCode.ButtonR2)	
		
		self.userCFrameEnabledConn = VRService.UserCFrameEnabled:Connect(function() self:OnUserCFrameEnabled() end)
		self:OnUserCFrameEnabled()

		VRService:SetTouchpadMode(Enum.VRTouchpad.Left, Enum.VRTouchpadMode.VirtualThumbstick)
		VRService:SetTouchpadMode(Enum.VRTouchpad.Right, Enum.VRTouchpadMode.ABXY)

		self.enabled = true
	else
		-- Disable
		self:StopFollowingPath()
		
		ContextActionService:UnbindAction("MoveThumbstick")
		ContextActionService:UnbindActivate(Enum.UserInputType.Gamepad1, Enum.KeyCode.ButtonR2)
		
		self:BindJumpAction(false)
		self:SetLaserPointerMode("Disabled")
		
		if self.navigationRequestedConn then
			self.navigationRequestedConn:Disconnect()
			self.navigationRequestedConn = nil
		end
		if self.heartbeatConn then
			self.heartbeatConn:Disconnect()
			self.heartbeatConn = nil
		end
		if self.userCFrameEnabledConn then
			self.userCFrameEnabledConn:Disconnect()
			self.userCFrameEnabledConn = nil
		end
		self.enabled = false
	end
end

return VRNavigation
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXAF2157BFED3F4316B27DB315DA0AAAA6">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">VehicleController</string>
							<string name="ScriptGuid">{72635BA8-9518-4A08-B4DE-9FB4037E6919}</string>
							<ProtectedString name="Source"><![CDATA[--[[
	// FileName: VehicleControl
	// Version 1.0
	// Written by: jmargh
	// Description: Implements in-game vehicle controls for all input devices
	
	// NOTE: This works for basic vehicles (single vehicle seat). If you use custom VehicleSeat code,
	// multiple VehicleSeats or your own implementation of a VehicleSeat this will not work.
--]]
local ContextActionService = game:GetService("ContextActionService")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

--[[ Constants ]]--
-- Set this to true if you want to instead use the triggers for the throttle
local useTriggersForThrottle = true
-- Also set this to true if you want the thumbstick to not affect throttle, only triggers when a gamepad is conected
local onlyTriggersForThrottle = false
local ZERO_VECTOR3 = Vector3.new(0,0,0)

local bindAtPriorityFlagExists, bindAtPriorityFlagEnabled = pcall(function()
	return UserSettings():IsUserFeatureEnabled("UserPlayerScriptsBindAtPriority")
end)
local FFlagPlayerScriptsBindAtPriority = bindAtPriorityFlagExists and bindAtPriorityFlagEnabled

-- Note that VehicleController does not derive from BaseCharacterController, it is a special case
local VehicleController = {}
VehicleController.__index = VehicleController

function VehicleController.new(CONTROL_ACTION_PRIORITY)
	local self = setmetatable({}, VehicleController)
	
	self.CONTROL_ACTION_PRIORITY = CONTROL_ACTION_PRIORITY
	
	self.enabled = false
	self.vehicleSeat = nil
	self.throttle = 0
	self.steer = 0
	
	self.acceleration = 0
	self.decceleration = 0
	self.turningRight = 0
	self.turningLeft = 0
	
	self.vehicleMoveVector = ZERO_VECTOR3

	return self
end

function VehicleController:BindContextActions()
	if useTriggersForThrottle then
		ContextActionService:BindActionAtPriority("throttleAccel", (function(actionName, inputState, inputObject)
			self:OnThrottleAccel(actionName, inputState, inputObject)
			return Enum.ContextActionResult.Pass
		end), false, self.CONTROL_ACTION_PRIORITY, Enum.KeyCode.ButtonR2)
		ContextActionService:BindActionAtPriority("throttleDeccel", (function(actionName, inputState, inputObject)
			self:OnThrottleDeccel(actionName, inputState, inputObject)
			return Enum.ContextActionResult.Pass
		end), false, self.CONTROL_ACTION_PRIORITY, Enum.KeyCode.ButtonL2)
	end
	ContextActionService:BindActionAtPriority("arrowSteerRight", (function(actionName, inputState, inputObject)
		self:OnSteerRight(actionName, inputState, inputObject)
		return Enum.ContextActionResult.Pass
	end), false, self.CONTROL_ACTION_PRIORITY, Enum.KeyCode.Right)
	ContextActionService:BindActionAtPriority("arrowSteerLeft", (function(actionName, inputState, inputObject)
		self:OnSteerLeft(actionName, inputState, inputObject)
		return Enum.ContextActionResult.Pass
	end), false, self.CONTROL_ACTION_PRIORITY, Enum.KeyCode.Left)
end

function VehicleController:Enable(enable, vehicleSeat)
	if enable == self.enabled and vehicleSeat == self.vehicleSeat then
		return
	end
	
	self.vehicleMoveVector = ZERO_VECTOR3
	
	if enable then
		if vehicleSeat then
			self.vehicleSeat = vehicleSeat
			if FFlagPlayerScriptsBindAtPriority then
				self:BindContextActions()
			else
				if useTriggersForThrottle then
					ContextActionService:BindAction("throttleAccel", (function(actionName, inputState, inputObject)
						self:OnThrottleAccel(actionName, inputState, inputObject)
						return Enum.ContextActionResult.Pass
					end), false, Enum.KeyCode.ButtonR2)
					ContextActionService:BindAction("throttleDeccel", (function(actionName, inputState, inputObject)
						self:OnThrottleDeccel(actionName, inputState, inputObject)
						return Enum.ContextActionResult.Pass
					end), false, Enum.KeyCode.ButtonL2)
				end
				ContextActionService:BindAction("arrowSteerRight", (function(actionName, inputState, inputObject)
					self:OnSteerRight(actionName, inputState, inputObject)
					return Enum.ContextActionResult.Pass
				end), false, Enum.KeyCode.Right)
				ContextActionService:BindAction("arrowSteerLeft", (function(actionName, inputState, inputObject)
					self:OnSteerLeft(actionName, inputState, inputObject)
					return Enum.ContextActionResult.Pass
				end), false, Enum.KeyCode.Left)
			end
		end
	else
		if useTriggersForThrottle then
			ContextActionService:UnbindAction("throttleAccel")
			ContextActionService:UnbindAction("throttleDeccel")
		end
		ContextActionService:UnbindAction("arrowSteerRight")
		ContextActionService:UnbindAction("arrowSteerLeft")
		self.vehicleSeat = nil
	end
end

function VehicleController:OnThrottleAccel(actionName, inputState, inputObject)	
	self.acceleration = (inputState ~= Enum.UserInputState.End) and -1 or 0
	self.throttle = self.acceleration + self.decceleration
end

function VehicleController:OnThrottleDeccel(actionName, inputState, inputObject)
	self.decceleration = (inputState ~= Enum.UserInputState.End) and 1 or 0
	self.throttle = self.acceleration + self.decceleration
end

function VehicleController:OnSteerRight(actionName, inputState, inputObject)
	self.turningRight = (inputState ~= Enum.UserInputState.End) and 1 or 0
	self.steer = self.turningRight + self.turningLeft
end

function VehicleController:OnSteerLeft(actionName, inputState, inputObject)
	self.turningLeft = (inputState ~= Enum.UserInputState.End) and -1 or 0
	self.steer = self.turningRight + self.turningLeft
end

-- Call this from a function bound to Renderstep with Input Priority
function VehicleController:Update(moveVector, usingGamepad)
	if self.vehicleSeat then
		moveVector = moveVector + Vector3.new(self.steer, 0, self.throttle)
		if usingGamepad and onlyTriggersForThrottle and useTriggersForThrottle then 
			self.vehicleSeat.ThrottleFloat = -self.throttle
		else
			self.vehicleSeat.ThrottleFloat = -moveVector.Z
		end
		self.vehicleSeat.SteerFloat = moveVector.X
		
		return moveVector, true
	end
	return moveVector, false
end

return VehicleController
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX295F2201B112457DB9CB33FB4DFAA1C4">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">TouchJump</string>
							<string name="ScriptGuid">{D8D813F3-11BA-4B8A-8011-DEFA54935100}</string>
							<ProtectedString name="Source"><![CDATA[--[[
	// FileName: TouchJump
	// Version 1.0
	// Written by: jmargh
	// Description: Implements jump controls for touch devices. Use with Thumbstick and Thumbpad
--]]

local Players = game:GetService("Players")
local GuiService = game:GetService("GuiService")

--[[ Constants ]]--
local TOUCH_CONTROL_SHEET = "rbxasset://textures/ui/Input/TouchControlsSheetV2.png"

--[[ The Module ]]--
local BaseCharacterController = require(script.Parent:WaitForChild("BaseCharacterController"))
local TouchJump = setmetatable({}, BaseCharacterController)
TouchJump.__index = TouchJump

function TouchJump.new()
	local self = setmetatable(BaseCharacterController.new(), TouchJump)

	self.parentUIFrame = nil
	self.jumpButton = nil
	self.characterAddedConn = nil
	self.humanoidStateEnabledChangedConn = nil
	self.humanoidJumpPowerConn = nil
	self.humanoidParentConn = nil
	self.externallyEnabled = false
	self.jumpPower = 0
	self.jumpStateEnabled = true
	self.isJumping = false
	self.humanoid = nil -- saved reference because property change connections are made using it

	return self
end

function TouchJump:EnableButton(enable)
	if enable then
		if not self.jumpButton then
			self:Create()
		end
		local humanoid = Players.LocalPlayer.Character and Players.LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
		if humanoid and self.externallyEnabled then
			if self.externallyEnabled then
				if humanoid.JumpPower > 0 then
					self.jumpButton.Visible = true
				end
			end
		end
	else
		self.jumpButton.Visible = false
		self.isJumping = false
		self.jumpButton.ImageRectOffset = Vector2.new(1, 146)
	end
end

function TouchJump:UpdateEnabled()
	if self.jumpPower > 0 and self.jumpStateEnabled then
		self:EnableButton(true)
	else
		self:EnableButton(false)
	end
end

function TouchJump:HumanoidChanged(prop)
	local humanoid = Players.LocalPlayer.Character and Players.LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
	if humanoid then
		if prop == "JumpPower" then
			self.jumpPower =  humanoid.JumpPower
			self:UpdateEnabled()
		elseif prop == "Parent" then
			if not humanoid.Parent then
				self.humanoidChangeConn:Disconnect()
			end
		end
	end
end

function TouchJump:HumanoidStateEnabledChanged(state, isEnabled)
	if state == Enum.HumanoidStateType.Jumping then
		self.jumpStateEnabled = isEnabled
		self:UpdateEnabled()
	end
end

function TouchJump:CharacterAdded(char)
	if self.humanoidChangeConn then
		self.humanoidChangeConn:Disconnect()
		self.humanoidChangeConn = nil
	end

	self.humanoid = char:FindFirstChildOfClass("Humanoid")
	while not self.humanoid do
		char.ChildAdded:wait()
		self.humanoid = char:FindFirstChildOfClass("Humanoid")
	end

	self.humanoidJumpPowerConn = self.humanoid:GetPropertyChangedSignal("JumpPower"):Connect(function()
		self.jumpPower =  self.humanoid.JumpPower
		self:UpdateEnabled()
	end)

	self.humanoidParentConn = self.humanoid:GetPropertyChangedSignal("Parent"):Connect(function()
		if not self.humanoid.Parent then
			self.humanoidJumpPowerConn:Disconnect()
			self.humanoidJumpPowerConn = nil
			self.humanoidParentConn:Disconnect()
			self.humanoidParentConn = nil
		end
	end)

	self.humanoidStateEnabledChangedConn = self.humanoid.StateEnabledChanged:Connect(function(state, enabled)
		self:HumanoidStateEnabledChanged(state, enabled)
	end)

	self.jumpPower = self.humanoid.JumpPower
	self.jumpStateEnabled = self.humanoid:GetStateEnabled(Enum.HumanoidStateType.Jumping)
	self:UpdateEnabled()
end

function TouchJump:SetupCharacterAddedFunction()
	self.characterAddedConn = Players.LocalPlayer.CharacterAdded:Connect(function(char)
		self:CharacterAdded(char)
	end)
	if Players.LocalPlayer.Character then
		self:CharacterAdded(Players.LocalPlayer.Character)
	end
end

function TouchJump:Enable(enable, parentFrame)
	self.parentUIFrame = parentFrame
	self.externallyEnabled = enable
	self:EnableButton(enable)
end

function TouchJump:Create()
	if not self.parentUIFrame then
		return
	end

	if self.jumpButton then
		self.jumpButton:Destroy()
		self.jumpButton = nil
	end

	local minAxis = math.min(self.parentUIFrame.AbsoluteSize.x, self.parentUIFrame.AbsoluteSize.y)
	local isSmallScreen = minAxis <= 500
	local jumpButtonSize = isSmallScreen and 70 or 120

	self.jumpButton = Instance.new("ImageButton")
	self.jumpButton.Name = "JumpButton"
	self.jumpButton.Visible = false
	self.jumpButton.BackgroundTransparency = 1
	self.jumpButton.Image = TOUCH_CONTROL_SHEET
	self.jumpButton.ImageRectOffset = Vector2.new(1, 146)
	self.jumpButton.ImageRectSize = Vector2.new(144, 144)
	self.jumpButton.Size = UDim2.new(0, jumpButtonSize, 0, jumpButtonSize)

    self.jumpButton.Position = isSmallScreen and UDim2.new(1, -(jumpButtonSize*1.5-10), 1, -jumpButtonSize - 20) or
        UDim2.new(1, -(jumpButtonSize*1.5-10), 1, -jumpButtonSize * 1.75)

	local touchObject = nil
	self.jumpButton.InputBegan:connect(function(inputObject)
		--A touch that starts elsewhere on the screen will be sent to a frame's InputBegan event
		--if it moves over the frame. So we check that this is actually a new touch (inputObject.UserInputState ~= Enum.UserInputState.Begin)
		if touchObject or inputObject.UserInputType ~= Enum.UserInputType.Touch
			or inputObject.UserInputState ~= Enum.UserInputState.Begin then
			return
		end

		touchObject = inputObject
		self.jumpButton.ImageRectOffset = Vector2.new(146, 146)
		self.isJumping = true
	end)

	local OnInputEnded = function()
		touchObject = nil
		self.isJumping = false
		self.jumpButton.ImageRectOffset = Vector2.new(1, 146)
	end

	self.jumpButton.InputEnded:connect(function(inputObject)
		if inputObject == touchObject then
			OnInputEnded()
		end
	end)

	GuiService.MenuOpened:connect(function()
		if touchObject then
			OnInputEnded()
		end
	end)

	if not self.characterAddedConn then
		self:SetupCharacterAddedFunction()
	end

	self.jumpButton.Parent = self.parentUIFrame
end

return TouchJump
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX41F7E9BC172B40879AF621CB4BA69B7F">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">PathDisplay</string>
							<string name="ScriptGuid">{9289BBC9-17E1-4F73-A7C5-FDFCD6ABA2C2}</string>
							<ProtectedString name="Source"><![CDATA[

local PathDisplay = {}
PathDisplay.spacing = 8
PathDisplay.image = "rbxasset://textures/Cursors/Gamepad/Pointer.png"
PathDisplay.imageSize = Vector2.new(2, 2)

local currentPoints = {}
local renderedPoints = {}

local pointModel = Instance.new("Model")
pointModel.Name = "PathDisplayPoints"

local adorneePart = Instance.new("Part")
adorneePart.Anchored = true
adorneePart.CanCollide = false
adorneePart.Transparency = 1
adorneePart.Name = "PathDisplayAdornee"
adorneePart.CFrame = CFrame.new(0, 0, 0)
adorneePart.Parent = pointModel

local pointPool = {}
local poolTop = 30
for i = 1, poolTop do
	local point = Instance.new("ImageHandleAdornment")
	point.Archivable = false
	point.Adornee = adorneePart
	point.Image = PathDisplay.image
	point.Size = PathDisplay.imageSize
	pointPool[i] = point
end

local function retrieveFromPool()
	local point = pointPool[1]
	if not point then
		return
	end
	
	pointPool[1], pointPool[poolTop] = pointPool[poolTop], nil
	poolTop = poolTop - 1
	return point
end

local function returnToPool(point)
	poolTop = poolTop + 1
	pointPool[poolTop] = point
end

local function renderPoint(point, isLast)
	if poolTop == 0 then
		return
	end

	local rayDown = Ray.new(point + Vector3.new(0, 2, 0), Vector3.new(0, -8, 0))
	local hitPart, hitPoint, hitNormal = workspace:FindPartOnRayWithIgnoreList(rayDown, { game.Players.LocalPlayer.Character, workspace.CurrentCamera  }) 	
	if not hitPart then
		return
	end

	local pointCFrame = CFrame.new(hitPoint, hitPoint + hitNormal)
	
	local point = retrieveFromPool()
	point.CFrame = pointCFrame
	point.Parent = pointModel
	return point
end

function PathDisplay.setCurrentPoints(points)
	if typeof(points) == 'table' then
		currentPoints = points
	else
		currentPoints = {}
	end
end

function PathDisplay.clearRenderedPath()
	for _, oldPoint in ipairs(renderedPoints) do
		oldPoint.Parent = nil
		returnToPool(oldPoint)
	end
	renderedPoints = {}
	pointModel.Parent = nil
end

function PathDisplay.renderPath()
	PathDisplay.clearRenderedPath()
	if not currentPoints or #currentPoints == 0 then
		return
	end

	local currentIdx = #currentPoints
	local lastPos = currentPoints[currentIdx]	
	local distanceBudget = 0
	
	renderedPoints[1] = renderPoint(lastPos, true)
	if not renderedPoints[1] then
		return
	end
	
	while true do
		local currentPoint = currentPoints[currentIdx]
		local nextPoint = currentPoints[currentIdx - 1]
		
		if currentIdx < 2 then
			break
		else
			
			local toNextPoint = nextPoint - currentPoint
			local distToNextPoint = toNextPoint.magnitude	
			
			if distanceBudget > distToNextPoint then
				distanceBudget = distanceBudget - distToNextPoint
				currentIdx = currentIdx - 1
			else
				local dirToNextPoint = toNextPoint.unit
				local pointPos = currentPoint + (dirToNextPoint * distanceBudget)
				local point = renderPoint(pointPos, false)
				
				if point then
					renderedPoints[#renderedPoints + 1] = point
				end
				
				distanceBudget = distanceBudget + PathDisplay.spacing
			end
		end
	end
	
	pointModel.Parent = workspace.CurrentCamera
end

return PathDisplay
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXDD6741492B634EFBBA1BC0A09B876C29">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">DynamicThumbstick</string>
							<string name="ScriptGuid">{762118C8-2187-4377-A4F8-129673D9236B}</string>
							<ProtectedString name="Source"><![CDATA[--[[ Constants ]]--
local ZERO_VECTOR3 = Vector3.new(0,0,0)
local TOUCH_CONTROLS_SHEET = "rbxasset://textures/ui/Input/TouchControlsSheetV2.png"

local MIDDLE_TRANSPARENCIES = {
	1 - 0.89,
	1 - 0.70,
	1 - 0.60,
	1 - 0.50,
	1 - 0.40,
	1 - 0.30,
	1 - 0.25
}
local NUM_MIDDLE_IMAGES = #MIDDLE_TRANSPARENCIES

local FADE_IN_OUT_BACKGROUND = true
local FADE_IN_OUT_MAX_ALPHA = 0.35

local FADE_IN_OUT_HALF_DURATION_DEFAULT = 0.3
local FADE_IN_OUT_BALANCE_DEFAULT = 0.5
local ThumbstickFadeTweenInfo = TweenInfo.new(0.15, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut)

local Players = game:GetService("Players")
local GuiService = game:GetService("GuiService")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")

--[[ The Module ]]--
local BaseCharacterController = require(script.Parent:WaitForChild("BaseCharacterController"))
local DynamicThumbstick = setmetatable({}, BaseCharacterController)
DynamicThumbstick.__index = DynamicThumbstick

function DynamicThumbstick.new()
	local self = setmetatable(BaseCharacterController.new(), DynamicThumbstick)

	self.humanoid = nil

	self.tools = {}
	self.toolEquipped = nil

	self.revertAutoJumpEnabledToFalse = false

	self.moveTouchObject = nil
	self.moveTouchStartPosition = nil

	self.startImage = nil
	self.endImage = nil
	self.middleImages = {}

	self.startImageFadeTween = nil
	self.endImageFadeTween = nil
	self.middleImageFadeTweens = {}

	self.isFirstTouch = true

	self.isFollowStick = false
	self.thumbstickFrame = nil
	self.onTouchMovedConn = nil
	self.onTouchEndedConn = nil
	self.onTouchActivateConn = nil
	self.onRenderSteppedConn = nil

	self.fadeInAndOutBalance = FADE_IN_OUT_BALANCE_DEFAULT
	self.fadeInAndOutHalfDuration = FADE_IN_OUT_HALF_DURATION_DEFAULT
	self.hasFadedBackgroundInPortrait = false
	self.hasFadedBackgroundInLandscape = false

	self.tweenInAlphaStart = nil
	self.tweenOutAlphaStart = nil

	-- If this module changes a player's humanoid's AutoJumpEnabled, it saves
	-- the previous state in this variable to revert to
	self.shouldRevertAutoJumpOnDisable = false

	return self
end

-- Note: Overrides base class GetIsJumping with get-and-clear behavior to do a single jump
-- rather than sustained jumping. This is only to preserve the current behavior through the refactor.
function DynamicThumbstick:GetIsJumping()
	local wasJumping = self.isJumping
	self.isJumping = false
	return wasJumping
end

function DynamicThumbstick:EnableAutoJump(enable)
	local humanoid = Players.LocalPlayer.Character and Players.LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
	if humanoid then
		if enable then
			self.shouldRevertAutoJumpOnDisable = (humanoid.AutoJumpEnabled == false) and (Players.LocalPlayer.DevTouchMovementMode == Enum.DevTouchMovementMode.UserChoice)
			humanoid.AutoJumpEnabled = true
		elseif self.shouldRevertAutoJumpOnDisable then
			humanoid.AutoJumpEnabled = false
		end
	end
end

function DynamicThumbstick:Enable(enable, uiParentFrame)
	if enable == nil then return false end			-- If nil, return false (invalid argument)
	enable = enable and true or false				-- Force anything non-nil to boolean before comparison
	if self.enabled == enable then return true end	-- If no state change, return true indicating already in requested state

	if enable then
		-- Enable
		if not self.thumbstickFrame then
			self:Create(uiParentFrame)
		end

		if Players.LocalPlayer.Character then
			self:OnCharacterAdded(Players.LocalPlayer.Character)
		else
			Players.LocalPlayer.CharacterAdded:Connect(function(char)
				self:OnCharacterAdded(char)
			end)
		end
	else
		-- Disable
		self:OnInputEnded() -- Cleanup
	end

	self.enabled = enable
	self.thumbstickFrame.Visible = enable
end

function DynamicThumbstick:OnCharacterAdded(char)

	for _, child in ipairs(char:GetChildren()) do
		if child:IsA("Tool") then
			self.toolEquipped = child
		end
	end

	char.ChildAdded:Connect(function(child)
		if child:IsA("Tool") then
			self.toolEquipped = child
		elseif child:IsA("Humanoid") then
			self:EnableAutoJump(true)
		end

	end)
	char.ChildRemoved:Connect(function(child)
		if child == self.toolEquipped then
			self.toolEquipped = nil
		end
	end)

	self.humanoid = char:FindFirstChildOfClass("Humanoid")
	if self.humanoid then
		self:EnableAutoJump(true)
	end
end

-- Was called OnMoveTouchEnded in previous version
function DynamicThumbstick:OnInputEnded()
	self.moveTouchObject = nil
	self.moveVector = ZERO_VECTOR3
	self:FadeThumbstick(false)
	self.thumbstickFrame.Active = true
end

function DynamicThumbstick:FadeThumbstick(visible)
	if not visible and self.moveTouchObject then
		return
	end
	if self.isFirstTouch then return end

	if self.startImageFadeTween then
		self.startImageFadeTween:Cancel()
	end
	if self.endImageFadeTween then
		self.endImageFadeTween:Cancel()
	end
	for i = 1, #self.middleImages do
		if self. middleImageFadeTweens[i] then
			self.middleImageFadeTweens[i]:Cancel()
		end
	end

	if visible then
		self.startImageFadeTween = TweenService:Create(self.startImage, ThumbstickFadeTweenInfo, { ImageTransparency = 0 })
		self.startImageFadeTween:Play()

		self.endImageFadeTween = TweenService:Create(self.endImage, ThumbstickFadeTweenInfo, { ImageTransparency = 0.2 })
		self.endImageFadeTween:Play()

		for i = 1, #self.middleImages do
			self.middleImageFadeTweens[i] = TweenService:Create(self.middleImages[i], ThumbstickFadeTweenInfo, { ImageTransparency = MIDDLE_TRANSPARENCIES[i] })
			self.middleImageFadeTweens[i]:Play()
		end
	else
		self.startImageFadeTween = TweenService:Create(self.startImage, ThumbstickFadeTweenInfo, { ImageTransparency = 1 })
		self.startImageFadeTween:Play()

		self.endImageFadeTween = TweenService:Create(self.endImage, ThumbstickFadeTweenInfo, { ImageTransparency = 1 })
		self.endImageFadeTween:Play()

		for i = 1, #self.middleImages do
			self.middleImageFadeTweens[i] = TweenService:Create(self.middleImages[i], ThumbstickFadeTweenInfo, { ImageTransparency = 1 })
			self.middleImageFadeTweens[i]:Play()
		end
	end
end

function DynamicThumbstick:FadeThumbstickFrame(fadeDuration, fadeRatio)
	self.fadeInAndOutHalfDuration = fadeDuration * 0.5
	self.fadeInAndOutBalance = fadeRatio
	self.tweenInAlphaStart = tick()
end

function DynamicThumbstick:Create(parentFrame)
	if self.thumbstickFrame then
		self.thumbstickFrame:Destroy()
		self.thumbstickFrame = nil
		if self.onTouchMovedConn then
			self.onTouchMovedConn:Disconnect()
			self.onTouchMovedConn = nil
		end
		if self.onTouchEndedConn then
			self.onTouchEndedCon:Disconnect()
			self.onTouchEndedCon = nil
		end
		if self.onRenderSteppedConn then
			self.onRenderSteppedConn:Disconnect()
			self.onRenderSteppedConn = nil
		end
		if self.onTouchActivateConn then
			self.onTouchActivateConn:Disconnect()
			self.onTouchActivateConn = nil
		end
	end

	local ThumbstickSize = 45
	local ThumbstickRingSize = 20
	local MiddleSize = 10
	local MiddleSpacing = MiddleSize + 4
	local RadiusOfDeadZone = 2
	local RadiusOfMaxSpeed = 20

	local screenSize = parentFrame.AbsoluteSize
	local isBigScreen = math.min(screenSize.x, screenSize.y) > 500
	if isBigScreen then
		ThumbstickSize = ThumbstickSize * 2
		ThumbstickRingSize = ThumbstickRingSize * 2
		MiddleSize = MiddleSize * 2
		MiddleSpacing = MiddleSpacing * 2
		RadiusOfDeadZone = RadiusOfDeadZone * 2
		RadiusOfMaxSpeed = RadiusOfMaxSpeed * 2
	end

	local function layoutThumbstickFrame(portraitMode)
		if portraitMode then
			self.thumbstickFrame.Size = UDim2.new(1, 0, 0.4, 0)
			self.thumbstickFrame.Position = UDim2.new(0, 0, 0.6, 0)
		else
			self.thumbstickFrame.Size = UDim2.new(0.4, 0, 2/3, 0)
			self.thumbstickFrame.Position = UDim2.new(0, 0, 1/3, 0)
		end
	end

	self.thumbstickFrame = Instance.new("TextButton")
	self.thumbstickFrame.Text = ""
	self.thumbstickFrame.Name = "DynamicThumbstickFrame"
	self.thumbstickFrame.Visible = false
	self.thumbstickFrame.BackgroundTransparency = 1.0
	self.thumbstickFrame.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
	layoutThumbstickFrame(false)

	self.startImage = Instance.new("ImageLabel")
	self.startImage.Name = "ThumbstickStart"
	self.startImage.Visible = true
	self.startImage.BackgroundTransparency = 1
	self.startImage.Image = TOUCH_CONTROLS_SHEET
	self.startImage.ImageRectOffset = Vector2.new(1,1)
	self.startImage.ImageRectSize = Vector2.new(144, 144)
	self.startImage.ImageColor3 = Color3.new(0, 0, 0)
	self.startImage.AnchorPoint = Vector2.new(0.5, 0.5)
	self.startImage.Position = UDim2.new(0, ThumbstickRingSize * 3.3, 1, -ThumbstickRingSize * 2.8)
	self.startImage.Size = UDim2.new(0, ThumbstickRingSize * 3.7, 0, ThumbstickRingSize * 3.7)
	self.startImage.ZIndex = 10
	self.startImage.Parent = self.thumbstickFrame

	self.endImage = Instance.new("ImageLabel")
	self.endImage.Name = "ThumbstickEnd"
	self.endImage.Visible = true
	self.endImage.BackgroundTransparency = 1
	self.endImage.Image = TOUCH_CONTROLS_SHEET
	self.endImage.ImageRectOffset = Vector2.new(1,1)
	self.endImage.ImageRectSize =  Vector2.new(144, 144)
	self.endImage.AnchorPoint = Vector2.new(0.5, 0.5)
	self.endImage.Position = self.startImage.Position
	self.endImage.Size = UDim2.new(0, ThumbstickSize * 0.8, 0, ThumbstickSize * 0.8)
	self.endImage.ZIndex = 10
	self.endImage.Parent = self.thumbstickFrame

	for i = 1, NUM_MIDDLE_IMAGES do
		self.middleImages[i] = Instance.new("ImageLabel")
		self.middleImages[i].Name = "ThumbstickMiddle"
		self.middleImages[i].Visible = false
		self.middleImages[i].BackgroundTransparency = 1
		self.middleImages[i].Image = TOUCH_CONTROLS_SHEET
		self.middleImages[i].ImageRectOffset = Vector2.new(1,1)
		self.middleImages[i].ImageRectSize = Vector2.new(144, 144)
		self.middleImages[i].ImageTransparency = MIDDLE_TRANSPARENCIES[i]
		self.middleImages[i].AnchorPoint = Vector2.new(0.5, 0.5)
		self.middleImages[i].ZIndex = 9
		self.middleImages[i].Parent = self.thumbstickFrame
	end

	local CameraChangedConn = nil
	local function onCurrentCameraChanged()
		if CameraChangedConn then
			CameraChangedConn:Disconnect()
			CameraChangedConn = nil
		end
		local newCamera = workspace.CurrentCamera
		if newCamera then
			local function onViewportSizeChanged()
				local size = newCamera.ViewportSize
				local portraitMode = size.X < size.Y
				layoutThumbstickFrame(portraitMode)
			end
			CameraChangedConn = newCamera:GetPropertyChangedSignal("ViewportSize"):Connect(onViewportSizeChanged)
			onViewportSizeChanged()
		end
	end
	workspace:GetPropertyChangedSignal("CurrentCamera"):Connect(onCurrentCameraChanged)
	if workspace.CurrentCamera then
		onCurrentCameraChanged()
	end

	self.moveTouchStartPosition = nil

	self.startImageFadeTween = nil
	self.endImageFadeTween = nil
	self.middleImageFadeTweens = {}

	local function doMove(direction)
		local currentMoveVector = direction

		-- Scaled Radial Dead Zone
		local inputAxisMagnitude = currentMoveVector.magnitude
		if inputAxisMagnitude < RadiusOfDeadZone then
			currentMoveVector = Vector3.new()
		else
			currentMoveVector = currentMoveVector.unit*(1 - math.max(0, (RadiusOfMaxSpeed - currentMoveVector.magnitude)/RadiusOfMaxSpeed))
			currentMoveVector = Vector3.new(currentMoveVector.x, 0, currentMoveVector.y)
		end

		self.moveVector = currentMoveVector
	end

	local function layoutMiddleImages(startPos, endPos)
		local startDist = (ThumbstickSize / 2) + MiddleSize
		local vector = endPos - startPos
		local distAvailable = vector.magnitude - (ThumbstickRingSize / 2) - MiddleSize
		local direction = vector.unit

		local distNeeded = MiddleSpacing * NUM_MIDDLE_IMAGES
		local spacing = MiddleSpacing

		if distNeeded < distAvailable then
			spacing = distAvailable / NUM_MIDDLE_IMAGES
		end

		for i = 1, NUM_MIDDLE_IMAGES do
			local image = self.middleImages[i]
			local distWithout = startDist + (spacing * (i - 2))
			local currentDist = startDist + (spacing * (i - 1))

			if distWithout < distAvailable then
				local pos = endPos - direction * currentDist
				local exposedFraction = math.clamp(1 - ((currentDist - distAvailable) / spacing), 0, 1)

				image.Visible = true
				image.Position = UDim2.new(0, pos.X, 0, pos.Y)
				image.Size = UDim2.new(0, MiddleSize * exposedFraction, 0, MiddleSize * exposedFraction)
			else
				image.Visible = false
			end
		end
	end

	local function moveStick(pos)
		local startPos = Vector2.new(self.moveTouchStartPosition.X, self.moveTouchStartPosition.Y) - self.thumbstickFrame.AbsolutePosition
		local endPos = Vector2.new(pos.X, pos.Y) - self.thumbstickFrame.AbsolutePosition
		self.endImage.Position = UDim2.new(0, endPos.X, 0, endPos.Y)
		layoutMiddleImages(startPos, endPos)
	end

	-- input connections
	self.thumbstickFrame.InputBegan:Connect(function(inputObject)
		if inputObject.UserInputType ~= Enum.UserInputType.Touch or inputObject.UserInputState ~= Enum.UserInputState.Begin then
			return
		end
		if self.moveTouchObject then
			return
		end

		if self.isFirstTouch then
			self.isFirstTouch = false
			local tweenInfo = TweenInfo.new(0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.Out,0,false,0)
			TweenService:Create(self.startImage, tweenInfo, {Size = UDim2.new(0, 0, 0, 0)}):Play()
			TweenService:Create(self.endImage, tweenInfo, {Size = UDim2.new(0, ThumbstickSize, 0, ThumbstickSize), ImageColor3 = Color3.new(0,0,0)}):Play()
		end

		self.moveTouchObject = inputObject
		self.moveTouchStartPosition = inputObject.Position
		local startPosVec2 = Vector2.new(inputObject.Position.X - self.thumbstickFrame.AbsolutePosition.X, inputObject.Position.Y - self.thumbstickFrame.AbsolutePosition.Y)

		self.startImage.Visible = true
		self.startImage.Position = UDim2.new(0, startPosVec2.X, 0, startPosVec2.Y)
		self.endImage.Visible = true
		self.endImage.Position = self.startImage.Position

		self:FadeThumbstick(true)
		moveStick(inputObject.Position)

		if FADE_IN_OUT_BACKGROUND then
			local playerGui = Players.LocalPlayer:FindFirstChildOfClass("PlayerGui")
			local hasFadedBackgroundInOrientation = false

			-- only fade in/out the background once per orientation
			if playerGui then
				if playerGui.CurrentScreenOrientation == Enum.ScreenOrientation.LandscapeLeft or
					playerGui.CurrentScreenOrientation == Enum.ScreenOrientation.LandscapeRight then
						hasFadedBackgroundInOrientation = self.hasFadedBackgroundInLandscape
						self.hasFadedBackgroundInLandscape = true
				elseif playerGui.CurrentScreenOrientation == Enum.ScreenOrientation.Portrait then
						hasFadedBackgroundInOrientation = self.hasFadedBackgroundInPortrait
						self.hasFadedBackgroundInPortrait = true
				end
			end

			if not hasFadedBackgroundInOrientation then
				self.fadeInAndOutHalfDuration = FADE_IN_OUT_HALF_DURATION_DEFAULT
				self.fadeInAndOutBalance = FADE_IN_OUT_BALANCE_DEFAULT
				self.tweenInAlphaStart = tick()
			end
		end
	end)

	self.onTouchMovedConn = UserInputService.TouchMoved:connect(function(inputObject)
		if inputObject == self.moveTouchObject then
			self.thumbstickFrame.Active = false
			local direction = Vector2.new(inputObject.Position.x - self.moveTouchStartPosition.x, inputObject.Position.y - self.moveTouchStartPosition.y)
			if math.abs(direction.x) > 0 or math.abs(direction.y) > 0 then
				doMove(direction)
				moveStick(inputObject.Position)
			end
		end
	end)

	self.onRenderSteppedConn = RunService.RenderStepped:Connect(function()
		if self.tweenInAlphaStart ~= nil then
			local delta = tick() - self.tweenInAlphaStart
			local fadeInTime = (self.fadeInAndOutHalfDuration * 2 * self.fadeInAndOutBalance)
			self.thumbstickFrame.BackgroundTransparency = 1 - FADE_IN_OUT_MAX_ALPHA*math.min(delta/fadeInTime, 1)
			if delta > fadeInTime then
				self.tweenOutAlphaStart = tick()
				self.tweenInAlphaStart = nil
			end
		elseif self.tweenOutAlphaStart ~= nil then
			local delta = tick() - self.tweenOutAlphaStart
			local fadeOutTime = (self.fadeInAndOutHalfDuration * 2) - (self.fadeInAndOutHalfDuration * 2 * self.fadeInAndOutBalance)
			self.thumbstickFrame.BackgroundTransparency = 1 - FADE_IN_OUT_MAX_ALPHA + FADE_IN_OUT_MAX_ALPHA*math.min(delta/fadeOutTime, 1)
			if delta > fadeOutTime  then
				self.tweenOutAlphaStart = nil
			end
		end
	end)

	self.onTouchEndedConn = UserInputService.TouchEnded:connect(function(inputObject)
		if inputObject == self.moveTouchObject then
			self:OnInputEnded()
		end
	end)

	GuiService.MenuOpened:connect(function()
		if self.moveTouchObject then
			self:OnInputEnded()
		end
	end)

	local playerGui = Players.LocalPlayer:FindFirstChildOfClass("PlayerGui")
	while not playerGui do
		Players.LocalPlayer.ChildAdded:wait()
		playerGui = Players.LocalPlayer:FindFirstChildOfClass("PlayerGui")
	end

	local playerGuiChangedConn = nil
	local originalScreenOrientationWasLandscape =	playerGui.CurrentScreenOrientation == Enum.ScreenOrientation.LandscapeLeft or
													playerGui.CurrentScreenOrientation == Enum.ScreenOrientation.LandscapeRight

	local function longShowBackground()
		self.fadeInAndOutHalfDuration = 2.5
		self.fadeInAndOutBalance = 0.05
		self.tweenInAlphaStart = tick()
	end

	playerGuiChangedConn = playerGui.Changed:connect(function(prop)
		if prop == "CurrentScreenOrientation" then
			if (originalScreenOrientationWasLandscape and playerGui.CurrentScreenOrientation == Enum.ScreenOrientation.Portrait) or
				(not originalScreenOrientationWasLandscape and playerGui.CurrentScreenOrientation ~= Enum.ScreenOrientation.Portrait) then

				playerGuiChangedConn:disconnect()
				longShowBackground()

				if originalScreenOrientationWasLandscape then
					self.hasFadedBackgroundInPortrait = true
				else
					self.hasFadedBackgroundInLandscape = true
				end
			end
		end
	end)

	self.thumbstickFrame.Parent = parentFrame

	spawn(function()
		if game:IsLoaded() then
			longShowBackground()
		else
			game.Loaded:wait()
			longShowBackground()
		end
	end)
end

return DynamicThumbstick
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX15DFB8D5078A47B4B9BEA893D9D7E26F">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">ClickToMoveController</string>
							<string name="ScriptGuid">{6EB19A50-229E-4137-87F4-024C6D717884}</string>
							<ProtectedString name="Source"><![CDATA[--[[
	-- Original By Kip Turner, Copyright Roblox 2014
	-- Updated by Garnold to utilize the new PathfindingService API, 2017
	-- 2018 PlayerScripts Update - AllYourBlox
--]]

--[[ Roblox Services ]]--
local UserInputService = game:GetService("UserInputService")
local ContextActionService = game:GetService("ContextActionService")
local PathfindingService = game:GetService("PathfindingService")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local DebrisService = game:GetService('Debris')
local ReplicatedStorage = game:GetService('ReplicatedStorage')
local TweenService = game:GetService("TweenService")

--[[ Constants ]]--
local ZERO_VECTOR3 = Vector3.new(0,0,0)
	local movementKeys = {
		[Enum.KeyCode.W] = true;
		[Enum.KeyCode.A] = true;
		[Enum.KeyCode.S] = true;
		[Enum.KeyCode.D] = true;
		[Enum.KeyCode.Up] = true;
		[Enum.KeyCode.Down] = true;
	}

local Player = Players.LocalPlayer
local PlayerScripts = Player.PlayerScripts

local TouchJump = nil

local SHOW_PATH = true

local RayCastIgnoreList = workspace.FindPartOnRayWithIgnoreList

local CurrentSeatPart = nil
local DrivingTo = nil

local XZ_VECTOR3 = Vector3.new(1,0,1)
local ZERO_VECTOR3 = Vector3.new(0,0,0)
local ZERO_VECTOR2 = Vector2.new(0,0)

local BindableEvent_OnFailStateChanged = nil
if UserInputService.TouchEnabled then
--	BindableEvent_OnFailStateChanged = MasterControl:GetClickToMoveFailStateChanged()
end

--------------------------UTIL LIBRARY-------------------------------
local Utility = {}
do
	local function ViewSizeX()
		local camera = workspace.CurrentCamera
		local x = camera and camera.ViewportSize.X or 0
		local y = camera and camera.ViewportSize.Y or 0
		if x == 0 then
			return 1024
		else
			if x > y then
				return x
			else
				return y
			end
		end
	end
	Utility.ViewSizeX = ViewSizeX

	local function ViewSizeY()
		local camera = workspace.CurrentCamera
		local x = camera and camera.ViewportSize.X or 0
		local y = camera and camera.ViewportSize.Y or 0
		if y == 0 then
			return 768
		else
			if x > y then
				return y
			else
				return x
			end
		end
	end
	Utility.ViewSizeY = ViewSizeY

	local function FindCharacterAncestor(part)
		if part then
			local humanoid = part:FindFirstChild("Humanoid")
			if humanoid then
				return part, humanoid
			else
				return FindCharacterAncestor(part.Parent)
			end
		end
	end
	Utility.FindCharacterAncestor = FindCharacterAncestor

	local function Raycast(ray, ignoreNonCollidable, ignoreList)
		local ignoreList = ignoreList or {}
		local hitPart, hitPos, hitNorm, hitMat = RayCastIgnoreList(workspace, ray, ignoreList)
		if hitPart then
			if ignoreNonCollidable and hitPart.CanCollide == false then
				table.insert(ignoreList, hitPart)
				return Raycast(ray, ignoreNonCollidable, ignoreList)
			end
			return hitPart, hitPos, hitNorm, hitMat
		end
		return nil, nil
	end
	Utility.Raycast = Raycast
	
	local function AveragePoints(positions)
		local avgPos = ZERO_VECTOR2
		if #positions > 0 then
			for i = 1, #positions do
				avgPos = avgPos + positions[i]
			end
			avgPos = avgPos / #positions
		end
		return avgPos
	end
	Utility.AveragePoints = AveragePoints
end

local humanoidCache = {}
local function findPlayerHumanoid(player)
	local character = player and player.Character
	if character then
		local resultHumanoid = humanoidCache[player]
		if resultHumanoid and resultHumanoid.Parent == character then
			return resultHumanoid
		else
			humanoidCache[player] = nil -- Bust Old Cache
			local humanoid = character:FindFirstChildOfClass("Humanoid")
			if humanoid then
				humanoidCache[player] = humanoid
			end
			return humanoid
		end
	end
end

--------------------------CHARACTER CONTROL-------------------------------
local CurrentIgnoreList

local function GetCharacter()
	return Player and Player.Character
end

local function GetTorso()
	local humanoid = findPlayerHumanoid(Player)
	return humanoid and humanoid.RootPart
end

local function getIgnoreList()
	if CurrentIgnoreList then
		return CurrentIgnoreList
	end
	CurrentIgnoreList = {}
	table.insert(CurrentIgnoreList, GetCharacter())
	return CurrentIgnoreList
end

-----------------------------------PATHER--------------------------------------

local popupAdornee
local function getPopupAdorneePart()
	--Handle the case of the adornee part getting deleted (camera changed, maybe)
	if popupAdornee and not popupAdornee.Parent then
		popupAdornee = nil
	end
	
	--If the adornee doesn't exist yet, create it
	if not popupAdornee then
		popupAdornee = Instance.new("Part")		
		popupAdornee.Name = "ClickToMovePopupAdornee"
		popupAdornee.Transparency = 1
		popupAdornee.CanCollide = false
		popupAdornee.Anchored = true
		popupAdornee.Size = Vector3.new(2, 2, 2)
		popupAdornee.CFrame = CFrame.new()
		
		popupAdornee.Parent = workspace.CurrentCamera
	end
	
	return popupAdornee
end

local activePopups = {}
local function createNewPopup(popupType)
	local newModel = Instance.new("ImageHandleAdornment")
	
	newModel.AlwaysOnTop = false
	newModel.Transparency = 1
	newModel.Size = ZERO_VECTOR2
	newModel.SizeRelativeOffset = ZERO_VECTOR3
	newModel.Image = "rbxasset://textures/ui/move.png"
	newModel.ZIndex = 20
	
	local radius = 0
	if popupType == "DestinationPopup" then
		newModel.Color3 = Color3.fromRGB(0, 175, 255)
		radius = 1.25
	elseif popupType == "DirectWalkPopup" then
		newModel.Color3 = Color3.fromRGB(0, 175, 255)
		radius = 1.25
	elseif popupType == "FailurePopup" then
		newModel.Color3 = Color3.fromRGB(255, 100, 100)
		radius = 1.25
	elseif popupType == "PatherPopup" then
		newModel.Color3 = Color3.fromRGB(255, 255, 255)
		radius = 1
		newModel.ZIndex = 10
	end
	newModel.Size = Vector2.new(5, 0.1) * radius
	
	local dataStructure = {}
	dataStructure.Model = newModel	
	
	activePopups[#activePopups + 1] = newModel
	
	function dataStructure:TweenIn()
		local tweenInfo = TweenInfo.new(1.5, Enum.EasingStyle.Elastic, Enum.EasingDirection.Out)
		local tween1 = TweenService:Create(newModel, tweenInfo, { Size = Vector2.new(2,2) * radius })
		tween1:Play()
		TweenService:Create(newModel, TweenInfo.new(0.25, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut, 0, false, 0.1), { Transparency = 0, SizeRelativeOffset = Vector3.new(0, radius * 1.5, 0) }):Play()
		return tween1
	end
	
	function dataStructure:TweenOut()
		local tweenInfo = TweenInfo.new(0.25, Enum.EasingStyle.Quad, Enum.EasingDirection.In)
		local tween1 = TweenService:Create(newModel, tweenInfo, { Size = ZERO_VECTOR2 })
		tween1:Play()
		
		coroutine.wrap(function()
			tween1.Completed:Wait()
			
			for i = 1, #activePopups do
				if activePopups[i] == newModel then
					table.remove(activePopups, i)
					break
				end
			end
		end)()
		return tween1
	end
	
	function dataStructure:Place(position, dest)
		-- place the model at position
		if not self.Model.Parent then
			local popupAdorneePart = getPopupAdorneePart()
			self.Model.Parent = popupAdorneePart
			self.Model.Adornee = popupAdorneePart

			--Start the 10-stud long ray 2.5 studs above where the tap happened and point straight down to try to find
			--the actual ground position.
			local ray = Ray.new(position + Vector3.new(0, 2.5, 0), Vector3.new(0, -10, 0))
			local hitPart, hitPoint, hitNormal = workspace:FindPartOnRayWithIgnoreList(ray, { workspace.CurrentCamera, Player.Character })
			
			self.Model.CFrame = CFrame.new(hitPoint) + Vector3.new(0, -radius,0)
		end
	end
	
	return dataStructure
end

local function createPopupPath(points, numCircles)
	-- creates a path with the provided points, using the path and number of circles provided
	local popups = {}
	local stopTraversing = false
	
	local function killPopup(i)
		-- kill all popups before and at i
		for iter, v in pairs(popups) do
			if iter <= i then
				local tween = v:TweenOut()
				spawn(function()
					tween.Completed:Wait()
					v.Model:Destroy()
				end)
				popups[iter] = nil
			end
		end
	end	
	
	local function stopFunction()
		stopTraversing = true
		killPopup(#points)
	end
	
	spawn(function()
		for i = 1, #points do
			if stopTraversing then
				break
			end

			local includeWaypoint = i % numCircles == 0
			                    and i < #points
			                    and (points[#points].Position - points[i].Position).magnitude > 4
			if includeWaypoint then
				local popup = createNewPopup("PatherPopup")
				popups[i] = popup
				local nextPopup = points[i+1]
				popup:Place(points[i].Position, nextPopup and nextPopup.Position or points[#points].Position)
				local tween = popup:TweenIn()
				wait(0.2)
			end
		end
	end)
	
	return stopFunction, killPopup
end

local function Pather(character, endPoint, surfaceNormal)
	local this = {}

	this.Cancelled = false
	this.Started = false

	this.Finished = Instance.new("BindableEvent")
	this.PathFailed = Instance.new("BindableEvent")
	
	this.PathComputing = false
	this.PathComputed = false
	
	this.TargetPoint = endPoint
	this.TargetSurfaceNormal = surfaceNormal
	
	this.DiedConn = nil
	this.SeatedConn = nil
	this.MoveToConn = nil
	this.BlockedConn = nil
	this.CurrentPoint = 0

	function this:Cleanup()
		if this.stopTraverseFunc then
			this.stopTraverseFunc()
			this.stopTraverseFunc = nil
		end

		if this.MoveToConn then
			this.MoveToConn:Disconnect()
			this.MoveToConn = nil
		end

		if this.BlockedConn then
			this.BlockedConn:Disconnect()
			this.BlockedConn = nil
		end

		if this.DiedConn then
			this.DiedConn:Disconnect()
			this.DiedConn = nil
		end

		if this.SeatedConn then
			this.SeatedConn:Disconnect()
			this.SeatedConn = nil
		end

		this.humanoid = nil
	end

	function this:Cancel()
		this.Cancelled = true
		this:Cleanup()
	end

	function this:OnPathInterrupted()
		-- Stop moving
		this.Cancelled = true
		this:OnPointReached(false)
	end

	function this:ComputePath()
		local humanoid = findPlayerHumanoid(Player)
		local torso = humanoid and humanoid.Torso
		local success = false
		if torso then
			if this.PathComputed or this.PathComputing then return end
			this.PathComputing = true
			success = pcall(function()
				this.pathResult = PathfindingService:FindPathAsync(torso.CFrame.p, this.TargetPoint)
			end)
			this.pointList = this.pathResult and this.pathResult:GetWaypoints()
			if this.pathResult then
				this.BlockedConn = this.pathResult.Blocked:Connect(function(blockedIdx) this:OnPathBlocked(blockedIdx) end)
			end
			this.PathComputing = false
			this.PathComputed = this.pathResult and this.pathResult.Status == Enum.PathStatus.Success or false
		end
		return true
	end

	function this:IsValidPath()
		if not this.pathResult then
			this:ComputePath()
		end
		return this.pathResult.Status == Enum.PathStatus.Success
	end

	this.Recomputing = false
	function this:OnPathBlocked(blockedWaypointIdx)
		local pathBlocked = blockedWaypointIdx >= this.CurrentPoint
		if not pathBlocked or this.Recomputing then
			return
		end

		this.Recomputing = true

		if this.stopTraverseFunc then
			this.stopTraverseFunc()
			this.stopTraverseFunc = nil
		end

		this.pathResult:ComputeAsync(this.humanoid.Torso.CFrame.p, this.TargetPoint)
		this.pointList = this.pathResult:GetWaypoints()
		this.PathComputed = this.pathResult and this.pathResult.Status == Enum.PathStatus.Success or false

		if SHOW_PATH then
			this.stopTraverseFunc, this.setPointFunc = createPopupPath(this.pointList, 4, true)
		end
		if this.PathComputed then
			this.humanoid = findPlayerHumanoid(Player)
			this.CurrentPoint = 1 -- The first waypoint is always the start location. Skip it.
			this:OnPointReached(true) -- Move to first point
		else
			this.PathFailed:Fire()
			this:Cleanup()
		end

		this.Recomputing = false
	end

	function this:OnPointReached(reached)

		if reached and not this.Cancelled then

			local nextWaypointIdx = this.CurrentPoint + 1

			if nextWaypointIdx > #this.pointList then
				-- End of path reached
				if this.stopTraverseFunc then
					this.stopTraverseFunc()
				end
				this.Finished:Fire()
				this:Cleanup()
			else
				local currentWaypoint = this.pointList[this.CurrentPoint]
				local nextWaypoint = this.pointList[nextWaypointIdx]

				-- If airborne, only allow to keep moving
				-- if nextWaypoint.Action ~= Jump, or path mantains a direction
				-- Otherwise, wait until the humanoid gets to the ground
				local currentState = this.humanoid:GetState()
				local isInAir = currentState == Enum.HumanoidStateType.FallingDown
					or currentState == Enum.HumanoidStateType.Freefall
					or currentState == Enum.HumanoidStateType.Jumping
				
				if isInAir then
					local shouldWaitForGround = nextWaypoint.Action == Enum.PathWaypointAction.Jump
					if not shouldWaitForGround and this.CurrentPoint > 1 then
						local prevWaypoint = this.pointList[this.CurrentPoint - 1]

						local prevDir = currentWaypoint.Position - prevWaypoint.Position
						local currDir = nextWaypoint.Position - currentWaypoint.Position

						local prevDirXZ = Vector2.new(prevDir.x, prevDir.z).Unit
						local currDirXZ = Vector2.new(currDir.x, currDir.z).Unit

						local THRESHOLD_COS = 0.996 -- ~cos(5 degrees)
						shouldWaitForGround = prevDirXZ:Dot(currDirXZ) < THRESHOLD_COS
					end

					if shouldWaitForGround then
						this.humanoid.FreeFalling:Wait()

						-- Give time to the humanoid's state to change
						-- Otherwise, the jump flag in Humanoid
						-- will be reset by the state change
						wait(0.1)
					end
				end

				-- Move to the next point
				if this.setPointFunc then
					this.setPointFunc(nextWaypointIdx)
				end
				
				if nextWaypoint.Action == Enum.PathWaypointAction.Jump then
					this.humanoid.Jump = true
				end
				this.humanoid:MoveTo(nextWaypoint.Position)

				this.CurrentPoint = nextWaypointIdx
			end
		else
			this.PathFailed:Fire()
			this:Cleanup()
		end
	end

	function this:Start()
		if CurrentSeatPart then
			return
		end
		
		this.humanoid = findPlayerHumanoid(Player)
		if not this.humanoid then
			this.PathFailed:Fire()
			return
		end

		if this.Started then return end
		this.Started = true
		
		if SHOW_PATH then
			-- choose whichever one Mike likes best
			this.stopTraverseFunc, this.setPointFunc = createPopupPath(this.pointList, 4)
		end

		if #this.pointList > 0 then
			this.SeatedConn = this.humanoid.Seated:Connect(function(reached) this:OnPathInterrupted() end)
			this.DiedConn = this.humanoid.Died:Connect(function(reached) this:OnPathInterrupted() end)
			this.MoveToConn = this.humanoid.MoveToFinished:Connect(function(reached) this:OnPointReached(reached) end)

			this.CurrentPoint = 1 -- The first waypoint is always the start location. Skip it.
			this:OnPointReached(true) -- Move to first point
		else
			this.PathFailed:Fire()
			if this.stopTraverseFunc then
				this.stopTraverseFunc()
			end
		end
	end
	
	this:ComputePath()
	if not this.PathComputed then
		-- set the end point towards the camera and raycasted towards the ground in case we hit a wall
		local offsetPoint = this.TargetPoint + this.TargetSurfaceNormal*1.5
		local ray = Ray.new(offsetPoint, Vector3.new(0,-1,0)*50)
		local newHitPart, newHitPos = RayCastIgnoreList(workspace, ray, getIgnoreList())
		if newHitPart then
			this.TargetPoint = newHitPos
		end
		-- try again
		this:ComputePath()
	end
	
	return this
end

-------------------------------------------------------------------------

local function IsInBottomLeft(pt)
	local joystickHeight = math.min(Utility.ViewSizeY() * 0.33, 250)
	local joystickWidth = joystickHeight
	return pt.X <= joystickWidth and pt.Y > Utility.ViewSizeY() - joystickHeight
end

local function IsInBottomRight(pt)
	local joystickHeight = math.min(Utility.ViewSizeY() * 0.33, 250)
	local joystickWidth = joystickHeight
	return pt.X >= Utility.ViewSizeX() - joystickWidth and pt.Y > Utility.ViewSizeY() - joystickHeight
end

local function CheckAlive(character)
	local humanoid = findPlayerHumanoid(Player)
	return humanoid ~= nil and humanoid.Health > 0
end

local function GetEquippedTool(character)
	if character ~= nil then
		for _, child in pairs(character:GetChildren()) do
			if child:IsA('Tool') then
				return child
			end
		end
	end
end

local ExistingPather = nil
local ExistingIndicator = nil
local PathCompleteListener = nil
local PathFailedListener = nil

local function CleanupPath()
	DrivingTo = nil
	if ExistingPather then
		ExistingPather:Cancel()
	end
	if PathCompleteListener then
		PathCompleteListener:Disconnect()
		PathCompleteListener = nil
	end
	if PathFailedListener then
		PathFailedListener:Disconnect()
		PathFailedListener = nil
	end
	if ExistingIndicator then
		local obj = ExistingIndicator
		local tween = obj:TweenOut()
		local tweenCompleteEvent = nil
		tweenCompleteEvent = tween.Completed:connect(function()
			tweenCompleteEvent:Disconnect()
			obj.Model:Destroy()
		end)
		ExistingIndicator = nil
	end
end

local function getExtentsSize(Parts)
	local maxX,maxY,maxZ = -math.huge,-math.huge,-math.huge
	local minX,minY,minZ = math.huge,math.huge,math.huge
	for i = 1, #Parts do
		maxX,maxY,maxZ = math.max(maxX, Parts[i].Position.X), math.max(maxY, Parts[i].Position.Y), math.max(maxZ, Parts[i].Position.Z)
		minX,minY,minZ = math.min(minX, Parts[i].Position.X), math.min(minY, Parts[i].Position.Y), math.min(minZ, Parts[i].Position.Z)
	end
	return Region3.new(Vector3.new(minX, minY, minZ), Vector3.new(maxX, maxY, maxZ))
end

local function inExtents(Extents, Position)
	if Position.X < (Extents.CFrame.p.X - Extents.Size.X/2) or Position.X > (Extents.CFrame.p.X + Extents.Size.X/2) then
		return false
	end
	if Position.Z < (Extents.CFrame.p.Z - Extents.Size.Z/2) or Position.Z > (Extents.CFrame.p.Z + Extents.Size.Z/2) then
		return false
	end
	--ignoring Y for now
	return true
end

local function showQuickPopupAsync(position, popupType)
	local popup = createNewPopup(popupType)
	popup:Place(position, Vector3.new(0,position.y,0))
	local tweenIn = popup:TweenIn()
	tweenIn.Completed:Wait()
	local tweenOut = popup:TweenOut()
	tweenOut.Completed:Wait()
	popup.Model:Destroy()
	popup = nil
end

local FailCount = 0
local function OnTap(tapPositions, goToPoint)
	-- Good to remember if this is the latest tap event
	local camera = workspace.CurrentCamera
	local character = Player.Character
	
	if not CheckAlive(character) then return end
	
	-- This is a path tap position
	if #tapPositions == 1 or goToPoint then
		if camera then
			local unitRay = camera:ScreenPointToRay(tapPositions[1].x, tapPositions[1].y)
			local ray = Ray.new(unitRay.Origin, unitRay.Direction*1000)
			
			-- inivisicam stuff
			local initIgnore = getIgnoreList()
			local invisicamParts = {} --InvisicamModule and InvisicamModule:GetObscuredParts() or {}
			local ignoreTab = {}
			
			-- add to the ignore list
			for i, v in pairs(invisicamParts) do
				ignoreTab[#ignoreTab+1] = i
			end
			for i = 1, #initIgnore do
				ignoreTab[#ignoreTab+1] = initIgnore[i]
			end
			--			
			local myHumanoid = findPlayerHumanoid(Player)
			local hitPart, hitPt, hitNormal, hitMat = Utility.Raycast(ray, true, ignoreTab)

			local hitChar, hitHumanoid = Utility.FindCharacterAncestor(hitPart)
			local torso = GetTorso()
			local startPos = torso.CFrame.p
			if goToPoint then
				hitPt = goToPoint
				hitChar = nil
			end
			if hitChar and hitHumanoid and hitHumanoid.RootPart and (hitHumanoid.Torso.CFrame.p - torso.CFrame.p).magnitude < 7 then
				CleanupPath()
				
				if myHumanoid then
					myHumanoid:MoveTo(hitPt)
				end
				-- Do shoot
				local currentWeapon = GetEquippedTool(character)
				if currentWeapon then
					currentWeapon:Activate()
					LastFired = tick()
				end
			elseif hitPt and character and not CurrentSeatPart then
				local thisPather = Pather(character, hitPt, hitNormal)
				if thisPather:IsValidPath() then
					FailCount = 0
					
					thisPather:Start()
					if BindableEvent_OnFailStateChanged then
						BindableEvent_OnFailStateChanged:Fire(false)
					end
					CleanupPath()
					
					local destinationPopup = createNewPopup("DestinationPopup")	
					destinationPopup:Place(hitPt, Vector3.new(0,hitPt.y,0))
					local failurePopup = createNewPopup("FailurePopup")
					local currentTween = destinationPopup:TweenIn()
					
					
					ExistingPather = thisPather
					ExistingIndicator = destinationPopup

					PathCompleteListener = thisPather.Finished.Event:Connect(function()
						if destinationPopup then
							if ExistingIndicator == destinationPopup then
								ExistingIndicator = nil
							end
							local tween = destinationPopup:TweenOut()
							local tweenCompleteEvent = nil
							tweenCompleteEvent = tween.Completed:Connect(function()
								tweenCompleteEvent:Disconnect()
								destinationPopup.Model:Destroy()
								destinationPopup = nil
							end)
						end
						if hitChar then
							local humanoid = findPlayerHumanoid(Player)
							local currentWeapon = GetEquippedTool(character)
							if currentWeapon then
								currentWeapon:Activate()
								LastFired = tick()
							end
							if humanoid then
								humanoid:MoveTo(hitPt)
							end
						end
					end)
					PathFailedListener = thisPather.PathFailed.Event:Connect(function()
						CleanupPath()
						if failurePopup then
							failurePopup:Place(hitPt, Vector3.new(0,hitPt.y,0))
							local failTweenIn = failurePopup:TweenIn()
							failTweenIn.Completed:Wait()
							local failTweenOut = failurePopup:TweenOut()
							failTweenOut.Completed:Wait()
							failurePopup.Model:Destroy()
							failurePopup = nil
						end
					end)
				else
					if hitPt then
						-- Feedback here for when we don't have a good path
						local foundDirectPath = false
						if (hitPt-startPos).Magnitude < 25 and (startPos.y-hitPt.y > -3) then
							-- move directly here
							if myHumanoid then
								if myHumanoid.Sit then
									myHumanoid.Jump = true
								end
								myHumanoid:MoveTo(hitPt)
								foundDirectPath = true
							end
						end		
						
						coroutine.wrap(showQuickPopupAsync)(hitPt, foundDirectPath and "DirectWalkPopup" or "FailurePopup")
					end
				end
			elseif hitPt and character and CurrentSeatPart then 
				local destinationPopup = createNewPopup("DestinationPopup")	
				ExistingIndicator = destinationPopup
				destinationPopup:Place(hitPt, Vector3.new(0,hitPt.y,0))
				destinationPopup:TweenIn()
				
				DrivingTo = hitPt
				local ConnectedParts = CurrentSeatPart:GetConnectedParts(true)
				
				while wait() do
					if CurrentSeatPart and ExistingIndicator == destinationPopup then
						local ExtentsSize = getExtentsSize(ConnectedParts)
						if inExtents(ExtentsSize, hitPt) then
							local popup = destinationPopup
							spawn(function()
								local tweenOut = popup:TweenOut()
								tweenOut.Completed:Wait()
								popup.Model:Destroy()
							end)
							destinationPopup = nil
							DrivingTo = nil
							break
						end
					else
						if CurrentSeatPart == nil and destinationPopup == ExistingIndicator then
							DrivingTo = nil
							OnTap(tapPositions, hitPt)
						end
						local popup = destinationPopup
						spawn(function()
							local tweenOut = popup:TweenOut()
							tweenOut.Completed:Wait()
							popup.Model:Destroy()
						end)
						destinationPopup = nil
						break
					end
				end
			end
		end
	elseif #tapPositions >= 2 then
		if camera then
			-- Do shoot
			local avgPoint = Utility.AveragePoints(tapPositions)
			local unitRay = camera:ScreenPointToRay(avgPoint.x, avgPoint.y)
			local currentWeapon = GetEquippedTool(character)
			if currentWeapon then
				currentWeapon:Activate()
				LastFired = tick()
			end
		end
	end
end

local function IsFinite(num)
	return num == num and num ~= 1/0 and num ~= -1/0
end

local function findAngleBetweenXZVectors(vec2, vec1)
	return math.atan2(vec1.X*vec2.Z-vec1.Z*vec2.X, vec1.X*vec2.X + vec1.Z*vec2.Z)
end

local function DisconnectEvent(event)
	if event then
		event:Disconnect()
	end
end

--[[ The ClickToMove Controller Class ]]--
local KeyboardController = require(script.Parent:WaitForChild("Keyboard"))
local ClickToMove = setmetatable({}, KeyboardController)
ClickToMove.__index = ClickToMove

function ClickToMove.new(CONTROL_ACTION_PRIORITY)
	local self = setmetatable(KeyboardController.new(CONTROL_ACTION_PRIORITY), ClickToMove)
	
	self.fingerTouches = {}
	self.numUnsunkTouches = 0
	-- PC simulation
	self.mouse1Down = tick()
	self.mouse1DownPos = Vector2.new()
	self.mouse2DownTime = tick()
	self.mouse2DownPos = Vector2.new()
	self.mouse2UpTime = tick()



	self.tapConn = nil
	self.inputBeganConn = nil
	self.inputChangedConn = nil
	self.inputEndedConn = nil
	self.humanoidDiedConn = nil
	self.characterChildAddedConn = nil
	self.onCharacterAddedConn = nil
	self.characterChildRemovedConn = nil
	self.renderSteppedConn = nil
	self.humanoidSeatedConn = nil
	
	self.running = false
	
	self.wasdEnabled = false
	
	return self
end

function ClickToMove:DisconnectEvents()
	DisconnectEvent(self.tapConn)
	DisconnectEvent(self.inputBeganConn)
	DisconnectEvent(self.inputChangedConn)
	DisconnectEvent(self.inputEndedConn)
	DisconnectEvent(self.humanoidDiedConn)
	DisconnectEvent(self.characterChildAddedConn)
	DisconnectEvent(self.onCharacterAddedConn)
	DisconnectEvent(self.renderSteppedConn)
	DisconnectEvent(self.characterChildRemovedConn)
	
	-- TODO: Resolve with ControlScript handling of seating for vehicles
	DisconnectEvent(self.humanoidSeatedConn)
	
	RunService:UnbindFromRenderStep("ClickToMoveRenderUpdate")
end

function ClickToMove:OnTouchBegan(input, processed)
	if self.fingerTouches[input] == nil and not processed then
		self.numUnsunkTouches = self.numUnsunkTouches + 1
	end
	self.fingerTouches[input] = processed
end

function ClickToMove:OnTouchChanged(input, processed)
	if self.fingerTouches[input] == nil then
		self.fingerTouches[input] = processed
		if not processed then
			self.numUnsunkTouches = self.numUnsunkTouches + 1
		end
	end
end

function ClickToMove:OnTouchEnded(input, processed)
	if self.fingerTouches[input] ~= nil and self.fingerTouches[input] == false then
		self.numUnsunkTouches = self.numUnsunkTouches - 1
	end
	self.fingerTouches[input] = nil
end


function ClickToMove:OnCharacterAdded(character)
	self:DisconnectEvents()

	self.inputBeganConn = UserInputService.InputBegan:Connect(function(input, processed)
		if input.UserInputType == Enum.UserInputType.Touch then
			self:OnTouchBegan(input, processed)

			-- Give back controls when they tap both sticks
			local wasInBottomLeft = IsInBottomLeft(input.Position)
			local wasInBottomRight = IsInBottomRight(input.Position)
			if wasInBottomRight or wasInBottomLeft then
				for otherInput, _ in pairs(self.fingerTouches) do
					if otherInput ~= input then
						local otherInputInLeft = IsInBottomLeft(otherInput.Position)
						local otherInputInRight = IsInBottomRight(otherInput.Position)
						if otherInput.UserInputState ~= Enum.UserInputState.End and ((wasInBottomLeft and otherInputInRight) or (wasInBottomRight and otherInputInLeft)) then
							if BindableEvent_OnFailStateChanged then
								BindableEvent_OnFailStateChanged:Fire(true)
							end
							return
						end
					end
				end
			end
		end

		 -- Cancel path when you use the keyboard controls.
		if processed == false and input.UserInputType == Enum.UserInputType.Keyboard and movementKeys[input.KeyCode] then
			CleanupPath()
		end
		if input.UserInputType == Enum.UserInputType.MouseButton1 then
			self.mouse1DownTime = tick()
			self.mouse1DownPos = input.Position
		end
		if input.UserInputType == Enum.UserInputType.MouseButton2 then
			self.mouse2DownTime = tick()
			self.mouse2DownPos = input.Position
		end
	end)

	self.inputChangedConn = UserInputService.InputChanged:Connect(function(input, processed)
		if input.UserInputType == Enum.UserInputType.Touch then
			self:OnTouchChanged(input, processed)
		end
	end)

	self.inputEndedConn = UserInputService.InputEnded:Connect(function(input, processed)
		if input.UserInputType == Enum.UserInputType.Touch then
			self:OnTouchEnded(input, processed)
		end

		if input.UserInputType == Enum.UserInputType.MouseButton2 then
			self.mouse2UpTime = tick()
			local currPos = input.Position
			if self.mouse2UpTime - self.mouse2DownTime < 0.25 and (currPos - self.mouse2DownPos).magnitude < 5 and self.moveVector.Magnitude<=0 then
				local positions = {currPos}
				OnTap(positions)
			end
		end
	end)

	self.tapConn = UserInputService.TouchTap:Connect(function(touchPositions, processed)
		if not processed then
			OnTap(touchPositions)
		end
	end)
	
	local function computeThrottle(dist)
		if dist > .2 then
			return 0.5+(dist^2)/2
		else
			return 0
		end
	end		

	local lastSteer = 0

	--kP = how much the steering corrects for the current error in driving angle
	--kD = how much the steering corrects for how quickly the error in driving angle is changing
	local kP = 1
	local kD = 0.5
	local function getThrottleAndSteer(object, point)
		local throttle, steer = 0, 0
		local oCF = object.CFrame
		
		local relativePosition = oCF:pointToObjectSpace(point)
		local relativeZDirection = -relativePosition.z
		local relativeDistance = relativePosition.magnitude
		
		-- throttle quadratically increases from 0-1 as distance from the selected point goes from 0-50, after 50, throttle is 1.
		-- this allows shorter distance travel to have more fine-tuned control.
		throttle = computeThrottle(math.min(1,relativeDistance/50))*math.sign(relativeZDirection)
		
		local steerAngle = -math.atan2(-relativePosition.x, -relativePosition.z)
		steer = steerAngle/(math.pi/4)

		local steerDelta = steer - lastSteer
		lastSteer = steer
		local pdSteer = kP * steer + kD * steer
		return throttle, pdSteer
	end
	
	local function Update()
		if CurrentSeatPart then
			if DrivingTo then
				local throttle, steer = getThrottleAndSteer(CurrentSeatPart, DrivingTo)
				CurrentSeatPart.ThrottleFloat = throttle
				CurrentSeatPart.SteerFloat = steer
			else
				CurrentSeatPart.ThrottleFloat = 0
				CurrentSeatPart.SteerFloat = 0
			end
		end
		
		local cameraPos = workspace.CurrentCamera.CFrame.p
		for i = 1, #activePopups do
			local popup = activePopups[i]
			popup.CFrame = CFrame.new(popup.CFrame.p, cameraPos)
		end
	end
	
	RunService:BindToRenderStep("ClickToMoveRenderUpdate",Enum.RenderPriority.Camera.Value - 1,Update)

	local function OnCharacterChildAdded(child)
		if UserInputService.TouchEnabled then
			if child:IsA('Tool') then
				child.ManualActivationOnly = true
			end
		end
		if child:IsA('Humanoid') then
			DisconnectEvent(self.humanoidDiedConn)
			self.humanoidDiedConn = child.Died:Connect(function()
				if ExistingIndicator then
					DebrisService:AddItem(ExistingIndicator.Model, 1)
				end
			end)
		end
	end

	self.characterChildAddedConn = character.ChildAdded:Connect(function(child)
		OnCharacterChildAdded(child)
	end)
	self.characterChildRemovedConn = character.ChildRemoved:Connect(function(child)
		if UserInputService.TouchEnabled then
			if child:IsA('Tool') then
				child.ManualActivationOnly = false
			end
		end
	end)
	for _, child in pairs(character:GetChildren()) do
		OnCharacterChildAdded(child)
	end
end

function ClickToMove:Start()
	self:Enable(true)
end

function ClickToMove:Stop()
	self:Enable(false)
end

function ClickToMove:Enable(enable, enableWASD)
	if enable then
		if not self.running then
			if Player.Character then -- retro-listen
				self:OnCharacterAdded(Player.Character)
			end
			self.onCharacterAddedConn = Player.CharacterAdded:Connect(function(char)
				self:OnCharacterAdded(char)
			end)
			self.running = true
		end
	else
		if self.running then
			self:DisconnectEvents()
			CleanupPath()
			-- Restore tool activation on shutdown
			if UserInputService.TouchEnabled then
				local character = Player.Character
				if character then
					for _, child in pairs(character:GetChildren()) do
						if child:IsA('Tool') then
							child.ManualActivationOnly = false
						end
					end
				end
			end
			DrivingTo = nil
			self.running = false
		end
	end
	
	-- Extension for initializing Keyboard input as this class now derives from Keyboard
	if UserInputService.KeyboardEnabled and enable ~= self.enabled then
	
		self.forwardValue  = 0
		self.backwardValue = 0
		self.leftValue = 0
		self.rightValue = 0
		
		self.moveVector = ZERO_VECTOR3
		
		if enable then
			self:BindContextActions()
			self:ConnectFocusEventListeners()
		else
			self:UnbindContextActions()
			self:DisconnectFocusEventListeners()
		end	
	end
	
	self.wasdEnabled = enable and enableWASD or false
	self.enabled = enable
end

-- Overrides Keyboard:UpdateMovement(inputState) to conditionally consider self.wasdEnabled
function ClickToMove:UpdateMovement(inputState)
	if inputState == Enum.UserInputState.Cancel then
		self.moveVector = ZERO_VECTOR3
	elseif self.wasdEnabled then
		self.moveVector = Vector3.new(self.leftValue + self.rightValue, 0, self.forwardValue + self.backwardValue)
	end
end

return ClickToMove
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX1AE3C04A5109463BB28AB63F6216B948">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">BaseCharacterController</string>
							<string name="ScriptGuid">{370C2D9E-E7E7-490E-91F3-F31FCAE11360}</string>
							<ProtectedString name="Source"><![CDATA[--[[
	BaseCharacterController - Abstract base class for character controllers, not intended to be
	directly instantiated.
	
	2018 PlayerScripts Update - AllYourBlox		
--]]

local ZERO_VECTOR3 = Vector3.new(0,0,0)

--[[ Roblox Services ]]--
local Players = game:GetService("Players")

--[[ The Module ]]--
local BaseCharacterController = {}
BaseCharacterController.__index = BaseCharacterController

function BaseCharacterController.new()
	local self = setmetatable({}, BaseCharacterController)
	self.enabled = false
	self.moveVector = ZERO_VECTOR3
	self.isJumping = false
	return self
end

function BaseCharacterController:GetMoveVector()
	return self.moveVector
end

function BaseCharacterController:GetIsJumping()
	return self.isJumping
end

-- Override in derived classes to set self.enabled and return boolean indicating
-- whether Enable/Disable was successful. Return true if controller is already in the requested state.
function BaseCharacterController:Enable(enable)
	error("BaseCharacterController:Enable must be overridden in derived classes and should not be called.")
	return false
end

return BaseCharacterController]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX424BB16334824DF49E92F9F5DD82D08E">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">TouchThumbpad</string>
							<string name="ScriptGuid">{10A4037D-9B44-4D8F-B586-3025D3809510}</string>
							<ProtectedString name="Source"><![CDATA[--[[
	
	TouchThumbpad
	
--]]

local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local GuiService = game:GetService("GuiService")

--[[ Constants ]]--
local DPAD_SHEET = "rbxasset://textures/ui/DPadSheet.png"
local TOUCH_CONTROL_SHEET = "rbxasset://textures/ui/TouchControlsSheet.png"
local ZERO_VECTOR3 = Vector3.new(0,0,0)
local UNIT_Z = Vector3.new(0,0,1)
local UNIT_X = Vector3.new(1,0,0)

--[[ The Module ]]--
local BaseCharacterController = require(script.Parent:WaitForChild("BaseCharacterController"))
local TouchThumbpad = setmetatable({}, BaseCharacterController)
TouchThumbpad.__index = TouchThumbpad

function TouchThumbpad.new()
	local self = setmetatable(BaseCharacterController.new(), TouchThumbpad)
	
	self.thumbpadFrame = nil
	self.touchChangedConn = nil
	self.touchEndedConn = nil
	self.menuOpenedConn = nil
	self.screenPos = nil
	self.isRight, self.isLeft, self.isUp, self.isDown = false, false, false, false
	self.smArrowSize = nil
	self.lgArrowSize = nil
	self.smImgOffset = nil
	self.lgImgOffset = nil
	return self
end

--[[ Local Helper Functions ]]--
local function doTween(guiObject, endSize, endPosition)
	guiObject:TweenSizeAndPosition(endSize, endPosition, Enum.EasingDirection.InOut, Enum.EasingStyle.Linear, 0.15, true)
end

local function CreateArrowLabel(name, position, size, rectOffset, rectSize, parent)
	local image = Instance.new("ImageLabel")
	image.Name = name
	image.Image = DPAD_SHEET
	image.ImageRectOffset = rectOffset
	image.ImageRectSize = rectSize
	image.BackgroundTransparency = 1
	image.ImageColor3 = Color3.fromRGB(190, 190, 190)
	image.Size = size
	image.Position = position
	image.Parent = parent
	return image
end

function TouchThumbpad:Enable(enable, uiParentFrame)
	if enable == nil then return false end			-- If nil, return false (invalid argument)
	enable = enable and true or false				-- Force anything non-nil to boolean before comparison
	if self.enabled == enable then return true end	-- If no state change, return true indicating already in requested state
	
	self.moveVector = ZERO_VECTOR3
	self.isJumping = false
	
	if enable then
		-- Enable
		if not self.thumbpadFrame then
			self:Create(uiParentFrame)
		end
		self.thumbpadFrame.Visible = true
	else 
		-- Disable
		self.thumbpadFrame.Visible = false
		self:OnInputEnded()
	end
	self.enabled = enable
end
	
function TouchThumbpad:OnInputEnded()
	self.moveVector = ZERO_VECTOR3
	self.isJumping = false

	self.thumbpadFrame.Position = self.screenPos
	self.touchObject = nil
	self.isUp, self.isDown, self.isLeft, self.isRight = false, false, false, false
	doTween(self.dArrow, self.smArrowSize, UDim2.new(0.5, -0.5*self.smArrowSize.X.Offset, 1, self.lgImgOffset))
	doTween(self.uArrow, self.smArrowSize, UDim2.new(0.5, -0.5*self.smArrowSize.X.Offset, 0, self.smImgOffset))
	doTween(self.lArrow, self.smArrowSize, UDim2.new(0, self.smImgOffset, 0.5, -0.5*self.smArrowSize.Y.Offset))
	doTween(self.rArrow, self.smArrowSize, UDim2.new(1, self.lgImgOffset, 0.5, -0.5*self.smArrowSize.Y.Offset))
end

function TouchThumbpad:Create(parentFrame)
	if self.thumbpadFrame then
		self.thumbpadFrame:Destroy()
		self.thumbpadFrame = nil
	end
	if self.touchChangedConn then
		self.touchChangedConn:Disconnect()
		self.touchChangedConn = nil
	end
	if self.touchEndedConn then
		self.touchEndedConn:Disconnect()
		self.touchEndedConn = nil
	end
	if self.menuOpenedConn then
		self.menuOpenedConn:Disconnect()
		self.menuOpenedConn = nil
	end
	
	local minAxis = math.min(parentFrame.AbsoluteSize.x, parentFrame.AbsoluteSize.y)
	local isSmallScreen = minAxis <= 500
	local thumbpadSize = isSmallScreen and 70 or 120
	self.screenPos = isSmallScreen and UDim2.new(0, thumbpadSize * 1.25, 1, -thumbpadSize - 20) or
		UDim2.new(0, thumbpadSize * 0.5 - 10, 1, -thumbpadSize * 1.75 - 10)
	
	self.thumbpadFrame = Instance.new("Frame")
	self.thumbpadFrame.Name = "ThumbpadFrame"
	self.thumbpadFrame.Visible = false
	self.thumbpadFrame.Active = true
	self.thumbpadFrame.Size = UDim2.new(0, thumbpadSize + 20, 0, thumbpadSize + 20)
	self.thumbpadFrame.Position = self.screenPos
	self.thumbpadFrame.BackgroundTransparency = 1
	
	local outerImage = Instance.new("ImageLabel")
	outerImage.Name = "OuterImage"
	outerImage.Image = TOUCH_CONTROL_SHEET
	outerImage.ImageRectOffset = Vector2.new(0, 0)
	outerImage.ImageRectSize = Vector2.new(220, 220)
	outerImage.BackgroundTransparency = 1
	outerImage.Size = UDim2.new(0, thumbpadSize, 0, thumbpadSize)
	outerImage.Position = UDim2.new(0, 10, 0, 10)
	outerImage.Parent = self.thumbpadFrame
	
	self.smArrowSize = isSmallScreen and UDim2.new(0, 32, 0, 32) or UDim2.new(0, 64, 0, 64)
	self.lgArrowSize = UDim2.new(0, self.smArrowSize.X.Offset * 2, 0, self.smArrowSize.Y.Offset * 2)
	local imgRectSize = Vector2.new(110, 110)
	self.smImgOffset = isSmallScreen and -4 or -9
	self.lgImgOffset = isSmallScreen and -28 or -55
	
	self.dArrow = CreateArrowLabel("DownArrow", UDim2.new(0.5, -0.5*self.smArrowSize.X.Offset, 1, self.lgImgOffset), self.smArrowSize, Vector2.new(8, 8), imgRectSize, outerImage)
	self.uArrow = CreateArrowLabel("UpArrow", UDim2.new(0.5, -0.5*self.smArrowSize.X.Offset, 0, self.smImgOffset), self.smArrowSize, Vector2.new(8, 266), imgRectSize, outerImage)
	self.lArrow = CreateArrowLabel("LeftArrow", UDim2.new(0, self.smImgOffset, 0.5, -0.5*self.smArrowSize.Y.Offset), self.smArrowSize, Vector2.new(137, 137), imgRectSize, outerImage)
	self.rArrow = CreateArrowLabel("RightArrow", UDim2.new(1, self.lgImgOffset, 0.5, -0.5*self.smArrowSize.Y.Offset), self.smArrowSize, Vector2.new(8, 137), imgRectSize, outerImage)
	
	local function doTween(guiObject, endSize, endPosition)
		guiObject:TweenSizeAndPosition(endSize, endPosition, Enum.EasingDirection.InOut, Enum.EasingStyle.Linear, 0.15, true)
	end
	
	local padOrigin = nil
	local deadZone = 0.1
	self.isRight, self.isLeft, self.isUp, self.isDown = false, false, false, false
	
	local function doMove(pos)
		
		local moveDelta = pos - padOrigin
		local moveVector2 = 2 * moveDelta / thumbpadSize
		
		-- Scaled Radial Dead Zone
		if moveVector2.Magnitude < deadZone then
			self.moveVector = ZERO_VECTOR3
		else
			moveVector2 = moveVector2.unit * ((moveVector2.Magnitude - deadZone) / (1 - deadZone))
			
			-- prevent NAN Vector from trying to do zerovector.Unit
			if moveVector2.Magnitude == 0 then
				self.moveVector = ZERO_VECTOR3
			else
				self.moveVector = Vector3.new(moveVector2.x, 0, moveVector2.y).Unit
			end
		end
		
		local forwardDot = self.moveVector:Dot(-UNIT_Z)
		local rightDot = self.moveVector:Dot(UNIT_X)
		
		if forwardDot > 0.5 then		-- UP
			if not self.isUp then
				self.isUp, self.isDown = true, false
				doTween(self.uArrow, self.lgArrowSize, UDim2.new(0.5, -self.smArrowSize.X.Offset, 0, self.smImgOffset - 1.5*self.smArrowSize.Y.Offset))
				doTween(self.dArrow, self.smArrowSize, UDim2.new(0.5, -0.5*self.smArrowSize.X.Offset, 1, self.lgImgOffset))
			end
		elseif forwardDot < -0.5 then	-- DOWN
			if not self.isDown then
				self.isDown, self.isUp = true, false
				doTween(self.dArrow, self.lgArrowSize, UDim2.new(0.5, -self.smArrowSize.X.Offset, 1, self.lgImgOffset + 0.5*self.smArrowSize.Y.Offset))
				doTween(self.uArrow, self.smArrowSize, UDim2.new(0.5, -0.5*self.smArrowSize.X.Offset, 0, self.smImgOffset))
			end
		else
			self.isUp, self.isDown = false, false
			doTween(self.dArrow, self.smArrowSize, UDim2.new(0.5, -0.5*self.smArrowSize.X.Offset, 1, self.lgImgOffset))
			doTween(self.uArrow, self.smArrowSize, UDim2.new(0.5, -0.5*self.smArrowSize.X.Offset, 0, self.smImgOffset))
		end
		
		if rightDot > 0.5 then
			if not self.isRight then
				self.isRight, self.isLeft = true, false
				doTween(self.rArrow, self.lgArrowSize, UDim2.new(1, self.lgImgOffset + 0.5*self.smArrowSize.X.Offset, 0.5, -self.smArrowSize.Y.Offset))
				doTween(self.lArrow, self.smArrowSize, UDim2.new(0, self.smImgOffset, 0.5, -0.5*self.smArrowSize.Y.Offset))
			end
		elseif rightDot < -0.5 then
			if not self.isLeft then
				self.isLeft, self.isRight = true, false
				doTween(self.lArrow, self.lgArrowSize, UDim2.new(0, self.smImgOffset - 1.5*self.smArrowSize.X.Offset, 0.5, -self.smArrowSize.Y.Offset))
				doTween(self.rArrow, self.smArrowSize, UDim2.new(1, self.lgImgOffset, 0.5, -0.5*self.smArrowSize.Y.Offset))
			end
		else
			self.isRight, self.isLeft = false, false
			doTween(self.lArrow, self.smArrowSize, UDim2.new(0, self.smImgOffset, 0.5, -0.5*self.smArrowSize.Y.Offset))
			doTween(self.rArrow, self.smArrowSize, UDim2.new(1, self.lgImgOffset, 0.5, -0.5*self.smArrowSize.Y.Offset))
		end
	end
	
	--input connections
	self.thumbpadFrame.InputBegan:connect(function(inputObject)
		--A touch that starts elsewhere on the screen will be sent to a frame's InputBegan event
		--if it moves over the frame. So we check that this is actually a new touch (inputObject.UserInputState ~= Enum.UserInputState.Begin)
		if self.touchObject or inputObject.UserInputType ~= Enum.UserInputType.Touch
			or inputObject.UserInputState ~= Enum.UserInputState.Begin then
			return
		end
		
		self.thumbpadFrame.Position = UDim2.new(0, inputObject.Position.x - 0.5*self.thumbpadFrame.AbsoluteSize.x, 0, inputObject.Position.y - 0.5*self.thumbpadFrame.Size.Y.Offset)
		padOrigin = Vector3.new(self.thumbpadFrame.AbsolutePosition.x +0.5* self.thumbpadFrame.AbsoluteSize.x,
			self.thumbpadFrame.AbsolutePosition.y + 0.5*self.thumbpadFrame.AbsoluteSize.y, 0)
		doMove(inputObject.Position)
		self.touchObject = inputObject
	end)
	
	self.touchChangedConn = UserInputService.TouchMoved:connect(function(inputObject, isProcessed)
		if inputObject == self.touchObject then
			doMove(self.touchObject.Position)
		end
	end)
	
	self.touchEndedConn = UserInputService.TouchEnded:Connect(function(inputObject)
		if inputObject == self.touchObject then
			self:OnInputEnded()
		end
	end)
	
	self.menuOpenedConn = GuiService.MenuOpened:Connect(function()
		if self.touchObject then
			self:OnInputEnded()
		end
	end)	
	
	self.thumbpadFrame.Parent = parentFrame
end

return TouchThumbpad
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX5FF917E5737D45AC9BBC0ACFC1DBECCA">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">TouchDPad</string>
							<string name="ScriptGuid">{2282B974-5525-4902-A53D-176FB41BE418}</string>
							<ProtectedString name="Source"><![CDATA[--[[
	
	
	
--]]

local Players = game:GetService("Players")
local GuiService = game:GetService("GuiService")

--[[ Constants ]]--
local DPAD_SHEET = "rbxasset://textures/ui/DPadSheet.png"
local ZERO_VECTOR3 = Vector3.new(0,0,0)
local COMPASS_DIR = {
	Vector3.new(1, 0, 0),			-- E
	Vector3.new(1, 0, 1).unit,		-- SE
	Vector3.new(0, 0, 1),			-- S
	Vector3.new(-1, 0, 1).unit,		-- SW
	Vector3.new(-1, 0, 0),			-- W
	Vector3.new(-1, 0, -1).unit,	-- NW
	Vector3.new(0, 0, -1),			-- N
	Vector3.new(1, 0, -1).unit,		-- NE
}


--[[ The Module ]]--
local BaseCharacterController = require(script.Parent:WaitForChild("BaseCharacterController"))
local TouchDPad = setmetatable({}, BaseCharacterController)
TouchDPad.__index = TouchDPad

function TouchDPad.new()
	local self = setmetatable(BaseCharacterController.new(), TouchDPad)
	
	self.DPadFrame = nil
	self.touchObject = nil
	self.flBtn = nil
	self.frBtn = nil
	
	return self
end

--[[ Local Functions ]]--
local function CreateArrowLabel(name, position, size, rectOffset, rectSize, parent)
	local image = Instance.new("ImageLabel")
	image.Name = name
	image.Image = DPAD_SHEET
	image.ImageRectOffset = rectOffset
	image.ImageRectSize = rectSize
	image.BackgroundTransparency = 1
	image.Size = size
	image.Position = position
	image.Parent = parent
	return image
end

function TouchDPad:GetCenterPosition()
	return Vector2.new(self.DPadFrame.AbsolutePosition.x + self.DPadFrame.AbsoluteSize.x * 0.5, self.DPadFrame.AbsolutePosition.y + self.DPadFrame.AbsoluteSize.y * 0.5)
end

function TouchDPad:Enable(enable, uiParentFrame)
	if enable == nil then return false end			-- If nil, return false (invalid argument)
	enable = enable and true or false				-- Force anything non-nil to boolean before comparison
	if self.enabled == enable then return true end	-- If no state change, return true indicating already in requested state
	
	self.moveVector = ZERO_VECTOR3
	self.isJumping = false
	
	if enable then
		-- Enable
		if not self.DPadFrame then
			self:Create(uiParentFrame)
		end
		self.DPadFrame.Visible = true
	else 
		-- Disable
		self.DPadFrame.Visible = false
		self:OnInputEnded()
	end
	self.enabled = enable
end

-- Note: Overrides base class GetIsJumping with get-and-clear behavior to do a single jump
-- rather than sustained jumping. This is only to preserve the current behavior through the refactor.
function TouchDPad:GetIsJumping()
	local wasJumping = self.isJumping
	self.isJumping = false
	return wasJumping
end

function TouchDPad:OnInputEnded()
	self.touchObject =nil
	if self.flBtn then self.flBtn.Visible = false end
	if self.frBtn then self.frBtn.Visible = false end
	self.moveVector = ZERO_VECTOR3
end

function TouchDPad:Create(parentFrame)
	if self.DPadFrame then
		self.DPadFrame:Destroy()
		self.DPadFrame = nil
	end
	
	local position = UDim2.new(0, 10, 1, -230)
	self.DPadFrame = Instance.new("Frame")
	self.DPadFrame.Name = "DPadFrame"
	self.DPadFrame.Active = true
	self.DPadFrame.Visible = false
	self.DPadFrame.Size = UDim2.new(0, 192, 0, 192)
	self.DPadFrame.Position = position
	self.DPadFrame.BackgroundTransparency = 1
	
	local smArrowSize = UDim2.new(0, 23, 0, 23)
	local lgArrowSize = UDim2.new(0, 64, 0, 64)
	local smImgOffset = Vector2.new(46, 46)
	local lgImgOffset = Vector2.new(128, 128)
	
	local bBtn = CreateArrowLabel("BackButton", UDim2.new(0.5, -32, 1, -64), lgArrowSize, Vector2.new(0, 0), lgImgOffset, self.DPadFrame)
	local fBtn = CreateArrowLabel("ForwardButton", UDim2.new(0.5, -32, 0, 0), lgArrowSize, Vector2.new(0, 258), lgImgOffset, self.DPadFrame)
	local lBtn = CreateArrowLabel("LeftButton", UDim2.new(0, 0, 0.5, -32), lgArrowSize, Vector2.new(129, 129), lgImgOffset, self.DPadFrame)
	local rBtn = CreateArrowLabel("RightButton", UDim2.new(1, -64, 0.5, -32), lgArrowSize, Vector2.new(0, 129), lgImgOffset, self.DPadFrame)
	local jumpBtn = CreateArrowLabel("JumpButton", UDim2.new(0.5, -32, 0.5, -32), lgArrowSize, Vector2.new(129, 0), lgImgOffset, self.DPadFrame)
	self.flBtn = CreateArrowLabel("ForwardLeftButton", UDim2.new(0, 35, 0, 35), smArrowSize, Vector2.new(129, 258), smImgOffset, self.DPadFrame)
	self.frBtn = CreateArrowLabel("ForwardRightButton", UDim2.new(1, -55, 0, 35), smArrowSize, Vector2.new(176, 258), smImgOffset, self.DPadFrame)
	self.flBtn.Visible = false
	self.frBtn.Visible = false
	
	-- input connections
	jumpBtn.InputBegan:Connect(function(inputObject)
		self.isJumping = true
	end)
	
	local function normalizeDirection(inputPosition)
		local jumpRadius = jumpBtn.AbsoluteSize.x*0.5
		local centerPosition = self:GetCenterPosition()
		local direction = Vector2.new(inputPosition.x - centerPosition.x, inputPosition.y - centerPosition.y)
		
		if direction.magnitude > jumpRadius then
			local angle = math.atan2(direction.y, direction.x)
			local octant = (math.floor(8 * angle / (2 * math.pi) + 8.5)%8) + 1
			self.moveVector = COMPASS_DIR[octant]
		end
		
		if not self.flBtn.Visible and self.moveVector == COMPASS_DIR[7] then
			self.flBtn.Visible = true
			self.frBtn.Visible = true
		end
	end
	
	self.DPadFrame.InputBegan:Connect(function(inputObject)
		if self.touchObject or inputObject.UserInputType ~= Enum.UserInputType.Touch then
			return
		end
		
		self.touchObject = inputObject
		normalizeDirection(self.touchObject.Position)
	end)
	
	self.DPadFrame.InputChanged:Connect(function(inputObject)
		if inputObject == self.touchObject then
			normalizeDirection(self.touchObject.Position)
			self.isJumping = false
		end
	end)
	
	self.DPadFrame.InputEnded:connect(function(inputObject)
		if inputObject == self.touchObject then
			self:OnInputEnded()
		end
	end)
	
	GuiService.MenuOpened:Connect(function()
		if self.touchObject then
			self:OnInputEnded()
		end
	end)
	
	self.DPadFrame.Parent = parentFrame
end

return TouchDPad
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXE29177AC41C94547A56892C1C48A6AEB">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">TouchThumbstick</string>
							<string name="ScriptGuid">{B9E449EA-C560-4E9B-BDC8-1B9846CAF04F}</string>
							<ProtectedString name="Source"><![CDATA[--[[
	
	TouchThumbstick
	
--]]

local Players = game:GetService("Players")
local GuiService = game:GetService("GuiService")
local UserInputService = game:GetService("UserInputService")

--[[ Constants ]]--
local ZERO_VECTOR3 = Vector3.new(0,0,0)
local TOUCH_CONTROL_SHEET = "rbxasset://textures/ui/TouchControlsSheet.png"

--[[ The Module ]]--
local BaseCharacterController = require(script.Parent:WaitForChild("BaseCharacterController"))
local TouchThumbstick = setmetatable({}, BaseCharacterController)
TouchThumbstick.__index = TouchThumbstick

function TouchThumbstick.new()
	local self = setmetatable(BaseCharacterController.new(), TouchThumbstick)
	
	self.isFollowStick = false
	
	self.thumbstickFrame = nil
	self.moveTouchObject = nil
	self.onTouchMovedConn = nil
	self.onTouchEndedConn = nil
	self.screenPos = nil
	self.stickImage = nil
	self.thumbstickSize = nil -- Float
	
	return self
end

function TouchThumbstick:Enable(enable, uiParentFrame)
	if enable == nil then return false end			-- If nil, return false (invalid argument)
	enable = enable and true or false				-- Force anything non-nil to boolean before comparison
	if self.enabled == enable then return true end	-- If no state change, return true indicating already in requested state
	
	self.moveVector = ZERO_VECTOR3
	self.isJumping = false
	
	if enable then
		-- Enable
		if not self.thumbstickFrame then
			self:Create(uiParentFrame)
		end
		self.thumbstickFrame.Visible = true
	else 
		-- Disable
		self.thumbstickFrame.Visible = false
		self:OnInputEnded()
	end
	self.enabled = enable
end

function TouchThumbstick:OnInputEnded()
	self.thumbstickFrame.Position = self.screenPos
	self.stickImage.Position = UDim2.new(0, self.thumbstickFrame.Size.X.Offset/2 - self.thumbstickSize/4, 0, self.thumbstickFrame.Size.Y.Offset/2 - self.thumbstickSize/4)
	
	self.moveVector = ZERO_VECTOR3
	self.isJumping = false

	self.thumbstickFrame.Position = self.screenPos
	self.moveTouchObject = nil
end

function TouchThumbstick:Create(parentFrame)
	
	if self.thumbstickFrame then
		self.thumbstickFrame:Destroy()
		self.thumbstickFrame = nil
		if self.onTouchMovedConn then
			self.onTouchMovedConn:Disconnect()
			self.onTouchMovedConn = nil
		end
		if self.onTouchEndedConn then
			self.onTouchEndedConn:Disconnect()
			self.onTouchEndedConn = nil
		end
	end
	
	local minAxis = math.min(parentFrame.AbsoluteSize.x, parentFrame.AbsoluteSize.y)
	local isSmallScreen = minAxis <= 500
	self.thumbstickSize = isSmallScreen and 70 or 120
	self.screenPos = isSmallScreen and UDim2.new(0, (self.thumbstickSize/2) - 10, 1, -self.thumbstickSize - 20) or
		UDim2.new(0, self.thumbstickSize/2, 1, -self.thumbstickSize * 1.75)
		
	self.thumbstickFrame = Instance.new("Frame")
	self.thumbstickFrame.Name = "ThumbstickFrame"
	self.thumbstickFrame.Active = true
	self.thumbstickFrame.Visible = false
	self.thumbstickFrame.Size = UDim2.new(0, self.thumbstickSize, 0, self.thumbstickSize)
	self.thumbstickFrame.Position = self.screenPos
	self.thumbstickFrame.BackgroundTransparency = 1
	
	local outerImage = Instance.new("ImageLabel")
	outerImage.Name = "OuterImage"
	outerImage.Image = TOUCH_CONTROL_SHEET
	outerImage.ImageRectOffset = Vector2.new()
	outerImage.ImageRectSize = Vector2.new(220, 220)
	outerImage.BackgroundTransparency = 1
	outerImage.Size = UDim2.new(0, self.thumbstickSize, 0, self.thumbstickSize)
	outerImage.Position = UDim2.new(0, 0, 0, 0)
	outerImage.Parent = self.thumbstickFrame
	
	self.stickImage = Instance.new("ImageLabel")
	self.stickImage.Name = "StickImage"
	self.stickImage.Image = TOUCH_CONTROL_SHEET
	self.stickImage.ImageRectOffset = Vector2.new(220, 0)
	self.stickImage.ImageRectSize = Vector2.new(111, 111)
	self.stickImage.BackgroundTransparency = 1
	self.stickImage.Size = UDim2.new(0, self.thumbstickSize/2, 0, self.thumbstickSize/2)
	self.stickImage.Position = UDim2.new(0, self.thumbstickSize/2 - self.thumbstickSize/4, 0, self.thumbstickSize/2 - self.thumbstickSize/4)
	self.stickImage.ZIndex = 2
	self.stickImage.Parent = self.thumbstickFrame
	
	local centerPosition = nil
	local deadZone = 0.05
	
	local function DoMove(direction)
		
		local currentMoveVector = direction / (self.thumbstickSize/2)
		
		-- Scaled Radial Dead Zone
		local inputAxisMagnitude = currentMoveVector.magnitude
		if inputAxisMagnitude < deadZone then
			currentMoveVector = Vector3.new()
		else
			currentMoveVector = currentMoveVector.unit * ((inputAxisMagnitude - deadZone) / (1 - deadZone))
			-- NOTE: Making currentMoveVector a unit vector will cause the player to instantly go max speed
			-- must check for zero length vector is using unit
			currentMoveVector = Vector3.new(currentMoveVector.x, 0, currentMoveVector.y)
		end
		
		self.moveVector = currentMoveVector
	end
	
	local function MoveStick(pos)
		local relativePosition = Vector2.new(pos.x - centerPosition.x, pos.y - centerPosition.y)
		local length = relativePosition.magnitude
		local maxLength = self.thumbstickFrame.AbsoluteSize.x/2
		if self.isFollowStick and length > maxLength then
			local offset = relativePosition.unit * maxLength
			self.thumbstickFrame.Position = UDim2.new(
				0, pos.x - self.thumbstickFrame.AbsoluteSize.x/2 - offset.x,
				0, pos.y - self.thumbstickFrame.AbsoluteSize.y/2 - offset.y)
		else
			length = math.min(length, maxLength)
			relativePosition = relativePosition.unit * length
		end
		self.stickImage.Position = UDim2.new(0, relativePosition.x + self.stickImage.AbsoluteSize.x/2, 0, relativePosition.y + self.stickImage.AbsoluteSize.y/2)
	end
	
	-- input connections
	self.thumbstickFrame.InputBegan:Connect(function(inputObject)
		--A touch that starts elsewhere on the screen will be sent to a frame's InputBegan event
		--if it moves over the frame. So we check that this is actually a new touch (inputObject.UserInputState ~= Enum.UserInputState.Begin)
		if self.moveTouchObject or inputObject.UserInputType ~= Enum.UserInputType.Touch
			or inputObject.UserInputState ~= Enum.UserInputState.Begin then
			return
		end
		
		self.moveTouchObject = inputObject
		self.thumbstickFrame.Position = UDim2.new(0, inputObject.Position.x - self.thumbstickFrame.Size.X.Offset/2, 0, inputObject.Position.y - self.thumbstickFrame.Size.Y.Offset/2)
		centerPosition = Vector2.new(self.thumbstickFrame.AbsolutePosition.x + self.thumbstickFrame.AbsoluteSize.x/2,
			self.thumbstickFrame.AbsolutePosition.y + self.thumbstickFrame.AbsoluteSize.y/2)
		local direction = Vector2.new(inputObject.Position.x - centerPosition.x, inputObject.Position.y - centerPosition.y)
	end)
	
	self.onTouchMovedConn = UserInputService.TouchMoved:Connect(function(inputObject, isProcessed)
		if inputObject == self.moveTouchObject then
			centerPosition = Vector2.new(self.thumbstickFrame.AbsolutePosition.x + self.thumbstickFrame.AbsoluteSize.x/2,
				self.thumbstickFrame.AbsolutePosition.y + self.thumbstickFrame.AbsoluteSize.y/2)
			local direction = Vector2.new(inputObject.Position.x - centerPosition.x, inputObject.Position.y - centerPosition.y)
			DoMove(direction)
			MoveStick(inputObject.Position)
		end
	end)
	
	self.onTouchEndedConn = UserInputService.TouchEnded:Connect(function(inputObject, isProcessed)
		if inputObject == self.moveTouchObject then
			self:OnInputEnded()
		end
	end)
	
	GuiService.MenuOpened:Connect(function()
		if self.moveTouchObject then
			self:OnInputEnded()
		end
	end)	
	
	self.thumbstickFrame.Parent = parentFrame
end

return TouchThumbstick
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX604621B3C67C441B970C49A0DEF29135">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Gamepad</string>
							<string name="ScriptGuid">{F177B349-24EC-4619-93C3-3CAF6B8D31E3}</string>
							<ProtectedString name="Source"><![CDATA[--[[
	Gamepad Character Control - This module handles controlling your avatar using a game console-style controller
	
	2018 PlayerScripts Update - AllYourBlox		
--]]

local UserInputService = game:GetService("UserInputService")
local ContextActionService = game:GetService("ContextActionService")

--[[ Constants ]]--
local ZERO_VECTOR3 = Vector3.new(0,0,0)
local NONE = Enum.UserInputType.None
local thumbstickDeadzone = 0.2

--[[ The Module ]]--
local BaseCharacterController = require(script.Parent:WaitForChild("BaseCharacterController"))
local Gamepad = setmetatable({}, BaseCharacterController)
Gamepad.__index = Gamepad

local bindAtPriorityFlagExists, bindAtPriorityFlagEnabled = pcall(function()
	return UserSettings():IsUserFeatureEnabled("UserPlayerScriptsBindAtPriority")
end)
local FFlagPlayerScriptsBindAtPriority = bindAtPriorityFlagExists and bindAtPriorityFlagEnabled

function Gamepad.new(CONTROL_ACTION_PRIORITY)
	local self = setmetatable(BaseCharacterController.new(), Gamepad)
	
	self.CONTROL_ACTION_PRIORITY = CONTROL_ACTION_PRIORITY
	
	self.forwardValue  = 0
	self.backwardValue = 0
	self.leftValue = 0
	self.rightValue = 0
	
	self.activeGamepad = NONE	-- Enum.UserInputType.Gamepad1, 2, 3...
	self.gamepadConnectedConn = nil
	self.gamepadDisconnectedConn = nil
	return self
end

function Gamepad:Enable(enable)
	if not UserInputService.GamepadEnabled then
		return false
	end
	
	if enable == self.enabled then
		-- Module is already in the state being requested. True is returned here since the module will be in the state
		-- expected by the code that follows the Enable() call. This makes more sense than returning false to indicate
		-- no action was necessary. False indicates failure to be in requested/expected state.
		return true
	end
	
	self.forwardValue  = 0
	self.backwardValue = 0
	self.leftValue = 0
	self.rightValue = 0
	self.moveVector = ZERO_VECTOR3
	self.isJumping = false
	
	if enable then
		self.activeGamepad = self:GetHighestPriorityGamepad()
		if self.activeGamepad ~= NONE then
			self:BindContextActions()
			self:ConnectGamepadConnectionListeners()
		else
			-- No connected gamepads, failure to enable
			return false
		end
	else
		self:UnbindContextActions()
		self:DisconnectGamepadConnectionListeners()
		self.activeGamepad = NONE
	end
	
	self.enabled = enable
	return true
end

-- This function selects the lowest number gamepad from the currently-connected gamepad
-- and sets it as the active gamepad
function Gamepad:GetHighestPriorityGamepad()
	local connectedGamepads = UserInputService:GetConnectedGamepads()
	local bestGamepad = NONE -- Note that this value is higher than all valid gamepad values
	for _, gamepad in pairs(connectedGamepads) do
		if gamepad.Value < bestGamepad.Value then
			bestGamepad = gamepad
		end
	end
	return bestGamepad
end

function Gamepad:BindContextActions()
	
	if self.activeGamepad == NONE then
		-- There must be an active gamepad to set up bindings
		return false
	end
	
	
	local updateMovement = function(inputState)
		if inputState == Enum.UserInputState.Cancel then
			self.moveVector = ZERO_VECTOR3
		else
			self.moveVector = Vector3.new(self.leftValue + self.rightValue, 0, self.forwardValue + self.backwardValue)
		end
	end
	
	-- Note: In the previous version of this code, the movement values were not zeroed-out on UserInputState. Cancel, now they are,
	-- which fixes them from getting stuck on.
	local handleMoveForward = function(actionName, inputState, inputObject)			
		self.forwardValue = (inputState == Enum.UserInputState.Begin) and -1 or 0
		updateMovement(inputState)
	end
	
	local handleMoveBackward = function(actionName, inputState, inputObject)	
		self.backwardValue = (inputState == Enum.UserInputState.Begin) and 1 or 0
		updateMovement(inputState)
	end
	
	local handleMoveLeft = function(actionName, inputState, inputObject)	
		self.leftValue = (inputState == Enum.UserInputState.Begin) and -1 or 0
		updateMovement(inputState)
	end
	
	local handleMoveRight = function(actionName, inputState, inputObject)	
		self.rightValue = (inputState == Enum.UserInputState.Begin) and 1 or 0
		updateMovement(inputState)
	end
	
	local handleJumpAction = function(actionName, inputState, inputObject)
		self.isJumping = (inputState == Enum.UserInputState.Begin)
		if FFlagPlayerScriptsBindAtPriority then
			return Enum.ContextActionResult.Sink
		end
	end
	
	local handleThumbstickInput = function(actionName, inputState, inputObject)
		
		if inputState == Enum.UserInputState.Cancel then
			self.moveVector = ZERO_VECTOR3
			return FFlagPlayerScriptsBindAtPriority and Enum.ContextActionResult.Sink or nil
		end
		
		if self.activeGamepad ~= inputObject.UserInputType then 
			return FFlagPlayerScriptsBindAtPriority and Enum.ContextActionResult.Pass or nil
		end
		if inputObject.KeyCode ~= Enum.KeyCode.Thumbstick1 then return end
		
		if inputObject.Position.magnitude > thumbstickDeadzone then
			self.moveVector  =  Vector3.new(inputObject.Position.X, 0, -inputObject.Position.Y)
		else
			self.moveVector = ZERO_VECTOR3
		end
		if FFlagPlayerScriptsBindAtPriority then
			return Enum.ContextActionResult.Sink
		end
	end
	
	ContextActionService:BindActivate(self.activeGamepad, Enum.KeyCode.ButtonR2)
	if FFlagPlayerScriptsBindAtPriority then
		ContextActionService:BindActionAtPriority("jumpAction", handleJumpAction, false,
			self.CONTROL_ACTION_PRIORITY, Enum.KeyCode.ButtonA)
		ContextActionService:BindActionAtPriority("moveThumbstick", handleThumbstickInput, false,
			self.CONTROL_ACTION_PRIORITY, Enum.KeyCode.Thumbstick1)
	else
		ContextActionService:BindAction("jumpAction",handleJumpAction, false, Enum.KeyCode.ButtonA)
		ContextActionService:BindAction("moveThumbstick",handleThumbstickInput, false, Enum.KeyCode.Thumbstick1)
	end
	
	return true
end

function Gamepad:UnbindContextActions()
	if self.activeGamepad ~= NONE then
		ContextActionService:UnbindActivate(self.activeGamepad, Enum.KeyCode.ButtonR2)
	end
	ContextActionService:UnbindAction("moveThumbstick")
	ContextActionService:UnbindAction("jumpAction")
end

function Gamepad:OnNewGamepadConnected()
	-- A new gamepad has been connected.
	local bestGamepad = self:GetHighestPriorityGamepad()
	
	if bestGamepad == self.activeGamepad then
		-- A new gamepad was connected, but our active gamepad is not changing
		return
	end
	
	if bestGamepad == NONE then
		-- There should be an active gamepad when GamepadConnected fires, so this should not
		-- normally be hit. If there is no active gamepad, unbind actions but leave
		-- the module enabled and continue to listen for a new gamepad connection.
		warn("Gamepad:OnNewGamepadConnected found no connected gamepads")
		self:UnbindContextActions()
		return
	end
	
	if self.activeGamepad ~= NONE then
		-- Switching from one active gamepad to another
		self:UnbindContextActions()
	end
	
	self.activeGamepad = bestGamepad
	self:BindContextActions()
end

function Gamepad:OnCurrentGamepadDisconnected()
	if self.activeGamepad ~= NONE then
		ContextActionService:UnbindActivate(self.activeGamepad, Enum.KeyCode.ButtonR2)
	end
	
	local bestGamepad = self:GetHighestPriorityGamepad()

	if self.activeGamepad ~= NONE and bestGamepad == self.activeGamepad then
		warn("Gamepad:OnCurrentGamepadDisconnected found the supposedly disconnected gamepad in connectedGamepads.")
		self:UnbindContextActions()
		self.activeGamepad = NONE
		return
	end	
	
	if bestGamepad == NONE then
		-- No active gamepad, unbinding actions but leaving gamepad connection listener active
		self:UnbindContextActions()
		self.activeGamepad = NONE
	else
		-- Set new gamepad as active and bind to tool activation
		self.activeGamepad = bestGamepad
		ContextActionService:BindActivate(self.activeGamepad, Enum.KeyCode.ButtonR2)
	end
end

function Gamepad:ConnectGamepadConnectionListeners()
	self.gamepadConnectedConn = UserInputService.GamepadConnected:Connect(function(gamepadEnum)
		self:OnNewGamepadConnected()
	end)
	
	self.gamepadDisconnectedConn = UserInputService.GamepadDisconnected:Connect(function(gamepadEnum)
		if self.activeGamepad == gamepadEnum then
			self:OnCurrentGamepadDisconnected()
		end
	end)

end

function Gamepad:DisconnectGamepadConnectionListeners()
	if self.gamepadConnectedConn then
		self.gamepadConnectedConn:Disconnect()
		self.gamepadConnectedConn = nil
	end
	
	if self.gamepadDisconnectedConn then
		self.gamepadDisconnectedConn:Disconnect()
		self.gamepadDisconnectedConn = nil
	end
end

return Gamepad
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX9C87A9FBB07B42C29C1D3842557FA113">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Keyboard</string>
							<string name="ScriptGuid">{A912C141-707F-4B55-919B-AF32AC8A7DF6}</string>
							<ProtectedString name="Source"><![CDATA[--[[
	Keyboard Character Control - This module handles controlling your avatar from a keyboard
	
	2018 PlayerScripts Update - AllYourBlox		
--]]

--[[ Roblox Services ]]--
local UserInputService = game:GetService("UserInputService")
local ContextActionService = game:GetService("ContextActionService")

--[[ Constants ]]--
local ZERO_VECTOR3 = Vector3.new(0,0,0)

--[[ The Module ]]--
local BaseCharacterController = require(script.Parent:WaitForChild("BaseCharacterController"))
local Keyboard = setmetatable({}, BaseCharacterController)
Keyboard.__index = Keyboard

local bindAtPriorityFlagExists, bindAtPriorityFlagEnabled = pcall(function()
	return UserSettings():IsUserFeatureEnabled("UserPlayerScriptsBindAtPriority")
end)
local FFlagPlayerScriptsBindAtPriority = bindAtPriorityFlagExists and bindAtPriorityFlagEnabled

function Keyboard.new(CONTROL_ACTION_PRIORITY)
	local self = setmetatable(BaseCharacterController.new(), Keyboard)
	
	self.CONTROL_ACTION_PRIORITY = CONTROL_ACTION_PRIORITY
	
	self.textFocusReleasedConn = nil
	self.textFocusGainedConn = nil
	self.windowFocusReleasedConn = nil
	
	self.forwardValue  = 0
	self.backwardValue = 0
	self.leftValue = 0
	self.rightValue = 0
	return self
end

function Keyboard:Enable(enable)
	if not UserInputService.KeyboardEnabled then
		return false
	end
	
	if enable == self.enabled then
		-- Module is already in the state being requested. True is returned here since the module will be in the state
		-- expected by the code that follows the Enable() call. This makes more sense than returning false to indicate
		-- no action was necessary. False indicates failure to be in requested/expected state.
		return true
	end
	
	self.forwardValue  = 0
	self.backwardValue = 0
	self.leftValue = 0
	self.rightValue = 0
	self.moveVector = ZERO_VECTOR3
	self.isJumping = false
	
	if enable then
		self:BindContextActions()
		self:ConnectFocusEventListeners()
	else
		self:UnbindContextActions()
		self:DisconnectFocusEventListeners()
	end
	
	self.enabled = enable
	return true
end

function Keyboard:UpdateMovement(inputState)
	if inputState == Enum.UserInputState.Cancel then
		self.moveVector = ZERO_VECTOR3
	else
		self.moveVector = Vector3.new(self.leftValue + self.rightValue, 0, self.forwardValue + self.backwardValue)
	end
end

function Keyboard:BindContextActions()
	
	-- Note: In the previous version of this code, the movement values were not zeroed-out on UserInputState. Cancel, now they are,
	-- which fixes them from getting stuck on.
	local handleMoveForward = function(actionName, inputState, inputObject)			
		self.forwardValue = (inputState == Enum.UserInputState.Begin) and -1 or 0
		self:UpdateMovement(inputState)
		if FFlagPlayerScriptsBindAtPriority then
			return Enum.ContextActionResult.Sink
		end
	end
	
	local handleMoveBackward = function(actionName, inputState, inputObject)	
		self.backwardValue = (inputState == Enum.UserInputState.Begin) and 1 or 0
		self:UpdateMovement(inputState)
		if FFlagPlayerScriptsBindAtPriority then
			return Enum.ContextActionResult.Sink
		end
	end
	
	local handleMoveLeft = function(actionName, inputState, inputObject)	
		self.leftValue = (inputState == Enum.UserInputState.Begin) and -1 or 0
		self:UpdateMovement(inputState)
		if FFlagPlayerScriptsBindAtPriority then
			return Enum.ContextActionResult.Sink
		end
	end
	
	local handleMoveRight = function(actionName, inputState, inputObject)	
		self.rightValue = (inputState == Enum.UserInputState.Begin) and 1 or 0
		self:UpdateMovement(inputState)
		if FFlagPlayerScriptsBindAtPriority then
			return Enum.ContextActionResult.Sink
		end
	end
	
	local handleJumpAction = function(actionName, inputState, inputObject)
		self.isJumping = (inputState == Enum.UserInputState.Begin)
		if FFlagPlayerScriptsBindAtPriority then
			return Enum.ContextActionResult.Sink
		end
	end
	
	-- TODO: Revert to KeyCode bindings so that in the future the abstraction layer from actual keys to
	-- movement direction is done in Lua
	if FFlagPlayerScriptsBindAtPriority then
		ContextActionService:BindActionAtPriority("moveForwardAction", handleMoveForward, false,
			self.CONTROL_ACTION_PRIORITY, Enum.PlayerActions.CharacterForward)
		ContextActionService:BindActionAtPriority("moveBackwardAction", handleMoveBackward, false,
			self.CONTROL_ACTION_PRIORITY, Enum.PlayerActions.CharacterBackward)
		ContextActionService:BindActionAtPriority("moveLeftAction", handleMoveLeft, false,
			self.CONTROL_ACTION_PRIORITY, Enum.PlayerActions.CharacterLeft)
		ContextActionService:BindActionAtPriority("moveRightAction", handleMoveRight, false,
			self.CONTROL_ACTION_PRIORITY, Enum.PlayerActions.CharacterRight)
		ContextActionService:BindActionAtPriority("jumpAction", handleJumpAction, false,
			self.CONTROL_ACTION_PRIORITY, Enum.PlayerActions.CharacterJump)
	else 
		ContextActionService:BindAction("moveForwardAction", handleMoveForward, false, Enum.PlayerActions.CharacterForward)
		ContextActionService:BindAction("moveBackwardAction", handleMoveBackward, false, Enum.PlayerActions.CharacterBackward)
		ContextActionService:BindAction("moveLeftAction", handleMoveLeft, false, Enum.PlayerActions.CharacterLeft)
		ContextActionService:BindAction("moveRightAction", handleMoveRight, false, Enum.PlayerActions.CharacterRight)
		ContextActionService:BindAction("jumpAction",handleJumpAction,false,Enum.PlayerActions.CharacterJump)
	end
end

function Keyboard:UnbindContextActions()
	ContextActionService:UnbindAction("moveForwardAction")
	ContextActionService:UnbindAction("moveBackwardAction")
	ContextActionService:UnbindAction("moveLeftAction")
	ContextActionService:UnbindAction("moveRightAction")
	ContextActionService:UnbindAction("jumpAction")
end

function Keyboard:ConnectFocusEventListeners()
	local function onFocusReleased()
		self.moveVector = ZERO_VECTOR3
		self.forwardValue  = 0
		self.backwardValue = 0
		self.leftValue = 0
		self.rightValue = 0
		self.isJumping = false
	end
	
	local function onTextFocusGained(textboxFocused)
		self.isJumping = false
	end
	
	self.textFocusReleasedConn = UserInputService.TextBoxFocusReleased:Connect(onFocusReleased)
	self.textFocusGainedConn = UserInputService.TextBoxFocused:Connect(onTextFocusGained)
	self.windowFocusReleasedConn = UserInputService.WindowFocused:Connect(onFocusReleased)
end

function Keyboard:DisconnectFocusEventListeners()
	if self.textFocusReleasedCon then
		self.textFocusReleasedCon:Disconnect()
		self.textFocusReleasedCon = nil
	end
	if self.textFocusGainedConn then
		self.textFocusGainedConn:Disconnect()
		self.textFocusGainedConn = nil
	end
	if self.windowFocusReleasedConn then
		self.windowFocusReleasedConn:Disconnect()
		self.windowFocusReleasedConn = nil
	end
end

return Keyboard
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="ModuleScript" referent="RBXC7F9CE13F50147B59D3E534F45525D59">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">CameraModule</string>
						<string name="ScriptGuid">{5C72B4C4-36E5-412A-9C3D-E532FF8CB40E}</string>
						<ProtectedString name="Source"><![CDATA[--[[
	CameraModule - This ModuleScript implements a singleton class to manage the
	selection, activation, and deactivation of the current camera controller,
	character occlusion controller, and transparency controller. This script binds to
	RenderStepped at Camera priority and calls the Update() methods on the active
	controller instances.
	
	The camera controller ModuleScripts implement classes which are instantiated and
	activated as-needed, they are no longer all instantiated up front as they were in
	the previous generation of PlayerScripts.
	
	2018 PlayerScripts Update - AllYourBlox		
--]]

local CameraModule = {}
CameraModule.__index = CameraModule

-- NOTICE: Player property names do not all match their StarterPlayer equivalents,
-- with the differences noted in the comments on the right
local PLAYER_CAMERA_PROPERTIES =
{
	"CameraMinZoomDistance",
	"CameraMaxZoomDistance",
	"CameraMode",
	"DevCameraOcclusionMode",
	"DevComputerCameraMode",			-- Corresponds to StarterPlayer.DevComputerCameraMovementMode
	"DevTouchCameraMode",				-- Corresponds to StarterPlayer.DevTouchCameraMovementMode
	
	-- Character movement mode
	"DevComputerMovementMode",
	"DevTouchMovementMode",
	"DevEnableMouseLock",				-- Corresponds to StarterPlayer.EnableMouseLockOption
}

local USER_GAME_SETTINGS_PROPERTIES =
{
	"ComputerCameraMovementMode",
	"ComputerMovementMode",
	"ControlMode",
	"GamepadCameraSensitivity",
	"MouseSensitivity",
	"RotationType",
	"TouchCameraMovementMode",
	"TouchMovementMode",
}

--[[ Roblox Services ]]--
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local StarterPlayer = game:GetService("StarterPlayer")
local UserGameSettings = UserSettings():GetService("UserGameSettings")

-- Camera math utility library
local CameraUtils = require(script:WaitForChild("CameraUtils"))

-- Load Roblox Camera Controller Modules
local ClassicCamera = require(script:WaitForChild("ClassicCamera"))
local OrbitalCamera = require(script:WaitForChild("OrbitalCamera"))
local LegacyCamera = require(script:WaitForChild("LegacyCamera"))

-- Load Roblox Occlusion Modules
local Invisicam = require(script:WaitForChild("Invisicam"))
local Poppercam do
	local success, useNewPoppercam = pcall(UserSettings().IsUserFeatureEnabled, UserSettings(), "UserNewPoppercam4")
	if success and useNewPoppercam then
		Poppercam = require(script:WaitForChild("Poppercam"))
	else
		Poppercam = require(script:WaitForChild("Poppercam_Classic"))
	end
end

-- Load the near-field character transparency controller and the mouse lock "shift lock" controller
local TransparencyController = require(script:WaitForChild("TransparencyController"))
local MouseLockController = require(script:WaitForChild("MouseLockController"))

-- Table of camera controllers that have been instantiated. They are instantiated as they are used.
local instantiatedCameraControllers = {}
local instantiatedOcclusionModules = {}

-- Management of which options appear on the Roblox User Settings screen
do
	local PlayerScripts = Players.LocalPlayer:WaitForChild("PlayerScripts")

	PlayerScripts:RegisterTouchCameraMovementMode(Enum.TouchCameraMovementMode.Default)
	PlayerScripts:RegisterTouchCameraMovementMode(Enum.TouchCameraMovementMode.Follow)
	PlayerScripts:RegisterTouchCameraMovementMode(Enum.TouchCameraMovementMode.Classic)

	PlayerScripts:RegisterComputerCameraMovementMode(Enum.ComputerCameraMovementMode.Default)
	PlayerScripts:RegisterComputerCameraMovementMode(Enum.ComputerCameraMovementMode.Follow)
	PlayerScripts:RegisterComputerCameraMovementMode(Enum.ComputerCameraMovementMode.Classic)
end


function CameraModule.new()
	local self = setmetatable({},CameraModule)
	
	-- Current active controller instances
	self.activeCameraController = nil
	self.activeOcclusionModule = nil
	self.activeTransparencyController = nil
	self.activeMouseLockController = nil
	
	self.currentComputerCameraMovementMode = nil
	
	-- Connections to events
	self.cameraSubjectChangedConn = nil
	self.cameraTypeChangedConn = nil
	
	-- Adds CharacterAdded and CharacterRemoving event handlers for all current players
	for _,player in pairs(Players:GetPlayers()) do
		self:OnPlayerAdded(player)
	end
	
	-- Adds CharacterAdded and CharacterRemoving event handlers for all players who join in the future
	Players.PlayerAdded:Connect(function(player)
		self:OnPlayerAdded(player)
	end)

	self.activeTransparencyController = TransparencyController.new()
	self.activeTransparencyController:Enable(true)
	
	if not UserInputService.TouchEnabled then
		self.activeMouseLockController = MouseLockController.new()
		local toggleEvent = self.activeMouseLockController:GetBindableToggleEvent()
		if toggleEvent then
			toggleEvent:Connect(function()
				self:OnMouseLockToggled()
			end)
		end
	end
	
	self:ActivateCameraController(self:GetCameraControlChoice())
	self:ActivateOcclusionModule(Players.LocalPlayer.DevCameraOcclusionMode)
	self:OnCurrentCameraChanged() -- Does initializations and makes first camera controller
	RunService:BindToRenderStep("cameraRenderUpdate", Enum.RenderPriority.Camera.Value, function(dt) self:Update(dt) end)
	
	-- Connect listeners to camera-related properties
	for _, propertyName in pairs(PLAYER_CAMERA_PROPERTIES) do
		Players.LocalPlayer:GetPropertyChangedSignal(propertyName):Connect(function()
			self:OnLocalPlayerCameraPropertyChanged(propertyName)
		end)
	end
	
	for _, propertyName in pairs(USER_GAME_SETTINGS_PROPERTIES) do
		UserGameSettings:GetPropertyChangedSignal(propertyName):Connect(function()
			self:OnUserGameSettingsPropertyChanged(propertyName)
		end)
	end
	game.Workspace:GetPropertyChangedSignal("CurrentCamera"):Connect(function()
		self:OnCurrentCameraChanged()
	end)

	self.lastInputType = UserInputService:GetLastInputType()
	UserInputService.LastInputTypeChanged:Connect(function(newLastInputType)
		self.lastInputType = newLastInputType
	end)

	return self
end





function CameraModule:GetCameraMovementModeFromSettings()
	local cameraMode = Players.LocalPlayer.CameraMode

	-- Lock First Person trumps all other settings and forces ClassicCamera
	if cameraMode == Enum.CameraMode.LockFirstPerson then
		return CameraUtils.ConvertCameraModeEnumToStandard(Enum.ComputerCameraMovementMode.Classic)
	end

	local devMode, userMode
	if UserInputService.TouchEnabled then
		devMode = CameraUtils.ConvertCameraModeEnumToStandard(Players.LocalPlayer.DevTouchCameraMode)
		userMode = CameraUtils.ConvertCameraModeEnumToStandard(UserGameSettings.TouchCameraMovementMode)
	else
		devMode = CameraUtils.ConvertCameraModeEnumToStandard(Players.LocalPlayer.DevComputerCameraMode)
		userMode = CameraUtils.ConvertCameraModeEnumToStandard(UserGameSettings.ComputerCameraMovementMode)
	end	
	
	if devMode == Enum.DevComputerCameraMovementMode.UserChoice then
		-- Developer is allowing user choice, so user setting is respected
		return userMode
	end

	return devMode
end

function CameraModule:ActivateOcclusionModule( occlusionMode )
	local newModuleCreator = nil
	if occlusionMode == Enum.DevCameraOcclusionMode.Zoom then
		newModuleCreator = Poppercam
	elseif occlusionMode == Enum.DevCameraOcclusionMode.Invisicam then
		newModuleCreator = Invisicam
	else
		warn("CameraScript ActivateOcclusionModule called with unsupported mode")
		return
	end
	
	-- First check to see if there is actually a change. If the module being requested is already
	-- the currently-active solution then just make sure it's enabled and exit early
	if self.activeOcclusionModule and self.activeOcclusionModule:GetOcclusionMode() == occlusionMode then
		if not self.activeOcclusionModule:GetEnabled() then
			self.activeOcclusionModule:Enable(true)
		end
		return
	end
	
	-- Save a reference to the current active module (may be nil) so that we can disable it if
	-- we are successful in activating its replacement
	local prevOcclusionModule = self.activeOcclusionModule
	
	-- If there is no active module, see if the one we need has already been instantiated
	self.activeOcclusionModule = instantiatedOcclusionModules[newModuleCreator]
	
	-- If the module was not already instantiated and selected above, instantiate it
	if not self.activeOcclusionModule then
		self.activeOcclusionModule = newModuleCreator.new()
		if self.activeOcclusionModule then
			instantiatedOcclusionModules[newModuleCreator] = self.activeOcclusionModule
		end
	end
	
	-- If we were successful in either selecting or instantiating the module,
	-- enable it if it's not already the currently-active enabled module
	if self.activeOcclusionModule then
		local newModuleOcclusionMode = self.activeOcclusionModule:GetOcclusionMode()
		-- Sanity check that the module we selected or instantiated actually supports the desired occlusionMode
		if newModuleOcclusionMode ~= occlusionMode then
			warn("CameraScript ActivateOcclusionModule mismatch: ",self.activeOcclusionModule:GetOcclusionMode(),"~=",occlusionMode)
		end		
		
		-- Deactivate current module if there is one
		if prevOcclusionModule then
			-- Sanity check that current module is not being replaced by itself (that should have been handled above)
			if prevOcclusionModule ~= self.activeOcclusionModule then
				prevOcclusionModule:Enable(false)
			else
				warn("CameraScript ActivateOcclusionModule failure to detect already running correct module")
			end
		end
		
		-- Occlusion modules need to be initialized with information about characters and cameraSubject
		-- Invisicam needs the LocalPlayer's character
		-- Poppercam needs all player characters and the camera subject
		if occlusionMode == Enum.DevCameraOcclusionMode.Invisicam then
			-- Optimization to only send Invisicam what we know it needs
			if Players.LocalPlayer.Character then
				self.activeOcclusionModule:CharacterAdded(Players.LocalPlayer.Character, Players.LocalPlayer )
			end
		else
			-- When Poppercam is enabled, we send it all existing player characters for its raycast ignore list
			for _, player in pairs(Players:GetPlayers()) do
				if player and player.Character then
					self.activeOcclusionModule:CharacterAdded(player.Character, player)
				end
			end
			self.activeOcclusionModule:OnCameraSubjectChanged(game.Workspace.CurrentCamera.CameraSubject)
		end
		
		-- Activate new choice
		self.activeOcclusionModule:Enable(true)
	end
end

-- When supplied, legacyCameraType is used and cameraMovementMode is ignored (should be nil anyways)
-- Next, if userCameraCreator is passed in, that is used as the cameraCreator
function CameraModule:ActivateCameraController( cameraMovementMode, legacyCameraType )
	local newCameraCreator = nil
	
	if legacyCameraType~=nil then
		--[[ 
			This function has been passed a CameraType enum value. Some of these map to the use of
			the LegacyCamera module, the value "Custom" will be translated to a movementMode enum
			value based on Dev and User settings, and "Scriptable" will disable the camera controller.
		--]]
		
		if legacyCameraType == Enum.CameraType.Scriptable then
			if self.activeCameraController then
				self.activeCameraController:Enable(false)
				self.activeCameraController = nil				
				return
			end
		elseif legacyCameraType == Enum.CameraType.Custom then
			cameraMovementMode = self:GetCameraMovementModeFromSettings()
			
		elseif legacyCameraType == Enum.CameraType.Track then
			-- Note: The TrackCamera module was basically an older, less fully-featured
			-- version of ClassicCamera, no longer actively maintained, but it is re-implemented in
			-- case a game was dependent on its lack of ClassicCamera's extra functionality.
			cameraMovementMode = Enum.ComputerCameraMovementMode.Classic
			
		elseif legacyCameraType == Enum.CameraType.Follow then
			cameraMovementMode = Enum.ComputerCameraMovementMode.Follow
			
		elseif legacyCameraType == Enum.CameraType.Orbital then
			cameraMovementMode = Enum.ComputerCameraMovementMode.Orbital
			
		elseif legacyCameraType == Enum.CameraType.Attach or
			   legacyCameraType == Enum.CameraType.Watch or
			   legacyCameraType == Enum.CameraType.Fixed then
			newCameraCreator = LegacyCamera
		else
			warn("CameraScript encountered an unhandled Camera.CameraType value: ",legacyCameraType)			
		end		
	end
	
	if not newCameraCreator then		
		if cameraMovementMode == Enum.ComputerCameraMovementMode.Classic or
			cameraMovementMode == Enum.ComputerCameraMovementMode.Follow or
			cameraMovementMode == Enum.ComputerCameraMovementMode.Default then
			newCameraCreator = ClassicCamera
		elseif cameraMovementMode == Enum.ComputerCameraMovementMode.Orbital then
			newCameraCreator = OrbitalCamera
		else
			warn("ActivateCameraController did not select a module.")
			return
		end
	end
	
	-- Create the camera control module we need if it does not already exist in instantiatedCameraControllers
	local newCameraController = nil
	if not instantiatedCameraControllers[newCameraCreator] then
		newCameraController = newCameraCreator.new()
		instantiatedCameraControllers[newCameraCreator] = newCameraController
	else
		newCameraController = instantiatedCameraControllers[newCameraCreator]
	end
	
	-- If there is a controller active and it's not the one we need, disable it,
	-- if it is the one we need, make sure it's enabled
	if self.activeCameraController then
		if self.activeCameraController ~= newCameraController then
			self.activeCameraController:Enable(false)
			self.activeCameraController = newCameraController
			self.activeCameraController:Enable(true)		
		elseif not self.activeCameraController:GetEnabled() then
			self.activeCameraController:Enable(true)
		end		
	elseif newCameraController ~= nil then
		self.activeCameraController = newCameraController
		self.activeCameraController:Enable(true)		
	end
	
	if self.activeCameraController then
		if cameraMovementMode~=nil then
			self.activeCameraController:SetCameraMovementMode(cameraMovementMode)
		elseif legacyCameraType~=nil then
			-- Note that this is only called when legacyCameraType is not a type that
			-- was convertible to a ComputerCameraMovementMode value, i.e. really only applies to LegacyCamera
			self.activeCameraController:SetCameraType(legacyCameraType)
		end
	end
end

-- Note: The active transparency controller could be made to listen for this event itself.
function CameraModule:OnCameraSubjectChanged()
	if self.activeTransparencyController then
		self.activeTransparencyController:SetSubject(game.Workspace.CurrentCamera.CameraSubject)
	end
	
	if self.activeOcclusionModule then
		self.activeOcclusionModule:OnCameraSubjectChanged(game.Workspace.CurrentCamera.CameraSubject)
	end
end

function CameraModule:OnCameraTypeChanged(newCameraType)
	if newCameraType == Enum.CameraType.Scriptable then
		if UserInputService.MouseBehavior == Enum.MouseBehavior.LockCenter then
			UserInputService.MouseBehavior = Enum.MouseBehavior.Default
		end
	end
	
	-- Forward the change to ActivateCameraController to handle
	self:ActivateCameraController(nil, newCameraType)	
end

-- Note: Called whenever workspace.CurrentCamera changes, but also on initialization of this script
function CameraModule:OnCurrentCameraChanged()
	local currentCamera = game.Workspace.CurrentCamera
	if not currentCamera then return end
	
	if self.cameraSubjectChangedConn then
		self.cameraSubjectChangedConn:Disconnect()
	end

	if self.cameraTypeChangedConn then
		self.cameraTypeChangedConn:Disconnect()
	end

	self.cameraSubjectChangedConn = currentCamera:GetPropertyChangedSignal("CameraSubject"):Connect(function()
		self:OnCameraSubjectChanged(currentCamera.CameraSubject)
	end)

	self.cameraTypeChangedConn = currentCamera:GetPropertyChangedSignal("CameraType"):Connect(function()
		self:OnCameraTypeChanged(currentCamera.CameraType)
	end)

	self:OnCameraSubjectChanged(currentCamera.CameraSubject)
	self:OnCameraTypeChanged(currentCamera.CameraType)
end

function CameraModule:OnLocalPlayerCameraPropertyChanged(propertyName)
	if propertyName == "CameraMode" then
		-- CameraMode is only used to turn on/off forcing the player into first person view. The
		-- Note: The case "Classic" is used for all other views and does not correspond only to the ClassicCamera module
		if Players.LocalPlayer.CameraMode == Enum.CameraMode.LockFirstPerson then
			-- Locked in first person, use ClassicCamera which supports this
			if not self.activeCameraController or self.activeCameraController:GetModuleName() ~= "ClassicCamera" then
				self:ActivateCameraController(CameraUtils.ConvertCameraModeEnumToStandard(Enum.DevComputerCameraMovementMode.Classic))
			end
			
			if self.activeCameraController then
				self.activeCameraController:UpdateForDistancePropertyChange()
			end
		elseif Players.LocalPlayer.CameraMode == Enum.CameraMode.Classic then
			-- Not locked in first person view
			local cameraMovementMode =self: GetCameraMovementModeFromSettings()
			self:ActivateCameraController(CameraUtils.ConvertCameraModeEnumToStandard(cameraMovementMode))
		else
			warn("Unhandled value for property player.CameraMode: ",Players.LocalPlayer.CameraMode)
		end
	
	elseif propertyName == "DevComputerCameraMode" or 
		   propertyName == "DevTouchCameraMode" then
		local cameraMovementMode = self:GetCameraMovementModeFromSettings()
		self:ActivateCameraController(CameraUtils.ConvertCameraModeEnumToStandard(cameraMovementMode))
		
	elseif propertyName == "DevCameraOcclusionMode" then
		self:ActivateOcclusionModule(Players.LocalPlayer.DevCameraOcclusionMode)
		
	elseif propertyName == "CameraMinZoomDistance" or propertyName == "CameraMaxZoomDistance" then
		if self.activeCameraController then
			self.activeCameraController:UpdateForDistancePropertyChange()
		end
	elseif propertyName == "DevTouchMovementMode" then
		
	elseif propertyName == "DevComputerMovementMode" then
		
	elseif propertyName == "DevEnableMouseLock" then
		-- This is the enabling/disabling of "Shift Lock" mode, not LockFirstPerson (which is a CameraMode)
		
		-- Note: Enabling and disabling of MouseLock mode is normally only a publish-time choice made via
		-- the corresponding EnableMouseLockOption checkbox of StarterPlayer, and this script does not have
		-- support for changing the availability of MouseLock at runtime (this would require listening to
		-- Player.DevEnableMouseLock changes)
	end
end

function CameraModule:OnUserGameSettingsPropertyChanged(propertyName)
	
	if propertyName == 	"ComputerCameraMovementMode" then
		local cameraMovementMode = self:GetCameraMovementModeFromSettings()
		self:ActivateCameraController(CameraUtils.ConvertCameraModeEnumToStandard(cameraMovementMode))
	end
end



--[[	
	Main RenderStep Update. The camera controller and occlusion module both have opportunities
	to set and modify (respectively) the CFrame and Focus before it is set once on CurrentCamera.
	The camera and occlusion modules should only return CFrames, not set the CFrame property of
	CurrentCamera directly.	
--]]
function CameraModule:Update(dt)
	if self.activeCameraController then
		local newCameraCFrame, newCameraFocus = self.activeCameraController:Update(dt)
		self.activeCameraController:ApplyVRTransform()
		if self.activeOcclusionModule then
			newCameraCFrame, newCameraFocus = self.activeOcclusionModule:Update(dt, newCameraCFrame, newCameraFocus)
		end
		
		-- Here is where the new CFrame and Focus are set for this render frame
		game.Workspace.CurrentCamera.CFrame = newCameraCFrame
		game.Workspace.CurrentCamera.Focus = newCameraFocus
		
		-- Update to character local transparency as needed based on camera-to-subject distance
		if self.activeTransparencyController then
			self.activeTransparencyController:Update()
		end
	end
end

-- Formerly getCurrentCameraMode, this function resolves developer and user camera control settings to
-- decide which camera control module should be instantiated. The old method of converting redundant enum types
function CameraModule:GetCameraControlChoice()
	local player = Players.LocalPlayer
	
	if player then
		if self.lastInputType == Enum.UserInputType.Touch or UserInputService.TouchEnabled then
			-- Touch			
			if player.DevTouchCameraMode == Enum.DevTouchCameraMovementMode.UserChoice then
				return CameraUtils.ConvertCameraModeEnumToStandard( UserGameSettings.TouchCameraMovementMode )
			else
				return CameraUtils.ConvertCameraModeEnumToStandard( player.DevTouchCameraMode )
			end
		else
			-- Computer
			if player.DevComputerCameraMode == Enum.DevComputerCameraMovementMode.UserChoice then
				local computerMovementMode = CameraUtils.ConvertCameraModeEnumToStandard(UserGameSettings.ComputerCameraMovementMode)
				return CameraUtils.ConvertCameraModeEnumToStandard(computerMovementMode)
			else
				return CameraUtils.ConvertCameraModeEnumToStandard(player.DevComputerCameraMode)
			end
		end
	end
end


function CameraModule:OnCharacterAdded(char, player)
	if self.activeOcclusionModule then
		self.activeOcclusionModule:CharacterAdded(char, player)
	end
end

function CameraModule:OnCharacterRemoving(char, player)
	if self.activeOcclusionModule then
		self.activeOcclusionModule:CharacterRemoving(char, player)
	end
end

function CameraModule:OnPlayerAdded(player)
	player.CharacterAdded:Connect(function(char)
		self:OnCharacterAdded(char, player)
	end)
	player.CharacterRemoving:Connect(function(char)
		self:OnCharacterRemoving(char, player)
	end)
end

function CameraModule:OnMouseLockToggled()
	if self.activeMouseLockController then
		local mouseLocked = self.activeMouseLockController:GetIsMouseLocked()
		local mouseLockOffset = self.activeMouseLockController:GetMouseLockOffset()
		if self.activeCameraController then
			self.activeCameraController:SetIsMouseLocked(mouseLocked)
			self.activeCameraController:SetMouseLockOffset(mouseLockOffset)
		end
	end
end



return CameraModule.new()
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX2F020EEE57C64A458F443194D01D4037">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">LegacyCamera</string>
							<string name="ScriptGuid">{9A5C91B5-6953-4D57-AA14-8D846351733F}</string>
							<ProtectedString name="Source"><![CDATA[--[[
	LegacyCamera - Implements legacy controller types: Attach, Fixed, Watch
	2018 Camera Update - AllYourBlox		
--]]

-- Local private variables and constants
local UNIT_X = Vector3.new(1,0,0)
local UNIT_Y = Vector3.new(0,1,0)
local UNIT_Z = Vector3.new(0,0,1)
local X1_Y0_Z1 = Vector3.new(1,0,1)	--Note: not a unit vector, used for projecting onto XZ plane
local ZERO_VECTOR3 = Vector3.new(0,0,0)
local ZERO_VECTOR2 = Vector2.new(0,0)

local VR_PITCH_FRACTION = 0.25
local tweenAcceleration = math.rad(220)		--Radians/Second^2
local tweenSpeed = math.rad(0)				--Radians/Second
local tweenMaxSpeed = math.rad(250)			--Radians/Second
local TIME_BEFORE_AUTO_ROTATE = 2.0 		--Seconds, used when auto-aligning camera with vehicles
local PORTRAIT_OFFSET = Vector3.new(0,-3,0)

local Util = require(script.Parent:WaitForChild("CameraUtils"))

--[[ Services ]]--
local PlayersService = game:GetService('Players')
local VRService = game:GetService("VRService")

--[[ The Module ]]--
local BaseCamera = require(script.Parent:WaitForChild("BaseCamera"))
local LegacyCamera = setmetatable({}, BaseCamera)
LegacyCamera.__index = LegacyCamera

function LegacyCamera.new()
	local self = setmetatable(BaseCamera.new(), LegacyCamera)
	
	self.cameraType = Enum.CameraType.Fixed
	self.lastUpdate = tick()	
	self.lastDistanceToSubject = nil
	
	return self
end

function LegacyCamera:GetModuleName()
	return "LegacyCamera"
end

function LegacyCamera:Test()
	print("LegacyCamera:Test()")
end

--[[ Functions overridden from BaseCamera ]]--
function LegacyCamera:SetCameraToSubjectDistance(desiredSubjectDistance)
	return BaseCamera.SetCameraToSubjectDistance(self,desiredSubjectDistance)
end

function LegacyCamera:Update(dt)
	
	-- Cannot update until cameraType has been set
	if not self.cameraType then return end	
	
	local now = tick()
	local timeDelta = (now - self.lastUpdate)
	local camera = 	workspace.CurrentCamera
	local newCameraCFrame = camera.CFrame
	local newCameraFocus = camera.Focus
	local player = PlayersService.LocalPlayer
	local humanoid = self:GetHumanoid()
	local cameraSubject = camera and camera.CameraSubject
	local isInVehicle = cameraSubject and cameraSubject:IsA('VehicleSeat')
	local isOnASkateboard = cameraSubject and cameraSubject:IsA('SkateboardPlatform')
	local isClimbing = humanoid and humanoid:GetState() == Enum.HumanoidStateType.Climbing
	
	if self.lastUpdate == nil or timeDelta > 1 then
		self.lastDistanceToSubject = nil
	end
	local subjectPosition = self:GetSubjectPosition()	
	
	if self.cameraType == Enum.CameraType.Fixed then
		if self.lastUpdate then
			-- Cap out the delta to 0.1 so we don't get some crazy things when we re-resume from
			local delta = math.min(0.1, now - self.lastUpdate)
			local gamepadRotation = self:UpdateGamepad()		
			self.rotateInput = self.rotateInput + (gamepadRotation * delta)
		end		
		
		if subjectPosition and player and camera then
			local distanceToSubject = self:GetCameraToSubjectDistance()
			local newLookVector = self:CalculateNewLookVector()
			self.rotateInput = ZERO_VECTOR2
			
			newCameraFocus = camera.Focus -- Fixed camera does not change focus
			newCameraCFrame = CFrame.new(camera.CFrame.p, camera.CFrame.p + (distanceToSubject * newLookVector))
		end
	elseif self.cameraType == Enum.CameraType.Attach then
		if subjectPosition and camera then
			local distanceToSubject = self:GetCameraToSubjectDistance()
			local humanoid = self:GetHumanoid()
			if self.lastUpdate and humanoid and humanoid.RootPart then
				
				-- Cap out the delta to 0.1 so we don't get some crazy things when we re-resume from
				local delta = math.min(0.1, now - self.lastUpdate)
				local gamepadRotation = self:UpdateGamepad()
				self.rotateInput = self.rotateInput + (gamepadRotation * delta)		
				
				local forwardVector = humanoid.RootPart.CFrame.lookVector

				local y = Util.GetAngleBetweenXZVectors(forwardVector, self:GetCameraLookVector())
				if Util.IsFinite(y) then
					-- Preserve vertical rotation from user input
					self.rotateInput = Vector2.new(y, self.rotateInput.Y)
				end
			end

			local newLookVector = self:CalculateNewLookVector()
			self.rotateInput = ZERO_VECTOR2

			newCameraFocus = CFrame.new(subjectPosition)
			newCameraCFrame = CFrame.new(subjectPosition - (distanceToSubject * newLookVector), subjectPosition)
		end
	elseif self.cameraType == Enum.CameraType.Watch then
		if subjectPosition and player and camera then
			local cameraLook = nil

			local humanoid = self:GetHumanoid()
			if humanoid and humanoid.RootPart then
				local diffVector = subjectPosition - camera.CFrame.p
				cameraLook = diffVector.unit

				if self.lastDistanceToSubject and self.lastDistanceToSubject == self:GetCameraToSubjectDistance() then
					-- Don't clobber the zoom if they zoomed the camera
					local newDistanceToSubject = diffVector.magnitude
					self:SetCameraToSubjectDistance(newDistanceToSubject)
				end
			end
			
			local distanceToSubject = self:GetCameraToSubjectDistance()
			local newLookVector = self:CalculateNewLookVector(cameraLook)
			self.rotateInput = ZERO_VECTOR2
			
			newCameraFocus = CFrame.new(subjectPosition)
			newCameraCFrame = CFrame.new(subjectPosition - (distanceToSubject * newLookVector), subjectPosition)

			self.lastDistanceToSubject = distanceToSubject
		end
	else
		-- Unsupported type, return current values unchanged
		return camera.CFrame, camera.Focus
	end
	
	self.lastUpdate = now
	return newCameraCFrame, newCameraFocus
end

return LegacyCamera
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXBCDACAD1F3DC41BEBB43E0D3882791B6">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Poppercam</string>
							<string name="ScriptGuid">{F64DD982-A449-4DFD-9A79-B6A6B1AA9179}</string>
							<ProtectedString name="Source"><![CDATA[--[[
	Poppercam - Occlusion module that brings the camera closer to the subject when objects are blocking the view.
--]]

local ZoomController =  require(script.Parent:WaitForChild("ZoomController"))

local TransformExtrapolator = {} do
	TransformExtrapolator.__index = TransformExtrapolator

	local CF_IDENTITY = CFrame.new()

	local function cframeToAxis(cframe)
		local axis, angle = cframe:toAxisAngle()
		return axis*angle
	end

	local function axisToCFrame(axis)
		local angle = axis.magnitude
		if angle > 1e-5 then
			return CFrame.fromAxisAngle(axis, angle)
		end
		return CF_IDENTITY
	end

	local function extractRotation(cf)
		local _, _, _, xx, yx, zx, xy, yy, zy, xz, yz, zz = cf:components()
		return CFrame.new(0, 0, 0, xx, yx, zx, xy, yy, zy, xz, yz, zz)
	end

	function TransformExtrapolator.new()
		return setmetatable({
			lastCFrame = nil,
		}, TransformExtrapolator)
	end

	function TransformExtrapolator:Step(dt, currentCFrame)
		local lastCFrame = self.lastCFrame or currentCFrame
		self.lastCFrame = currentCFrame

		local currentPos = currentCFrame.p
		local currentRot = extractRotation(currentCFrame)

		local lastPos = lastCFrame.p
		local lastRot = extractRotation(lastCFrame)

		-- Estimate velocities from the delta between now and the last frame
		-- This estimation can be a little noisy.
		local dp = (currentPos - lastPos)/dt
		local dr = cframeToAxis(currentRot*lastRot:inverse())/dt

		local function extrapolate(t)
			local p = dp*t + currentPos
			local r = axisToCFrame(dr*t)*currentRot
			return r + p
		end

		return {
			extrapolate = extrapolate,
			posVelocity = dp,
			rotVelocity = dr,
		}
	end

	function TransformExtrapolator:Reset()
		self.lastCFrame = nil
	end
end

--[[ The Module ]]--
local BaseOcclusion = require(script.Parent:WaitForChild("BaseOcclusion"))
local Poppercam = setmetatable({}, BaseOcclusion)
Poppercam.__index = Poppercam

function Poppercam.new()
	local self = setmetatable(BaseOcclusion.new(), Poppercam)
	self.focusExtrapolator = TransformExtrapolator.new()
	return self
end

function Poppercam:GetOcclusionMode()
	return Enum.DevCameraOcclusionMode.Zoom
end

function Poppercam:Enable(enable)
	self.focusExtrapolator:Reset()
end

function Poppercam:Update(renderDt, desiredCameraCFrame, desiredCameraFocus, cameraController)
	local rotatedFocus = CFrame.new(desiredCameraFocus.p, desiredCameraCFrame.p)*CFrame.new(
		0, 0, 0,
		-1, 0, 0,
		0, 1, 0,
		0, 0, -1
	)
	local extrapolation = self.focusExtrapolator:Step(renderDt, rotatedFocus)
	local zoom = ZoomController.Update(renderDt, rotatedFocus, extrapolation)
	return rotatedFocus*CFrame.new(0, 0, zoom), desiredCameraFocus
end

-- Called when character is added
function Poppercam:CharacterAdded(character, player)
end

-- Called when character is about to be removed
function Poppercam:CharacterRemoving(character, player)
end

function Poppercam:OnCameraSubjectChanged(newSubject)
end

return Poppercam]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXF4DE4782B00C43BA93037A5DE1BA3530">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">TransparencyController</string>
							<string name="ScriptGuid">{3D292612-A3FF-4670-9724-27C4B4FEE15A}</string>
							<ProtectedString name="Source"><![CDATA[--[[
	TransparencyController - Manages transparency of player character at close camera-to-subject distances
	2018 Camera Update - AllYourBlox		
--]]

local MAX_TWEEN_RATE = 2.8 -- per second

local Util = require(script.Parent:WaitForChild("CameraUtils"))

--[[ The Module ]]--
local TransparencyController = {}
TransparencyController.__index = TransparencyController

function TransparencyController.new()
	local self = setmetatable({}, TransparencyController)
	
	self.lastUpdate = tick()
	self.transparencyDirty = false
	self.enabled = false
	self.lastTransparency = nil

	self.descendantAddedConn, self.descendantRemovingConn = nil, nil
	self.toolDescendantAddedConns = {}
	self.toolDescendantRemovingConns = {}
	self.cachedParts = {}
	
	return self
end


function TransparencyController:HasToolAncestor(object)
	if object.Parent == nil then return false end
	return object.Parent:IsA('Tool') or self:HasToolAncestor(object.Parent)
end

function TransparencyController:IsValidPartToModify(part)
	if part:IsA('BasePart') or part:IsA('Decal') then
		return not self:HasToolAncestor(part)
	end
	return false
end

function TransparencyController:CachePartsRecursive(object)
	if object then
		if self:IsValidPartToModify(object) then
			self.cachedParts[object] = true
			self.transparencyDirty = true
		end
		for _, child in pairs(object:GetChildren()) do
			self:CachePartsRecursive(child)
		end
	end
end

function TransparencyController:TeardownTransparency()
	for child, _ in pairs(self.cachedParts) do
		child.LocalTransparencyModifier = 0
	end
	self.cachedParts = {}
	self.transparencyDirty = true
	self.lastTransparency = nil

	if self.descendantAddedConn then
		self.descendantAddedConn:disconnect()
		self.descendantAddedConn = nil
	end
	if self.descendantRemovingConn then
		self.descendantRemovingConn:disconnect()
		self.descendantRemovingConn = nil
	end
	for object, conn in pairs(self.toolDescendantAddedConns) do
		conn:Disconnect()
		self.toolDescendantAddedConns[object] = nil
	end
	for object, conn in pairs(self.toolDescendantRemovingConns) do
		conn:Disconnect()
		self.toolDescendantRemovingConns[object] = nil
	end
end

function TransparencyController:SetupTransparency(character)
	self:TeardownTransparency()

	if self.descendantAddedConn then self.descendantAddedConn:disconnect() end
	self.descendantAddedConn = character.DescendantAdded:Connect(function(object)
		-- This is a part we want to invisify
		if self:IsValidPartToModify(object) then
			self.cachedParts[object] = true
			self.transparencyDirty = true
		-- There is now a tool under the character
		elseif object:IsA('Tool') then
			if self.toolDescendantAddedConns[object] then self.toolDescendantAddedConns[object]:Disconnect() end
			self.toolDescendantAddedConns[object] = object.DescendantAdded:Connect(function(toolChild)
				self.cachedParts[toolChild] = nil
				if toolChild:IsA('BasePart') or toolChild:IsA('Decal') then
					-- Reset the transparency
					toolChild.LocalTransparencyModifier = 0
				end
			end)
			if self.toolDescendantRemovingConns[object] then self.toolDescendantRemovingConns[object]:disconnect() end
			self.toolDescendantRemovingConns[object] = object.DescendantRemoving:Connect(function(formerToolChild)
				wait() -- wait for new parent
				if character and formerToolChild and formerToolChild:IsDescendantOf(character) then
					if self:IsValidPartToModify(formerToolChild) then
						self.cachedParts[formerToolChild] = true
						self.transparencyDirty = true
					end
				end
			end)
		end
	end)
	if self.descendantRemovingConn then self.descendantRemovingConn:disconnect() end
	self.descendantRemovingConn = character.DescendantRemoving:connect(function(object)
		if self.cachedParts[object] then
			self.cachedParts[object] = nil
			-- Reset the transparency
			object.LocalTransparencyModifier = 0
		end
	end)
	self:CachePartsRecursive(character)
end


function TransparencyController:Enable(enable)
	if self.enabled ~= enable then
		self.enabled = enable
		self:Update()
	end
end

function TransparencyController:SetSubject(subject)
	local character = nil
	if subject and subject:IsA("Humanoid") then
		character = subject.Parent
	end
	if subject and subject:IsA("VehicleSeat") and subject.Occupant then
		character = subject.Occupant.Parent
	end
	if character then
		self:SetupTransparency(character)
	else
		self:TeardownTransparency()
	end
end

function TransparencyController:Update()
	local instant = false
	local now = tick()
	local currentCamera = workspace.CurrentCamera

	if currentCamera then
		local transparency = 0
		if not self.enabled then
			instant = true
		else
			local distance = (currentCamera.Focus.p - currentCamera.CoordinateFrame.p).magnitude
			transparency = (distance<2) and (1.0-(distance-0.5)/1.5) or 0 --(7 - distance) / 5
			if transparency < 0.5 then
				transparency = 0
			end

			if self.lastTransparency then
				local deltaTransparency = transparency - self.lastTransparency
				
				-- Don't tween transparency if it is instant or your character was fully invisible last frame
				if not instant and transparency < 1 and self.lastTransparency < 0.95 then
					local maxDelta = MAX_TWEEN_RATE * (now - self.lastUpdate)
					deltaTransparency = Util.Clamp(-maxDelta, maxDelta, deltaTransparency)
				end
				transparency = self.lastTransparency + deltaTransparency
			else
				self.transparencyDirty = true
			end

			transparency = Util.Clamp(0, 1, Util.Round(transparency, 2))
		end

		if self.transparencyDirty or self.lastTransparency ~= transparency then
			for child, _ in pairs(self.cachedParts) do
				child.LocalTransparencyModifier = transparency
			end
			self.transparencyDirty = false
			self.lastTransparency = transparency
		end
	end
	self.lastUpdate = now
end

return TransparencyController
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX60BCC430F75949E6AAC7C1F5399332B0">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">OrbitalCamera</string>
							<string name="ScriptGuid">{82A660BA-23D0-4DFC-89BC-FB0D0016ECB6}</string>
							<ProtectedString name="Source"><![CDATA[--[[
	OrbitalCamera - Spherical coordinates control camera for top-down games
	2018 Camera Update - AllYourBlox		
--]]

-- Local private variables and constants
local UNIT_X = Vector3.new(1,0,0)
local UNIT_Y = Vector3.new(0,1,0)
local UNIT_Z = Vector3.new(0,0,1)
local X1_Y0_Z1 = Vector3.new(1,0,1)	--Note: not a unit vector, used for projecting onto XZ plane
local ZERO_VECTOR3 = Vector3.new(0,0,0)
local ZERO_VECTOR2 = Vector2.new(0,0)
local TAU = 2 * math.pi

local VR_PITCH_FRACTION = 0.25
local tweenAcceleration = math.rad(220)		--Radians/Second^2
local tweenSpeed = math.rad(0)				--Radians/Second
local tweenMaxSpeed = math.rad(250)			--Radians/Second
local TIME_BEFORE_AUTO_ROTATE = 2.0 		--Seconds, used when auto-aligning camera with vehicles
local PORTRAIT_OFFSET = Vector3.new(0,-3,0)

local bindAtPriorityFlagExists, bindAtPriorityFlagEnabled = pcall(function()
	return UserSettings():IsUserFeatureEnabled("UserPlayerScriptsBindAtPriority")
end)
local FFlagPlayerScriptsBindAtPriority = bindAtPriorityFlagExists and bindAtPriorityFlagEnabled

--[[ Gamepad Support ]]--
local THUMBSTICK_DEADZONE = 0.2

-- Do not edit these values, they are not the developer-set limits, they are limits
-- to the values the camera system equations can correctly handle
local MIN_ALLOWED_ELEVATION_DEG = -80
local MAX_ALLOWED_ELEVATION_DEG = 80

local externalProperties = {}
externalProperties["InitialDistance"] 	= 25
externalProperties["MinDistance"] 		= 10
externalProperties["MaxDistance"] 		= 100
externalProperties["InitialElevation"] 	= 35
externalProperties["MinElevation"] 		= 35
externalProperties["MaxElevation"] 		= 35
externalProperties["ReferenceAzimuth"] 	= -45	-- Angle around the Y axis where the camera starts. -45 offsets the camera in the -X and +Z directions equally
externalProperties["CWAzimuthTravel"] 	= 90	-- How many degrees the camera is allowed to rotate from the reference position, CW as seen from above
externalProperties["CCWAzimuthTravel"] 	= 90	-- How many degrees the camera is allowed to rotate from the reference position, CCW as seen from above
externalProperties["UseAzimuthLimits"] 	= false -- Full rotation around Y axis available by default

local Util = require(script.Parent:WaitForChild("CameraUtils"))

--[[ Services ]]--
local PlayersService = game:GetService('Players')
local VRService = game:GetService("VRService")

--[[ Utility functions specific to OrbitalCamera ]]--
local function GetValueObject(name, defaultValue)
	local valueObj = script:FindFirstChild(name)
	if valueObj then
		return valueObj.Value
	end
	return defaultValue
end

--[[ The Module ]]--
local BaseCamera = require(script.Parent:WaitForChild("BaseCamera"))
local OrbitalCamera = setmetatable({}, BaseCamera)
OrbitalCamera.__index = OrbitalCamera


function OrbitalCamera.new()
	local self = setmetatable(BaseCamera.new(), OrbitalCamera)
	
	self.lastUpdate = tick()
	
	-- OrbitalCamera-specific members
	self.changedSignalConnections = {}
	self.refAzimuthRad = nil
	self.curAzimuthRad = nil
	self.minAzimuthAbsoluteRad = nil
	self.maxAzimuthAbsoluteRad = nil
	self.useAzimuthLimits = nil
	self.curElevationRad = nil
	self.minElevationRad = nil
	self.maxElevationRad = nil
	self.curDistance = nil
	self.minDistance = nil
	self.maxDistance = nil
	
	-- Gamepad	
	self.r3ButtonDown = false
	self.l3ButtonDown = false
	self.gamepadDollySpeedMultiplier = 1
	
	self.lastUserPanCamera = tick()
		
	self.externalProperties = {}
	self.externalProperties["InitialDistance"] 	= 25
	self.externalProperties["MinDistance"] 		= 10
	self.externalProperties["MaxDistance"] 		= 100
	self.externalProperties["InitialElevation"] 	= 35
	self.externalProperties["MinElevation"] 		= 35
	self.externalProperties["MaxElevation"] 		= 35
	self.externalProperties["ReferenceAzimuth"] 	= -45	-- Angle around the Y axis where the camera starts. -45 offsets the camera in the -X and +Z directions equally
	self.externalProperties["CWAzimuthTravel"] 	= 90	-- How many degrees the camera is allowed to rotate from the reference position, CW as seen from above
	self.externalProperties["CCWAzimuthTravel"] 	= 90	-- How many degrees the camera is allowed to rotate from the reference position, CCW as seen from above
	self.externalProperties["UseAzimuthLimits"] 	= false -- Full rotation around Y axis available by default
	self:LoadNumberValueParameters()
	
	return self
end

function OrbitalCamera:LoadOrCreateNumberValueParameter(name, valueType, updateFunction)
	local valueObj = script:FindFirstChild(name)
	
	if valueObj and valueObj:isA(valueType) then
		-- Value object exists and is the correct type, use its value
		self.externalProperties[name] = valueObj.Value
	elseif self.externalProperties[name] ~= nil then
		-- Create missing (or replace incorrectly-typed) valueObject with default value
		valueObj = Instance.new(valueType)
		valueObj.Name = name
		valueObj.Parent = script
		valueObj.Value = self.externalProperties[name]
	else
		print("externalProperties table has no entry for ",name)
		return
	end
	
	if updateFunction then
		if self.changedSignalConnections[name] then
			self.changedSignalConnections[name]:Disconnect()
		end
		self.changedSignalConnections[name] = valueObj.Changed:Connect(function(newValue)
			self.externalProperties[name] = newValue
			updateFunction(self)
		end)
	end
end

function OrbitalCamera:SetAndBoundsCheckAzimuthValues()
	self.minAzimuthAbsoluteRad = math.rad(self.externalProperties["ReferenceAzimuth"]) - math.abs(math.rad(self.externalProperties["CWAzimuthTravel"]))
	self.maxAzimuthAbsoluteRad = math.rad(self.externalProperties["ReferenceAzimuth"]) + math.abs(math.rad(self.externalProperties["CCWAzimuthTravel"]))
	self.useAzimuthLimits = self.externalProperties["UseAzimuthLimits"]
	if self.useAzimuthLimits then
		self.curAzimuthRad = math.max(self.curAzimuthRad, self.minAzimuthAbsoluteRad)
		self.curAzimuthRad = math.min(self.curAzimuthRad, self.maxAzimuthAbsoluteRad)
	end
end

function OrbitalCamera:SetAndBoundsCheckElevationValues()
	-- These degree values are the direct user input values. It is deliberate that they are
	-- ranged checked only against the extremes, and not against each other. Any time one
	-- is changed, both of the internal values in radians are recalculated. This allows for
	-- A developer to change the values in any order and for the end results to be that the
	-- internal values adjust to match intent as best as possible.
	local minElevationDeg = math.max(self.externalProperties["MinElevation"], MIN_ALLOWED_ELEVATION_DEG)
	local maxElevationDeg = math.min(self.externalProperties["MaxElevation"], MAX_ALLOWED_ELEVATION_DEG)
	
	-- Set internal values in radians
	self.minElevationRad = math.rad(math.min(minElevationDeg, maxElevationDeg))
	self.maxElevationRad = math.rad(math.max(minElevationDeg, maxElevationDeg))
	self.curElevationRad = math.max(self.curElevationRad, self.minElevationRad)
	self.curElevationRad = math.min(self.curElevationRad, self.maxElevationRad)
end

function OrbitalCamera:SetAndBoundsCheckDistanceValues()
	self.minDistance = self.externalProperties["MinDistance"]
	self.maxDistance = self.externalProperties["MaxDistance"]
	self.curDistance = math.max(self.curDistance, self.minDistance)
	self.curDistance = math.min(self.curDistance, self.maxDistance)
end

-- This loads from, or lazily creates, NumberValue objects for exposed parameters
function OrbitalCamera:LoadNumberValueParameters()
	-- These initial values do not require change listeners since they are read only once
	self:LoadOrCreateNumberValueParameter("InitialElevation", "NumberValue", nil)
	self:LoadOrCreateNumberValueParameter("InitialDistance", "NumberValue", nil)
	
	-- Note: ReferenceAzimuth is also used as an initial value, but needs a change listener because it is used in the calculation of the limits
	self:LoadOrCreateNumberValueParameter("ReferenceAzimuth", "NumberValue", self.SetAndBoundsCheckAzimuthValue)
	self:LoadOrCreateNumberValueParameter("CWAzimuthTravel", "NumberValue", self.SetAndBoundsCheckAzimuthValues)
	self:LoadOrCreateNumberValueParameter("CCWAzimuthTravel", "NumberValue", self.SetAndBoundsCheckAzimuthValues)
	self:LoadOrCreateNumberValueParameter("MinElevation", "NumberValue", self.SetAndBoundsCheckElevationValues)
	self:LoadOrCreateNumberValueParameter("MaxElevation", "NumberValue", self.SetAndBoundsCheckElevationValues)
	self:LoadOrCreateNumberValueParameter("MinDistance", "NumberValue", self.SetAndBoundsCheckDistanceValues)
	self:LoadOrCreateNumberValueParameter("MaxDistance", "NumberValue", self.SetAndBoundsCheckDistanceValues)
	self:LoadOrCreateNumberValueParameter("UseAzimuthLimits", "BoolValue", self.SetAndBoundsCheckAzimuthValues)
	
	-- Internal values set (in radians, from degrees), plus sanitization
	self.curAzimuthRad = math.rad(self.externalProperties["ReferenceAzimuth"])
	self.curElevationRad = math.rad(self.externalProperties["InitialElevation"])
	self.curDistance = self.externalProperties["InitialDistance"]
	
	self:SetAndBoundsCheckAzimuthValues()
	self:SetAndBoundsCheckElevationValues()
	self:SetAndBoundsCheckDistanceValues()
end

function OrbitalCamera:GetModuleName()
	return "OrbitalCamera"
end

function OrbitalCamera:SetInitialOrientation(humanoid)
	if not humanoid or not humanoid.RootPart then
		warn("OrbitalCamera could not set initial orientation due to missing humanoid")
		return
	end
	local newDesiredLook = (humanoid.RootPart.CFrame.lookVector - Vector3.new(0,0.23,0)).unit
	local horizontalShift = Util.GetAngleBetweenXZVectors(newDesiredLook, self:GetCameraLookVector())
	local vertShift = math.asin(self:GetCameraLookVector().y) - math.asin(newDesiredLook.y)
	if not Util.IsFinite(horizontalShift) then
		horizontalShift = 0
	end
	if not Util.IsFinite(vertShift) then
		vertShift = 0
	end
	self.rotateInput = Vector2.new(horizontalShift, vertShift)
end

--[[ Functions of BaseCamera that are overridden by OrbitalCamera ]]--
function OrbitalCamera:GetCameraToSubjectDistance()
	return self.curDistance
end
	
function OrbitalCamera:SetCameraToSubjectDistance(desiredSubjectDistance)
	print("OrbitalCamera SetCameraToSubjectDistance ",desiredSubjectDistance)
	local player = PlayersService.LocalPlayer
	if player then
		self.currentSubjectDistance = Util.Clamp(self.minDistance, self.maxDistance, desiredSubjectDistance)
		
		-- OrbitalCamera is not allowed to go into the first-person range
		self.currentSubjectDistance = math.max(self.currentSubjectDistance, self.FIRST_PERSON_DISTANCE_THRESHOLD)
	end
	self.inFirstPerson = false
	self:UpdateMouseBehavior()
	return self.currentSubjectDistance
end

function OrbitalCamera:CalculateNewLookVector(suppliedLookVector, xyRotateVector)
	local currLookVector = suppliedLookVector or self:GetCameraLookVector()
	local currPitchAngle = math.asin(currLookVector.y)
	local yTheta = Util.Clamp(currPitchAngle - math.rad(MAX_ALLOWED_ELEVATION_DEG), currPitchAngle - math.rad(MIN_ALLOWED_ELEVATION_DEG), xyRotateVector.y)
	local constrainedRotateInput = Vector2.new(xyRotateVector.x, yTheta)	
	local startCFrame = CFrame.new(ZERO_VECTOR3, currLookVector)
	local newLookVector = (CFrame.Angles(0, -constrainedRotateInput.x, 0) * startCFrame * CFrame.Angles(-constrainedRotateInput.y,0,0)).lookVector	
	return newLookVector
end

function OrbitalCamera:GetGamepadPan(name, state, input)
	if input.UserInputType == self.activeGamepad and input.KeyCode == Enum.KeyCode.Thumbstick2 then
		if self.r3ButtonDown or self.l3ButtonDown then
		-- R3 or L3 Thumbstick is depressed, right stick controls dolly in/out
			if (input.Position.Y > THUMBSTICK_DEADZONE) then
				self.gamepadDollySpeedMultiplier = 0.96
			elseif (input.Position.Y < -THUMBSTICK_DEADZONE) then
				self.gamepadDollySpeedMultiplier = 1.04
			else 
				self.gamepadDollySpeedMultiplier = 1.00
			end
		else
			if state == Enum.UserInputState.Cancel then
				self.gamepadPanningCamera = ZERO_VECTOR2
				return
			end		
			
			local inputVector = Vector2.new(input.Position.X, -input.Position.Y)
			if inputVector.magnitude > THUMBSTICK_DEADZONE then
				self.gamepadPanningCamera = Vector2.new(input.Position.X, -input.Position.Y)
			else
				self.gamepadPanningCamera = ZERO_VECTOR2
			end
		end
		if FFlagPlayerScriptsBindAtPriority then
			return Enum.ContextActionResult.Sink
		end
	end
	if FFlagPlayerScriptsBindAtPriority then
		return Enum.ContextActionResult.Pass
	end
end

function OrbitalCamera:DoGamepadZoom(name, state, input)
	if input.UserInputType == self.activeGamepad and (input.KeyCode == Enum.KeyCode.ButtonR3 or input.KeyCode == Enum.KeyCode.ButtonL3) then
		if (state == Enum.UserInputState.Begin) then
			self.r3ButtonDown = input.KeyCode == Enum.KeyCode.ButtonR3
			self.l3ButtonDown = input.KeyCode == Enum.KeyCode.ButtonL3
		elseif (state == Enum.UserInputState.End) then
			if (input.KeyCode == Enum.KeyCode.ButtonR3) then
				self.r3ButtonDown = false
			elseif (input.KeyCode == Enum.KeyCode.ButtonL3) then
				self.l3ButtonDown = false
			end
			if (not self.r3ButtonDown) and (not self.l3ButtonDown) then
				self.gamepadDollySpeedMultiplier = 1.00
			end
		end
		if FFlagPlayerScriptsBindAtPriority then
			return Enum.ContextActionResult.Sink
		end
	end
	if FFlagPlayerScriptsBindAtPriority then
		return Enum.ContextActionResult.Pass
	end
end

function OrbitalCamera:BindGamepadInputActions()
	if FFlagPlayerScriptsBindAtPriority then
		self:BindAction("OrbitalCamGamepadPan", function(name, state, input) self:GetGamepadPan(name, state, input) end,
			false, Enum.KeyCode.Thumbstick2)
		self:BindAction("OrbitalCamGamepadZoom", function(name, state, input) self:DoGamepadZoom(name, state, input) end,
			false, Enum.KeyCode.ButtonR3, Enum.KeyCode.ButtonL3)
	else
		local ContextActionService = game:GetService('ContextActionService')
		
		ContextActionService:BindAction("OrbitalCamGamepadPan", function(name, state, input) self:GetGamepadPan(name, state, input) end, false, Enum.KeyCode.Thumbstick2)	
		ContextActionService:BindAction("OrbitalCamGamepadZoom", function(name, state, input) self:DoGamepadZoom(name, state, input) end, false, Enum.KeyCode.ButtonR3)
		ContextActionService:BindAction("OrbitalCamGamepadZoomAlt", function(name, state, input) self:DoGamepadZoom(name, state, input) end, false, Enum.KeyCode.ButtonL3)
	end
end


-- [[ Update ]]--
function OrbitalCamera:Update(dt)
	local now = tick()
	local timeDelta = (now - self.lastUpdate)
	local userPanningTheCamera = (self.UserPanningTheCamera == true)
	local camera = 	workspace.CurrentCamera
	local newCameraCFrame = camera.CFrame
	local newCameraFocus = camera.Focus
	local player = PlayersService.LocalPlayer
	local humanoid = self:GetHumanoid()
	local cameraSubject = camera and camera.CameraSubject
	local isInVehicle = cameraSubject and cameraSubject:IsA('VehicleSeat')
	local isOnASkateboard = cameraSubject and cameraSubject:IsA('SkateboardPlatform')
	
	if self.lastUpdate == nil or timeDelta > 1 then
		self.lastCameraTransform = nil
	end	
	
	if self.lastUpdate then
		local gamepadRotation = self:UpdateGamepad()
		
		if self:ShouldUseVRRotation() then				
			self.RotateInput = self.RotateInput + self:GetVRRotationInput()
		else
			-- Cap out the delta to 0.1 so we don't get some crazy things when we re-resume from
			local delta = math.min(0.1, timeDelta)
			
			if gamepadRotation ~= ZERO_VECTOR2 then
				userPanningTheCamera = true
				self.rotateInput = self.rotateInput + (gamepadRotation * delta)
			end

			local angle = 0
			if not (isInVehicle or isOnASkateboard) then
				angle = angle + (self.TurningLeft and -120 or 0)
				angle = angle + (self.TurningRight and 120 or 0)
			end
			
			if angle ~= 0 then
				self.rotateInput = self.rotateInput +  Vector2.new(math.rad(angle * delta), 0)
				userPanningTheCamera = true
			end
		end
	end

	-- Reset tween speed if user is panning
	if userPanningTheCamera then
		tweenSpeed = 0
		self.lastUserPanCamera = tick()
	end
	
	local userRecentlyPannedCamera = now - self.lastUserPanCamera < TIME_BEFORE_AUTO_ROTATE
	local subjectPosition = self:GetSubjectPosition()
	
	if subjectPosition and player and camera then
	
		-- Process any dollying being done by gamepad
		-- TODO: Move this
		if self.gamepadDollySpeedMultiplier ~= 1 then
			self:SetCameraToSubjectDistance(self.currentSubjectDistance * self.gamepadDollySpeedMultiplier)
		end
		
		local VREnabled = VRService.VREnabled
		newCameraFocus = VREnabled and self:GetVRFocus(subjectPosition, timeDelta) or CFrame.new(subjectPosition)

		local cameraFocusP = newCameraFocus.p
		if VREnabled and not self:IsInFirstPerson() then
			local cameraHeight = self:GetCameraHeight()
			local vecToSubject = (subjectPosition - camera.CFrame.p)
			local distToSubject = vecToSubject.magnitude

			-- Only move the camera if it exceeded a maximum distance to the subject in VR
			if distToSubject > self.currentSubjectDistance or self.rotateInput.x ~= 0 then
				local desiredDist = math.min(distToSubject, self.currentSubjectDistance)
				
				-- Note that CalculateNewLookVector is overridden from BaseCamera
				vecToSubject = self:CalculateNewLookVector(vecToSubject.unit * X1_Y0_Z1, Vector2.new(self.rotateInput.x, 0)) * desiredDist
				
				local newPos = cameraFocusP - vecToSubject
				local desiredLookDir = camera.CFrame.lookVector
				if self.rotateInput.x ~= 0 then
					desiredLookDir = vecToSubject
				end
				local lookAt = Vector3.new(newPos.x + desiredLookDir.x, newPos.y, newPos.z + desiredLookDir.z)
				self.RotateInput = ZERO_VECTOR2
				
				newCameraCFrame = CFrame.new(newPos, lookAt) + Vector3.new(0, cameraHeight, 0)
			end
		else
			-- self.RotateInput is a Vector2 of mouse movement deltas since last update
			self.curAzimuthRad = self.curAzimuthRad - self.rotateInput.x
			
			if self.useAzimuthLimits then
				self.curAzimuthRad = Util.Clamp(self.minAzimuthAbsoluteRad, self.maxAzimuthAbsoluteRad, self.curAzimuthRad)
			else
				self.curAzimuthRad = (self.curAzimuthRad ~= 0) and (math.sign(self.curAzimuthRad) * (math.abs(self.curAzimuthRad) % TAU)) or 0
			end

			self.curElevationRad = Util.Clamp(self.minElevationRad, self.maxElevationRad, self.curElevationRad + self.rotateInput.y)
			
			local cameraPosVector = self.currentSubjectDistance * ( CFrame.fromEulerAnglesYXZ( -self.curElevationRad, self.curAzimuthRad, 0 ) * UNIT_Z ) 
			local camPos = subjectPosition + cameraPosVector
			
			newCameraCFrame = CFrame.new(camPos, subjectPosition)
		
			self.rotateInput = ZERO_VECTOR2
		end

		self.lastCameraTransform = newCameraCFrame
		self.lastCameraFocus = newCameraFocus
		if (isInVehicle or isOnASkateboard) and cameraSubject:IsA('BasePart') then
			self.lastSubjectCFrame = cameraSubject.CFrame
		else
			self.lastSubjectCFrame = nil
		end
	end
	
	self.lastUpdate = now
	return newCameraCFrame, newCameraFocus
end

return OrbitalCamera
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXEF18E4E0F00D4F0DAEBB856CF2E227AF">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">MouseLockController</string>
							<string name="ScriptGuid">{35263B15-8483-4725-8300-DCD0BA3F7791}</string>
							<ProtectedString name="Source"><![CDATA[--[[
	MouseLockController - Replacement for ShiftLockController, manages use of mouse-locked mode
	2018 Camera Update - AllYourBlox		
--]]

--[[ Constants ]]--
local DEFAULT_MOUSE_LOCK_CURSOR = "rbxasset://textures/MouseLockedCursor.png"

local CONTEXT_ACTION_NAME = "MouseLockSwitchAction"
local MOUSELOCK_ACTION_PRIORITY = Enum.ContextActionPriority.Default.Value

local Util = require(script.Parent:WaitForChild("CameraUtils"))

--[[ Services ]]--
local PlayersService = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local ContextActionService = game:GetService("ContextActionService")
local Settings = UserSettings()	-- ignore warning
local GameSettings = Settings.GameSettings
local Mouse = PlayersService.LocalPlayer:GetMouse()

--[[ Variables ]]
local bindAtPriorityFlagExists, bindAtPriorityFlagEnabled = pcall(function()
	return UserSettings():IsUserFeatureEnabled("UserPlayerScriptsBindAtPriority")
end)
local FFlagPlayerScriptsBindAtPriority = bindAtPriorityFlagExists and bindAtPriorityFlagEnabled

--[[ The Module ]]--
local MouseLockController = {}
MouseLockController.__index = MouseLockController

function MouseLockController.new()
	local self = setmetatable({}, MouseLockController)
	
	self.inputBeganConn = nil -- Remove with FFlagPlayerScriptsBindAtPriority
	self.isMouseLocked = false
	self.savedMouseCursor = nil
	self.boundKeys = {Enum.KeyCode.LeftShift, Enum.KeyCode.RightShift} -- defaults
	
	self.mouseLockToggledEvent = Instance.new("BindableEvent")
	
	local boundKeysObj = script:FindFirstChild("BoundKeys")
	if (not boundKeysObj) or (not boundKeysObj:IsA("StringValue")) then
		-- If object with correct name was found, but it's not a StringValue, destroy and replace
		if boundKeysObj then
			boundKeysObj:Destroy()
		end
		
		boundKeysObj = Instance.new("StringValue")
		boundKeysObj.Name = "BoundKeys"
		boundKeysObj.Value = "LeftShift,RightShift"
		boundKeysObj.Parent = script
	end
	
	if boundKeysObj then
		boundKeysObj.Changed:Connect(function(value)
			self:OnBoundKeysObjectChanged(value)
		end)
		self:OnBoundKeysObjectChanged(boundKeysObj.Value) -- Initial setup call
	end
	
	-- Watch for changes to user's ControlMode and ComputerMovementMode settings and update the feature availability accordingly
	GameSettings.Changed:Connect(function(property)
		if property == "ControlMode" or property == "ComputerMovementMode" then
			self:UpdateMouseLockAvailability()
		end
	end)
	
	-- Watch for changes to DevEnableMouseLock and update the feature availability accordingly
	PlayersService.LocalPlayer:GetPropertyChangedSignal("DevEnableMouseLock"):Connect(function()
		self:UpdateMouseLockAvailability()
	end)
	
	-- Watch for changes to DevEnableMouseLock and update the feature availability accordingly
	PlayersService.LocalPlayer:GetPropertyChangedSignal("DevComputerMovementMode"):Connect(function()
		self:UpdateMouseLockAvailability()
	end)
	
	self:UpdateMouseLockAvailability()
	
	return self
end

function MouseLockController:GetIsMouseLocked()
	return self.isMouseLocked
end

function MouseLockController:GetBindableToggleEvent()
	return self.mouseLockToggledEvent.Event
end

function MouseLockController:GetMouseLockOffset()
	local offsetValueObj = script:FindFirstChild("CameraOffset")
	if offsetValueObj and offsetValueObj:IsA("Vector3Value") then
		return offsetValueObj.Value
	else
		-- If CameraOffset object was found but not correct type, destroy
		if offsetValueObj then
			offsetValueObj:Destroy()
		end
		offsetValueObj = Instance.new("Vector3Value")
		offsetValueObj.Name = "CameraOffset"
		offsetValueObj.Value = Vector3.new(1.75,0,0) -- Legacy Default Value
		offsetValueObj.Parent = script
	end
	
	if offsetValueObj and offsetValueObj.Value then
		return offsetValueObj.Value
	end
	
	return Vector3.new(1.75,0,0)
end

function MouseLockController:UpdateMouseLockAvailability()
	local devAllowsMouseLock = PlayersService.LocalPlayer.DevEnableMouseLock
	local devMovementModeIsScriptable = PlayersService.LocalPlayer.DevComputerMovementMode == Enum.DevComputerMovementMode.Scriptable
	local userHasMouseLockModeEnabled = GameSettings.ControlMode == Enum.ControlMode.MouseLockSwitch
	local userHasClickToMoveEnabled =  GameSettings.ComputerMovementMode == Enum.ComputerMovementMode.ClickToMove
	local MouseLockAvailable = devAllowsMouseLock and userHasMouseLockModeEnabled and not userHasClickToMoveEnabled and not devMovementModeIsScriptable
	
	if MouseLockAvailable~=self.enabled then
		self:EnableMouseLock(MouseLockAvailable)
	end
end

function MouseLockController:OnBoundKeysObjectChanged(newValue)
	self.boundKeys = {} -- Overriding defaults, note: possibly with nothing at all if boundKeysObj.Value is "" or contains invalid values
	for token in string.gmatch(newValue,"[^%s,]+") do
		for keyCode, keyEnum in pairs(Enum.KeyCode:GetEnumItems()) do
			if token == keyEnum.Name then
				self.boundKeys[#self.boundKeys+1] = keyEnum
				break
			end
		end
	end
	if FFlagPlayerScriptsBindAtPriority then 
		self:UnbindContextActions()
		self:BindContextActions()
	end
end

--[[ Local Functions ]]--
function MouseLockController:OnMouseLockToggled()
	self.isMouseLocked = not self.isMouseLocked
	
	if self.isMouseLocked then
		local cursorImageValueObj = script:FindFirstChild("CursorImage")
		if cursorImageValueObj and cursorImageValueObj:IsA("StringValue") and cursorImageValueObj.Value then
			self.savedMouseCursor = Mouse.Icon
			Mouse.Icon = cursorImageValueObj.Value
		else
			if cursorImageValueObj then
				cursorImageValueObj:Destroy()
			end
			cursorImageValueObj = Instance.new("StringValue")
			cursorImageValueObj.Name = "CursorImage"
			cursorImageValueObj.Value = DEFAULT_MOUSE_LOCK_CURSOR
			cursorImageValueObj.Parent = script
			self.savedMouseCursor = Mouse.Icon
			Mouse.Icon = DEFAULT_MOUSE_LOCK_CURSOR
		end
	else
		if self.savedMouseCursor then
			Mouse.Icon = self.savedMouseCursor
			self.savedMouseCursor = nil
		end
	end
	
	self.mouseLockToggledEvent:Fire()
end

-- Remove with FFlagPlayerScriptsBindAtPriority
function MouseLockController:OnInputBegan(input, processed)
	if processed then return end
	
	if input.UserInputType == Enum.UserInputType.Keyboard then
		for _, keyCode in pairs(self.boundKeys) do
			if keyCode == input.KeyCode then
				self:OnMouseLockToggled()
				return
			end
		end
	end
end

function MouseLockController:DoMouseLockSwitch(name, state, input)
	if state == Enum.UserInputState.Begin then 
		self:OnMouseLockToggled()
		return Enum.ContextActionResult.Sink
	end
	return Enum.ContextActionResult.Pass
end

function MouseLockController:BindContextActions()
	ContextActionService:BindActionAtPriority(CONTEXT_ACTION_NAME, function(name, state, input) self:DoMouseLockSwitch(name, state, input) end, 
		false, MOUSELOCK_ACTION_PRIORITY, unpack(self.boundKeys))
end

function MouseLockController:UnbindContextActions()
		ContextActionService:UnbindAction(CONTEXT_ACTION_NAME)
end

function MouseLockController:IsMouseLocked()
	return self.enabled and self.isMouseLocked
end

function MouseLockController:EnableMouseLock(enable)
	if enable~=self.enabled then
		
		self.enabled = enable

		if self.enabled then
			-- Enabling the mode
			if FFlagPlayerScriptsBindAtPriority then
				self:BindContextActions()
			else
				if self.inputBeganConn then
					self.inputBeganConn:Disconnect()
				end
				self.inputBeganConn = UserInputService.InputBegan:Connect(function(input, processed)
					self:OnInputBegan(input, processed)
				end)
			end
		else
			-- Disabling
			-- Restore mouse cursor
			if Mouse.Icon~="" then
				Mouse.Icon = ""
			end
			
			if FFlagPlayerScriptsBindAtPriority then
				self:UnbindContextActions()
			else
				if self.inputBeganConn then
					self.inputBeganConn:Disconnect()
				end
				self.inputBeganConn = nil
			end

			-- If the mode is disabled while being used, fire the event to toggle it off
			if self.isMouseLocked then
				self.mouseLockToggledEvent:Fire()
			end			
			
			self.isMouseLocked = false
		end		
		
	end
end

return MouseLockController
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="StringValue" referent="RBX97BD0BCB7E334239952F59623FD4CB31">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<string name="Name">BoundKeys</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<string name="Value">LeftShift,RightShift</string>
							</Properties>
						</Item>
					</Item>
					<Item class="ModuleScript" referent="RBX6C09CE82BB254A29B81CC3B13D24E699">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Invisicam</string>
							<string name="ScriptGuid">{BCD6A4F7-2B76-4D91-922D-C7EB53F3A278}</string>
							<ProtectedString name="Source"><![CDATA[--[[
	Invisicam - Occlusion module that makes objects occluding character view semi-transparent
	2018 Camera Update - AllYourBlox		
--]]

--[[ Camera Maths Utilities Library ]]--
local Util = require(script.Parent:WaitForChild("CameraUtils"))

--[[ Top Level Roblox Services ]]--
local PlayersService = game:GetService("Players")
local RunService = game:GetService("RunService")

--[[ Constants ]]--
local ZERO_VECTOR3 = Vector3.new(0,0,0)
local USE_STACKING_TRANSPARENCY = true	-- Multiple items between the subject and camera get transparency values that add up to TARGET_TRANSPARENCY
local TARGET_TRANSPARENCY = 0.75 -- Classic Invisicam's Value, also used by new invisicam for parts hit by head and torso rays
local TARGET_TRANSPARENCY_PERIPHERAL = 0.5 -- Used by new SMART_CIRCLE mode for items not hit by head and torso rays

local MODE = {
	--CUSTOM = 1, 		-- Retired, unused
	LIMBS = 2, 			-- Track limbs
	MOVEMENT = 3, 		-- Track movement
	CORNERS = 4, 		-- Char model corners
	CIRCLE1 = 5, 		-- Circle of casts around character
	CIRCLE2 = 6, 		-- Circle of casts around character, camera relative
	LIMBMOVE = 7, 		-- LIMBS mode + MOVEMENT mode
	SMART_CIRCLE = 8, 	-- More sample points on and around character
	CHAR_OUTLINE = 9,	-- Dynamic outline around the character
}

local LIMB_TRACKING_SET = {
	-- Body parts common to R15 and R6
	['Head'] = true,
	
	-- Body parts unique to R6
	['Left Arm'] = true,
	['Right Arm'] = true,
	['Left Leg'] = true,
	['Right Leg'] = true,
	
	-- Body parts unique to R15
	['LeftLowerArm'] = true,
	['RightLowerArm'] = true,
	['LeftUpperLeg'] = true,
	['RightUpperLeg'] = true
}

local CORNER_FACTORS = {
	Vector3.new(1,1,-1),
	Vector3.new(1,-1,-1),
	Vector3.new(-1,-1,-1),
	Vector3.new(-1,1,-1)
}

local CIRCLE_CASTS = 10
local MOVE_CASTS = 3
local SMART_CIRCLE_CASTS = 24
local SMART_CIRCLE_INCREMENT = 2.0 * math.pi / SMART_CIRCLE_CASTS
local CHAR_OUTLINE_CASTS = 24

-- Used to sanitize user-supplied functions
local function AssertTypes(param, ...)
	local allowedTypes = {}
	local typeString = ''
	for _, typeName in pairs({...}) do
		allowedTypes[typeName] = true
		typeString = typeString .. (typeString == '' and '' or ' or ') .. typeName
	end
	local theType = type(param)
	assert(allowedTypes[theType], typeString .. " type expected, got: " .. theType)
end

-- Helper function for Determinant of 3x3, not in CameraUtils for performance reasons
local function Det3x3(a,b,c,d,e,f,g,h,i)
	return (a*(e*i-f*h)-b*(d*i-f*g)+c*(d*h-e*g))
end

-- Smart Circle mode needs the intersection of 2 rays that are known to be in the same plane
-- because they are generated from cross products with a common vector. This function is computing
-- that intersection, but it's actually the general solution for the point halfway between where
-- two skew lines come nearest to each other, which is more forgiving.
local function RayIntersection(p0, v0, p1, v1)
	local v2 = v0:Cross(v1)
	local d1 = p1.x - p0.x
	local d2 = p1.y - p0.y
	local d3 = p1.z - p0.z
	local denom = Det3x3(v0.x,-v1.x,v2.x,v0.y,-v1.y,v2.y,v0.z,-v1.z,v2.z)
	
	if (denom == 0) then
		return ZERO_VECTOR3 -- No solution (rays are parallel)
	end
	
	local t0 = Det3x3(d1,-v1.x,v2.x,d2,-v1.y,v2.y,d3,-v1.z,v2.z) / denom
	local t1 = Det3x3(v0.x,d1,v2.x,v0.y,d2,v2.y,v0.z,d3,v2.z) / denom
	local s0 = p0 + t0 * v0
	local s1 = p1 + t1 * v1
	local s = s0 + 0.5 * ( s1 - s0 )
	
	-- 0.25 studs is a threshold for deciding if the rays are
	-- close enough to be considered intersecting, found through testing 
	if (s1-s0).Magnitude < 0.25 then
		return s
	else
		return ZERO_VECTOR3
	end
end



--[[ The Module ]]--
local BaseOcclusion = require(script.Parent:WaitForChild("BaseOcclusion"))
local Invisicam = setmetatable({}, BaseOcclusion)
Invisicam.__index = Invisicam

function Invisicam.new()
	local self = setmetatable(BaseOcclusion.new(), Invisicam)
	
	self.char = nil
	self.humanoidRootPart = nil
	self.torsoPart = nil
	self.headPart = nil
	
	self.childAddedConn = nil
	self.childRemovedConn = nil
	
	self.behaviors = {} 	-- Map of modes to behavior fns
	self.behaviors[MODE.LIMBS] = self.LimbBehavior
	self.behaviors[MODE.MOVEMENT] = self.MoveBehavior
	self.behaviors[MODE.CORNERS] = self.CornerBehavior
	self.behaviors[MODE.CIRCLE1] = self.CircleBehavior
	self.behaviors[MODE.CIRCLE2] = self.CircleBehavior
	self.behaviors[MODE.LIMBMOVE] = self.LimbMoveBehavior
	self.behaviors[MODE.SMART_CIRCLE] = self.SmartCircleBehavior
	self.behaviors[MODE.CHAR_OUTLINE] = self.CharacterOutlineBehavior	
	
	self.mode = MODE.SMART_CIRCLE
	self.behaviorFunction = self.SmartCircleBehavior
	
	
	self.savedHits = {} 	-- Objects currently being faded in/out
	self.trackedLimbs = {}	-- Used in limb-tracking casting modes
		
	self.camera = game.Workspace.CurrentCamera

	self.enabled = false
	return self
end

function Invisicam:Enable(enable)
	self.enabled = enable
	
	if not enable then
		self:Cleanup()
	end
end

function Invisicam:GetOcclusionMode()
	return Enum.DevCameraOcclusionMode.Invisicam
end

--[[ Module functions ]]--
function Invisicam:LimbBehavior(castPoints)
	for limb, _ in pairs(self.trackedLimbs) do
		castPoints[#castPoints + 1] = limb.Position
	end
end

function Invisicam:MoveBehavior(castPoints)
	for i = 1, MOVE_CASTS do
		local position, velocity = self.humanoidRootPart.Position, self.humanoidRootPart.Velocity
		local horizontalSpeed = Vector3.new(velocity.X, 0, velocity.Z).Magnitude / 2
		local offsetVector = (i - 1) * self.humanoidRootPart.CFrame.lookVector * horizontalSpeed
		castPoints[#castPoints + 1] = position + offsetVector
	end
end

function Invisicam:CornerBehavior(castPoints)
	local cframe = self.humanoidRootPart.CFrame
	local centerPoint = cframe.p
	local rotation = cframe - centerPoint
	local halfSize = self.char:GetExtentsSize() / 2 --NOTE: Doesn't update w/ limb animations
	castPoints[#castPoints + 1] = centerPoint
	for i = 1, #CORNER_FACTORS do
		castPoints[#castPoints + 1] = centerPoint + (rotation * (halfSize * CORNER_FACTORS[i]))
	end
end

function Invisicam:CircleBehavior(castPoints)
	local cframe = nil
	if self.mode == MODE.CIRCLE1 then
		cframe = self.humanoidRootPart.CFrame
	else
		local camCFrame = self.camera.CoordinateFrame
		cframe = camCFrame - camCFrame.p + self.humanoidRootPart.Position
	end
	castPoints[#castPoints + 1] = cframe.p
	for i = 0, CIRCLE_CASTS - 1 do
		local angle = (2 * math.pi / CIRCLE_CASTS) * i
		local offset = 3 * Vector3.new(math.cos(angle), math.sin(angle), 0)
		castPoints[#castPoints + 1] = cframe * offset
	end
end	

function Invisicam:LimbMoveBehavior(castPoints)
	self:LimbBehavior(castPoints)
	self:MoveBehavior(castPoints)
end

function Invisicam:CharacterOutlineBehavior(castPoints)
	local torsoUp = self.torsoPart.CFrame.upVector.unit
	local torsoRight = self.torsoPart.CFrame.rightVector.unit
	
	-- Torso cross of points for interior coverage
	castPoints[#castPoints + 1] = self.torsoPart.CFrame.p
	castPoints[#castPoints + 1] = self.torsoPart.CFrame.p + torsoUp
	castPoints[#castPoints + 1] = self.torsoPart.CFrame.p - torsoUp
	castPoints[#castPoints + 1] = self.torsoPart.CFrame.p + torsoRight
	castPoints[#castPoints + 1] = self.torsoPart.CFrame.p - torsoRight
	if self.headPart then
		castPoints[#castPoints + 1] = self.headPart.CFrame.p
	end
	
	local cframe = CFrame.new(ZERO_VECTOR3,Vector3.new(self.camera.CoordinateFrame.lookVector.X,0,self.camera.CoordinateFrame.lookVector.Z))
	local centerPoint = (self.torsoPart and self.torsoPart.Position or self.humanoidRootPart.Position)
	
	local partsWhitelist = {self.torsoPart}
	if self.headPart then
		partsWhitelist[#partsWhitelist + 1] = self.headPart
	end
	
	for i = 1, CHAR_OUTLINE_CASTS do
		local angle = (2 * math.pi * i / CHAR_OUTLINE_CASTS)
		local offset = cframe * (3 * Vector3.new(math.cos(angle), math.sin(angle), 0))
		
		offset = Vector3.new(offset.X, math.max(offset.Y, -2.25), offset.Z)	
		
		local ray = Ray.new(centerPoint + offset, -3 * offset)
		local hit, hitPoint = game.Workspace:FindPartOnRayWithWhitelist(ray, partsWhitelist, false, false)
		
		if hit then
			-- Use hit point as the cast point, but nudge it slightly inside the character so that bumping up against
			-- walls is less likely to cause a transparency glitch
			castPoints[#castPoints + 1] = hitPoint + 0.2 * (centerPoint - hitPoint).unit
		end
	end
end

function Invisicam:SmartCircleBehavior(castPoints)
	local torsoUp = self.torsoPart.CFrame.upVector.unit
	local torsoRight = self.torsoPart.CFrame.rightVector.unit
	
	-- SMART_CIRCLE mode includes rays to head and 5 to the torso.
	-- Hands, arms, legs and feet are not included since they
	-- are not canCollide and can therefore go inside of parts
	castPoints[#castPoints + 1] = self.torsoPart.CFrame.p
	castPoints[#castPoints + 1] = self.torsoPart.CFrame.p + torsoUp
	castPoints[#castPoints + 1] = self.torsoPart.CFrame.p - torsoUp
	castPoints[#castPoints + 1] = self.torsoPart.CFrame.p + torsoRight
	castPoints[#castPoints + 1] = self.torsoPart.CFrame.p - torsoRight
	if self.headPart then
		castPoints[#castPoints + 1] = self.headPart.CFrame.p
	end
	
	local cameraOrientation = self.camera.CFrame - self.camera.CFrame.p
	local torsoPoint = Vector3.new(0,0.5,0) + (self.torsoPart and self.torsoPart.Position or self.humanoidRootPart.Position)
	local radius = 2.5
	
	-- This loop first calculates points in a circle of radius 2.5 around the torso of the character, in the
	-- plane orthogonal to the camera's lookVector. Each point is then raycast to, to determine if it is within
	-- the free space surrounding the player (not inside anything). Two iterations are done to adjust points that
	-- are inside parts, to try to move them to valid locations that are still on their camera ray, so that the
	-- circle remains circular from the camera's perspective, but does not cast rays into walls or parts that are
	-- behind, below or beside the character and not really obstructing view of the character. This minimizes
	-- the undesirable situation where the character walks up to an exterior wall and it is made invisible even
	-- though it is behind the character.
	for i = 1, SMART_CIRCLE_CASTS do
		local angle = SMART_CIRCLE_INCREMENT * i - 0.5 * math.pi
		local offset = radius * Vector3.new(math.cos(angle), math.sin(angle), 0)
		local circlePoint = torsoPoint + cameraOrientation * offset		
		 
		-- Vector from camera to point on the circle being tested		
		local vp = circlePoint - self.camera.CFrame.p
		
		local ray = Ray.new(torsoPoint, circlePoint - torsoPoint)
		local hit, hp, hitNormal = game.Workspace:FindPartOnRayWithIgnoreList(ray, {self.char}, false, false )
		local castPoint = circlePoint
				
		if hit then
			local hprime = hp + 0.1 * hitNormal.unit -- Slightly offset hit point from the hit surface
			local v0 = hprime - torsoPoint -- Vector from torso to offset hit point
			local d0 = v0.magnitude
			
			local perp = (v0:Cross(vp)).unit

			-- Vector from the offset hit point, along the hit surface
			local v1 = (perp:Cross(hitNormal)).unit
			
			-- Vector from camera to offset hit
			local vprime = (hprime - self.camera.CFrame.p).unit
			
			-- This dot product checks to see if the vector along the hit surface would hit the correct
			-- side of the invisicam cone, or if it would cross the camera look vector and hit the wrong side
			if ( v0.unit:Dot(-v1) < v0.unit:Dot(vprime)) then
				castPoint = RayIntersection(hprime, v1, circlePoint, vp)
				
				if castPoint.Magnitude > 0 then
					local ray = Ray.new(hprime, castPoint - hprime)
					local hit, hitPoint, hitNormal = game.Workspace:FindPartOnRayWithIgnoreList(ray, {self.char}, false, false )
					
					if hit then
						local hprime2 = hitPoint + 0.1 * hitNormal.unit
						castPoint = hprime2
					end
				else
					castPoint = hprime
				end
			else
				castPoint = hprime
			end
			
			local ray = Ray.new(torsoPoint, (castPoint - torsoPoint))
			local hit, hitPoint, hitNormal = game.Workspace:FindPartOnRayWithIgnoreList(ray, {self.char}, false, false )
	
			if hit then
				local castPoint2 = hitPoint - 0.1 * (castPoint - torsoPoint).unit
				castPoint = castPoint2	
			end
		end
		
		castPoints[#castPoints + 1] = castPoint
	end
end

function Invisicam:CheckTorsoReference()
	if self.char then
		self.torsoPart = self.char:FindFirstChild("Torso")
		if not self.torsoPart then
			self.torsoPart = self.char:FindFirstChild("UpperTorso")
			if not self.torsoPart then
				self.torsoPart = self.char:FindFirstChild("HumanoidRootPart")
			end
		end
		
		self.headPart = self.char:FindFirstChild("Head")
	end
end

function Invisicam:CharacterAdded(char, player)
	-- We only want the LocalPlayer's character
	if player~=PlayersService.LocalPlayer then return end
	
	if self.childAddedConn then
		self.childAddedConn:Disconnect()
		self.childAddedConn = nil
	end
	if self.childRemovedConn then
		self.childRemovedConn:Disconnect()
		self.childRemovedConn = nil
	end

	self.char = char
	
	self.trackedLimbs = {}
	local function childAdded(child)
		if child:IsA("BasePart") then
			if LIMB_TRACKING_SET[child.Name] then
				self.trackedLimbs[child] = true
			end

			if (child.Name == "Torso" or child.Name == "UpperTorso") then
				self.torsoPart = child
			end

			if (child.Name == "Head") then
				self.headPart = child
			end			
		end
	end
	
	local function childRemoved(child)
		self.trackedLimbs[child] = nil
		
		-- If removed/replaced part is 'Torso' or 'UpperTorso' double check that we still have a TorsoPart to use
		self:CheckTorsoReference()
	end	
	
	self.childAddedConn = char.ChildAdded:Connect(childAdded)
	self.childRemovedConn = char.ChildRemoved:Connect(childRemoved)
	for _, child in pairs(self.char:GetChildren()) do
		childAdded(child)
	end
end

function Invisicam:SetMode(newMode)
	AssertTypes(newMode, 'number')
	for modeName, modeNum in pairs(MODE) do
		if modeNum == newMode then
			self.mode = newMode
			self.behaviorFunction = self.behaviors[self.mode]
			return
		end
	end
	error("Invalid mode number")
end

function Invisicam:GetObscuredParts()
	return self.savedHits
end

-- Want to turn off Invisicam? Be sure to call this after.
function Invisicam:Cleanup()
	for hit, originalFade in pairs(self.savedHits) do
		hit.LocalTransparencyModifier = originalFade
	end
end

function Invisicam:Update(dt, desiredCameraCFrame, desiredCameraFocus)
	
	-- Bail if there is no Character
	if not self.enabled or not self.char then
		return desiredCameraCFrame, desiredCameraFocus		
	end

	self.camera = game.Workspace.CurrentCamera
	
	-- TODO: Move this to a GetHumanoidRootPart helper, probably combine with CheckTorsoReference
	-- Make sure we still have a HumanoidRootPart
	if not self.humanoidRootPart then
		local humanoid = self.char:FindFirstChildOfClass("Humanoid")
		if humanoid and humanoid.RootPart then
			self.humanoidRootPart = humanoid.RootPart
		else
			-- Not set up with Humanoid? Try and see if there's one in the Character at all:
			self.humanoidRootPart = self.char:FindFirstChild("HumanoidRootPart")
			if not self.humanoidRootPart then
				-- Bail out, since we're relying on HumanoidRootPart existing
				return desiredCameraCFrame, desiredCameraFocus
			end
		end
		
		-- TODO: Replace this with something more sensible
		local ancestryChangedConn
		ancestryChangedConn = self.humanoidRootPart.AncestryChanged:Connect(function(child, parent)
			if child == self.humanoidRootPart and not parent then 
				self.humanoidRootPart = nil
				if ancestryChangedConn and ancestryChangedConn.Connected then
					ancestryChangedConn:Disconnect()
					ancestryChangedConn = nil
				end
			end
		end)
	end
	
	if not self.torsoPart then
		self:CheckTorsoReference()
		if not self.torsoPart then
			-- Bail out, since we're relying on Torso existing, should never happen since we fall back to using HumanoidRootPart as torso
			return desiredCameraCFrame, desiredCameraFocus
		end
	end

	-- Make a list of world points to raycast to
	local castPoints = {}
	self.behaviorFunction(self, castPoints)
	
	-- Cast to get a list of objects between the camera and the cast points
	local currentHits = {}
	local ignoreList = {self.char}
	local function add(hit)
		currentHits[hit] = true
		if not self.savedHits[hit] then
			self.savedHits[hit] = hit.LocalTransparencyModifier
		end
	end
	
	local hitParts
	local hitPartCount = 0
	
	-- Hash table to treat head-ray-hit parts differently than the rest of the hit parts hit by other rays
	-- head/torso ray hit parts will be more transparent than peripheral parts when USE_STACKING_TRANSPARENCY is enabled
	local headTorsoRayHitParts = {}	
	local partIsTouchingCamera = {}
	
	local perPartTransparencyHeadTorsoHits = TARGET_TRANSPARENCY
	local perPartTransparencyOtherHits = TARGET_TRANSPARENCY
	
	if USE_STACKING_TRANSPARENCY then
	
		-- This first call uses head and torso rays to find out how many parts are stacked up
		-- for the purpose of calculating required per-part transparency
		local headPoint = self.headPart and self.headPart.CFrame.p or castPoints[1]
		local torsoPoint = self.torsoPart and self.torsoPart.CFrame.p or castPoints[2]
		hitParts = self.camera:GetPartsObscuringTarget({headPoint, torsoPoint}, ignoreList)
		
		-- Count how many things the sample rays passed through, including decals. This should only
		-- count decals facing the camera, but GetPartsObscuringTarget does not return surface normals,
		-- so my compromise for now is to just let any decal increase the part count by 1. Only one
		-- decal per part will be considered.
		for i = 1, #hitParts do
			local hitPart = hitParts[i]
			hitPartCount = hitPartCount + 1 -- count the part itself
			headTorsoRayHitParts[hitPart] = true
			for _, child in pairs(hitPart:GetChildren()) do
				if child:IsA('Decal') or child:IsA('Texture') then
					hitPartCount = hitPartCount + 1 -- count first decal hit, then break
					break
				end
			end
		end
		
		if (hitPartCount > 0) then
			perPartTransparencyHeadTorsoHits = math.pow( ((0.5 * TARGET_TRANSPARENCY) + (0.5 * TARGET_TRANSPARENCY / hitPartCount)), 1 / hitPartCount )
			perPartTransparencyOtherHits = math.pow( ((0.5 * TARGET_TRANSPARENCY_PERIPHERAL) + (0.5 * TARGET_TRANSPARENCY_PERIPHERAL / hitPartCount)), 1 / hitPartCount )
		end
	end
	
	-- Now get all the parts hit by all the rays
	hitParts = self.camera:GetPartsObscuringTarget(castPoints, ignoreList)
	
	local partTargetTransparency = {}
	
	-- Include decals and textures
	for i = 1, #hitParts do
		local hitPart = hitParts[i]
		
		partTargetTransparency[hitPart] =headTorsoRayHitParts[hitPart] and perPartTransparencyHeadTorsoHits or perPartTransparencyOtherHits

		-- If the part is not already as transparent or more transparent than what invisicam requires, add it to the list of
		-- parts to be modified by invisicam
		if hitPart.Transparency < partTargetTransparency[hitPart] then
			add(hitPart)
		end
		
		-- Check all decals and textures on the part
		for _, child in pairs(hitPart:GetChildren()) do
			if child:IsA('Decal') or child:IsA('Texture') then
				if (child.Transparency < partTargetTransparency[hitPart]) then
					partTargetTransparency[child] = partTargetTransparency[hitPart]
					add(child)
				end
			end
		end
	end
	
	-- Invisibilize objects that are in the way, restore those that aren't anymore
	for hitPart, originalLTM in pairs(self.savedHits) do
		if currentHits[hitPart] then
			-- LocalTransparencyModifier gets whatever value is required to print the part's total transparency to equal perPartTransparency			
			hitPart.LocalTransparencyModifier = (hitPart.Transparency < 1) and ((partTargetTransparency[hitPart] - hitPart.Transparency) / (1.0 - hitPart.Transparency)) or 0
		else -- Restore original pre-invisicam value of LTM
			hitPart.LocalTransparencyModifier = originalLTM
			self.savedHits[hitPart] = nil
		end
	end
	
	-- Invisicam does not change the camera values
	return desiredCameraCFrame, desiredCameraFocus
end

return Invisicam]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXC0F3F8EEBCEB4EEC86B1E5F1ABA1F7F3">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">ClassicCamera</string>
							<string name="ScriptGuid">{D7193A76-79BF-4E3C-87D3-F9D4039AE92C}</string>
							<ProtectedString name="Source"><![CDATA[--[[
	ClassicCamera - Classic Roblox camera control module
	2018 Camera Update - AllYourBlox

	Note: This module also handles camera control types Follow and Track, the
	latter of which is currently not distinguished from Classic
--]]

-- Local private variables and constants
local ZERO_VECTOR2 = Vector2.new(0,0)

local tweenAcceleration = math.rad(220)		--Radians/Second^2
local tweenSpeed = math.rad(0)				--Radians/Second
local tweenMaxSpeed = math.rad(250)			--Radians/Second
local TIME_BEFORE_AUTO_ROTATE = 2.0 		--Seconds, used when auto-aligning camera with vehicles
local PORTRAIT_OFFSET = Vector3.new(0, 2, 0) 
local MOBILE_OFFSET = Vector3.new(0, 1, 0)

local INITIAL_CAMERA_ANGLE = CFrame.fromOrientation(math.rad(-15), 0, 0)

--[[ Services ]]--
local PlayersService = game:GetService('Players')
local VRService = game:GetService("VRService")

local Util = require(script.Parent:WaitForChild("CameraUtils"))

local newDefaultCameraAngleFlagExists, newDefaultCameraAngleFlagEnabled = pcall(function()
	return UserSettings():IsUserFeatureEnabled("UserNewDefaultCameraAngle")
end)
local FFlagUserNewDefaultCameraAngle = newDefaultCameraAngleFlagExists and newDefaultCameraAngleFlagEnabled

--[[ The Module ]]--
local BaseCamera = require(script.Parent:WaitForChild("BaseCamera"))
local ClassicCamera = setmetatable({}, BaseCamera)
ClassicCamera.__index = ClassicCamera

function ClassicCamera.new()
	local self = setmetatable(BaseCamera.new(), ClassicCamera)

	self.isFollowCamera = false
	self.lastUpdate = tick()

	return self
end

function ClassicCamera:GetModuleName()
	return "ClassicCamera"
end

-- Movement mode standardized to Enum.ComputerCameraMovementMode values
function ClassicCamera:SetCameraMovementMode( cameraMovementMode )
	BaseCamera.SetCameraMovementMode(self,cameraMovementMode)
	self.isFollowCamera = cameraMovementMode == Enum.ComputerCameraMovementMode.Follow
end

function ClassicCamera:Test()
	print("ClassicCamera:Test()")
end

function ClassicCamera:GetCameraSubjectOffset()
	if self:IsInFirstPerson() then 
		return Vector3.new(0, 0, 0)
	elseif self.portraitMode then
		return PORTRAIT_OFFSET
	elseif self.isSmallTouchScreen then
		return MOBILE_OFFSET
	end
	return Vector3.new(0, 0, 0)
end

function ClassicCamera:Update()		
	local now = tick()
	local timeDelta = (now - self.lastUpdate)

	local camera = 	workspace.CurrentCamera
	local newCameraCFrame = camera.CFrame
	local newCameraFocus = camera.Focus
	local overrideCameraLookVector = nil
	if FFlagUserNewDefaultCameraAngle and self.resetCameraAngle then
		local rootPart = self:GetHumanoidRootPart()
		if rootPart then 
			overrideCameraLookVector = (rootPart.CFrame * INITIAL_CAMERA_ANGLE).lookVector
		else
			overrideCameraLookVector = INITIAL_CAMERA_ANGLE.lookVector
		end
		self.resetCameraAngle = false
	end
	
	local player = PlayersService.LocalPlayer
	local humanoid = self:GetHumanoid()
	local cameraSubject = camera.CameraSubject
	local isInVehicle = cameraSubject and cameraSubject:IsA('VehicleSeat')
	local isOnASkateboard = cameraSubject and cameraSubject:IsA('SkateboardPlatform')
	local isClimbing = humanoid and humanoid:GetState() == Enum.HumanoidStateType.Climbing

	if self.lastUpdate == nil or timeDelta > 1 then
		self.lastCameraTransform = nil
	end

	if self.lastUpdate then
		local gamepadRotation = self:UpdateGamepad()

		if self:ShouldUseVRRotation() then
			self.rotateInput = self.rotateInput + self:GetVRRotationInput()
		else
			-- Cap out the delta to 0.1 so we don't get some crazy things when we re-resume from
			local delta = math.min(0.1, timeDelta)

			if gamepadRotation ~= ZERO_VECTOR2 then
				self.rotateInput = self.rotateInput + (gamepadRotation * delta)
			end

			local angle = 0
			if not (isInVehicle or isOnASkateboard) then
				angle = angle + (self.turningLeft and -120 or 0)
				angle = angle + (self.turningRight and 120 or 0)
			end

			if angle ~= 0 then
				self.rotateInput = self.rotateInput +  Vector2.new(math.rad(angle * delta), 0)
			end
		end
	end

	-- Reset tween speed if user is panning
	if self.userPanningTheCamera then
		tweenSpeed = 0
		self.lastUserPanCamera = tick()
	end

	local userRecentlyPannedCamera = now - self.lastUserPanCamera < TIME_BEFORE_AUTO_ROTATE
	local subjectPosition = self:GetSubjectPosition()

	if subjectPosition and player and camera then
		local zoom = self:GetCameraToSubjectDistance()
		if zoom < 0.5 then
			zoom = 0.5
		end

		if self:GetIsMouseLocked() and not self:IsInFirstPerson() then
			-- We need to use the right vector of the camera after rotation, not before
			local newLookCFrame = self:CalculateNewLookCFrame(overrideCameraLookVector)

			local offset = self:GetMouseLockOffset()
			local cameraRelativeOffset = offset.X * newLookCFrame.rightVector + offset.Y * newLookCFrame.upVector + offset.Z * newLookCFrame.lookVector

			--offset can be NAN, NAN, NAN if newLookVector has only y component
			if Util.IsFiniteVector3(cameraRelativeOffset) then
				subjectPosition = subjectPosition + cameraRelativeOffset
			end
		else
			if not self.userPanningTheCamera and self.lastCameraTransform then

				local isInFirstPerson = self:IsInFirstPerson()

				if (isInVehicle or isOnASkateboard or (self.isFollowCamera and isClimbing)) and self.lastUpdate and humanoid and humanoid.Torso then
					if isInFirstPerson then
						if self.lastSubjectCFrame and (isInVehicle or isOnASkateboard) and cameraSubject:IsA('BasePart') then
							local y = -Util.GetAngleBetweenXZVectors(self.lastSubjectCFrame.lookVector, cameraSubject.CFrame.lookVector)
							if Util.IsFinite(y) then
								self.rotateInput = self.rotateInput + Vector2.new(y, 0)
							end
							tweenSpeed = 0
						end
					elseif not userRecentlyPannedCamera then
						local forwardVector = humanoid.Torso.CFrame.lookVector
						if isOnASkateboard then
							forwardVector = cameraSubject.CFrame.lookVector
						end

						tweenSpeed = Util.Clamp(0, tweenMaxSpeed, tweenSpeed + tweenAcceleration * timeDelta)

						local percent = Util.Clamp(0, 1, tweenSpeed * timeDelta)
						if self:IsInFirstPerson() and not (self.isFollowCamera and self.isClimbing) then
							percent = 1
						end

						local y = Util.GetAngleBetweenXZVectors(forwardVector, self:GetCameraLookVector())
						if Util.IsFinite(y) and math.abs(y) > 0.0001 then
							self.rotateInput = self.rotateInput + Vector2.new(y * percent, 0)
						end
					end

				elseif self.isFollowCamera and (not (isInFirstPerson or userRecentlyPannedCamera) and not VRService.VREnabled) then
					-- Logic that was unique to the old FollowCamera module
					local lastVec = -(self.lastCameraTransform.p - subjectPosition)

					local y = Util.GetAngleBetweenXZVectors(lastVec, self:GetCameraLookVector())

					-- This cutoff is to decide if the humanoid's angle of movement,
					-- relative to the camera's look vector, is enough that
					-- we want the camera to be following them. The point is to provide
					-- a sizable dead zone to allow more precise forward movements.
					local thetaCutoff = 0.4

					-- Check for NaNs
					if Util.IsFinite(y) and math.abs(y) > 0.0001 and math.abs(y) > thetaCutoff * timeDelta then
						self.rotateInput = self.rotateInput + Vector2.new(y, 0)
					end
				end
			end
		end

		if not self.isFollowCamera then
			local VREnabled = VRService.VREnabled
			
			if FFlagUserNewDefaultCameraAngle then
				if VREnabled then
					newCameraFocus = self:GetVRFocus(subjectPosition, timeDelta)
				else
					newCameraFocus = CFrame.new(subjectPosition + self:GetCameraSubjectOffset())
				end
			else
				newCameraFocus = VREnabled and self:GetVRFocus(subjectPosition, timeDelta) or CFrame.new(subjectPosition)
			end
		
			local cameraFocusP = newCameraFocus.p
			if VREnabled and not self:IsInFirstPerson() then
				local cameraHeight = self:GetCameraHeight()
				local vecToSubject = (subjectPosition - camera.CFrame.p)
				local distToSubject = vecToSubject.magnitude

				-- Only move the camera if it exceeded a maximum distance to the subject in VR
				if distToSubject > zoom or self.rotateInput.x ~= 0 then
					local desiredDist = math.min(distToSubject, zoom)
					vecToSubject = self:CalculateNewLookVectorVR() * desiredDist
					local newPos = cameraFocusP - vecToSubject
					local desiredLookDir = camera.CFrame.lookVector
					if self.rotateInput.x ~= 0 then
						desiredLookDir = vecToSubject
					end
					local lookAt = Vector3.new(newPos.x + desiredLookDir.x, newPos.y, newPos.z + desiredLookDir.z)
					self.rotateInput = ZERO_VECTOR2

					newCameraCFrame = CFrame.new(newPos, lookAt) + Vector3.new(0, cameraHeight, 0)
				end
			else
				local newLookVector = self:CalculateNewLookVector(overrideCameraLookVector)
				self.rotateInput = ZERO_VECTOR2
				newCameraCFrame = CFrame.new(cameraFocusP - (zoom * newLookVector), cameraFocusP)
			end
		else -- is FollowCamera
			local newLookVector = self:CalculateNewLookVector(overrideCameraLookVector)
			self.rotateInput = ZERO_VECTOR2

			if FFlagUserNewDefaultCameraAngle then
				if VRService.VREnabled then
					newCameraFocus = self:GetVRFocus(subjectPosition, timeDelta)
				else
					newCameraFocus = CFrame.new(subjectPosition + self:GetCameraSubjectOffset())
				end
			else
				if VRService.VREnabled then
					newCameraFocus = self:GetVRFocus(subjectPosition, timeDelta)
				elseif self.portraitMode then
					newCameraFocus = CFrame.new(subjectPosition + PORTRAIT_OFFSET)
				else
					newCameraFocus = CFrame.new(subjectPosition)
				end
			end
			newCameraCFrame = CFrame.new(newCameraFocus.p - (zoom * newLookVector), newCameraFocus.p) + Vector3.new(0, self:GetCameraHeight(), 0)
		end

		self.lastCameraTransform = newCameraCFrame
		self.lastCameraFocus = newCameraFocus
		if (isInVehicle or isOnASkateboard) and cameraSubject:IsA('BasePart') then
			self.lastSubjectCFrame = cameraSubject.CFrame
		else
			self.lastSubjectCFrame = nil
		end
	end

	self.lastUpdate = now
	return newCameraCFrame, newCameraFocus
end

function ClassicCamera:EnterFirstPerson()
	self.inFirstPerson = true
	self:UpdateMouseBehavior()
end

function ClassicCamera:LeaveFirstPerson()
	self.inFirstPerson = false
	self:UpdateMouseBehavior()
end

return ClassicCamera
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXFF1319E672D246B9A10CDACAD06429F7">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">CameraUtils</string>
							<string name="ScriptGuid">{102A8CF7-38A3-4FE5-BD50-D553598B85A6}</string>
							<ProtectedString name="Source"><![CDATA[--[[
	CameraUtils - Math utility functions shared by multiple camera scripts
	2018 Camera Update - AllYourBlox		
--]]

local CameraUtils = {}

local function round(num)
	return math.floor(num + 0.5)
end

-- Note, arguments do not match the new math.clamp
-- Eventually we will replace these calls with math.clamp, but right now
-- this is safer as math.clamp is not tolerant of min>max
function CameraUtils.Clamp(low, high, val)
	return math.min(math.max(val, low), high)
end

-- From TransparencyController
function CameraUtils.Round(num, places)
	local decimalPivot = 10^places
	return math.floor(num * decimalPivot + 0.5) / decimalPivot
end

function CameraUtils.IsFinite(val)
	return val == val and val ~= math.huge and val ~= -math.huge
end

function CameraUtils.IsFiniteVector3(vec3)
	return CameraUtils.IsFinite(vec3.X) and CameraUtils.IsFinite(vec3.Y) and CameraUtils.IsFinite(vec3.Z)
end

-- Legacy implementation renamed
function CameraUtils.GetAngleBetweenXZVectors(v1, v2)
	return math.atan2(v2.X*v1.Z-v2.Z*v1.X, v2.X*v1.X+v2.Z*v1.Z)
end

function  CameraUtils.RotateVectorByAngleAndRound(camLook, rotateAngle, roundAmount)
	if camLook.Magnitude > 0 then
		camLook = camLook.unit
		local currAngle = math.atan2(camLook.z, camLook.x)
		local newAngle = round((math.atan2(camLook.z, camLook.x) + rotateAngle) / roundAmount) * roundAmount
		return newAngle - currAngle
	end
	return 0
end

-- K is a tunable parameter that changes the shape of the S-curve
-- the larger K is the more straight/linear the curve gets
local k = 0.35
local lowerK = 0.8
local function SCurveTranform(t)
	t = CameraUtils.Clamp(-1,1,t)
	if t >= 0 then
		return (k*t) / (k - t + 1)
	end
	return -((lowerK*-t) / (lowerK + t + 1))
end

local DEADZONE = 0.1
local function toSCurveSpace(t)
	return (1 + DEADZONE) * (2*math.abs(t) - 1) - DEADZONE
end

local function fromSCurveSpace(t)
	return t/2 + 0.5
end
	
function CameraUtils.GamepadLinearToCurve(thumbstickPosition)
	local function onAxis(axisValue)
		local sign = 1
		if axisValue < 0 then
			sign = -1
		end
		local point = fromSCurveSpace(SCurveTranform(toSCurveSpace(math.abs(axisValue))))
		point = point * sign
		return CameraUtils.Clamp(-1, 1, point)
	end
	return Vector2.new(onAxis(thumbstickPosition.x), onAxis(thumbstickPosition.y))
end

-- This function converts 4 different, redundant enumeration types to one standard so the values can be compared
function CameraUtils.ConvertCameraModeEnumToStandard( enumValue )
	
	if enumValue == Enum.TouchCameraMovementMode.Default then
		return Enum.ComputerCameraMovementMode.Follow
	end
	
	if enumValue == Enum.ComputerCameraMovementMode.Default then
		return Enum.ComputerCameraMovementMode.Classic
	end
	
	if enumValue == Enum.TouchCameraMovementMode.Classic or
		enumValue == Enum.DevTouchCameraMovementMode.Classic or
		enumValue == Enum.DevComputerCameraMovementMode.Classic or
		enumValue == Enum.ComputerCameraMovementMode.Classic then
		return Enum.ComputerCameraMovementMode.Classic
	end
	
	if enumValue == Enum.TouchCameraMovementMode.Follow or
		enumValue == Enum.DevTouchCameraMovementMode.Follow or
		enumValue == Enum.DevComputerCameraMovementMode.Follow or
		enumValue == Enum.ComputerCameraMovementMode.Follow then
		return Enum.ComputerCameraMovementMode.Follow
	end
	
	if enumValue == Enum.TouchCameraMovementMode.Orbital or
		enumValue == Enum.DevTouchCameraMovementMode.Orbital or
		enumValue == Enum.DevComputerCameraMovementMode.Orbital or
		enumValue == Enum.ComputerCameraMovementMode.Orbital then
		return Enum.ComputerCameraMovementMode.Orbital
	end
	
	-- Note: Only the Dev versions of the Enums have UserChoice as an option
	if enumValue == Enum.DevTouchCameraMovementMode.UserChoice or
		enumValue == Enum.DevComputerCameraMovementMode.UserChoice then
		return Enum.DevComputerCameraMovementMode.UserChoice
	end
	
	-- For any unmapped options return Classic camera
	return Enum.ComputerCameraMovementMode.Classic
end

return CameraUtils

]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXD5F4C5EFE918482599441A1658593147">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">BaseOcclusion</string>
							<string name="ScriptGuid">{DBCB3B43-B8D0-4CA0-943B-A91D71BC00F4}</string>
							<ProtectedString name="Source"><![CDATA[--[[
	BaseOcclusion - Abstract base class for character occlusion control modules
	2018 Camera Update - AllYourBlox		
--]]

--[[ The Module ]]--
local BaseOcclusion = {}
BaseOcclusion.__index = BaseOcclusion
setmetatable(BaseOcclusion, { __call = function(_, ...) return BaseOcclusion.new(...) end})

function BaseOcclusion.new()
	local self = setmetatable({}, BaseOcclusion)
	return self
end

-- Called when character is added
function BaseOcclusion:CharacterAdded(char, player)
	
end

-- Called when character is about to be removed
function BaseOcclusion:CharacterRemoving(char, player)
	
end

function BaseOcclusion:OnCameraSubjectChanged(newSubject)
	
end

--[[ Derived classes are required to override and implement all of the following functions ]]--
function GetOcclusionMode()
	-- Must be overridden in derived classes to return an Enum.DevCameraOcclusionMode value
	warn("BaseOcclusion GetOcclusionMode must be overridden by derived classes")
	return nil
end

function BaseOcclusion:Enable(enabled)
	warn("BaseOcclusion Enable must be overridden by derived classes")
end

function BaseOcclusion:Update(dt, desiredCameraCFrame, desiredCameraFocus)
	warn("BaseOcclusion Update must be overridden by derived classes")
	return desiredCameraCFrame, desiredCameraFocus
end

return BaseOcclusion
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX748F7163861D4F03B644BC522960BAE5">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">BaseCamera</string>
							<string name="ScriptGuid">{5F36CE02-919B-4DBC-8DBD-06C642603CAA}</string>
							<ProtectedString name="Source"><![CDATA[--[[
	BaseCamera - Abstract base class for camera control modules
	2018 Camera Update - AllYourBlox
--]]

--[[ Local Constants ]]--
local UNIT_Z = Vector3.new(0,0,1)
local X1_Y0_Z1 = Vector3.new(1,0,1)	--Note: not a unit vector, used for projecting onto XZ plane

local THUMBSTICK_DEADZONE = 0.2
local DEFAULT_DISTANCE = 12.5	-- Studs
local PORTRAIT_DEFAULT_DISTANCE = 25		-- Studs
local FIRST_PERSON_DISTANCE_THRESHOLD = 1.0 -- Below this value, snap into first person

local CAMERA_ACTION_PRIORITY = Enum.ContextActionPriority.Default.Value

-- Note: DotProduct check in CoordinateFrame::lookAt() prevents using values within about
-- 8.11 degrees of the +/- Y axis, that's why these limits are currently 80 degrees
local MIN_Y = math.rad(-80)
local MAX_Y = math.rad(80)

local VR_ANGLE = math.rad(15)
local VR_LOW_INTENSITY_ROTATION = Vector2.new(math.rad(15), 0)
local VR_HIGH_INTENSITY_ROTATION = Vector2.new(math.rad(45), 0)
local VR_LOW_INTENSITY_REPEAT = 0.1
local VR_HIGH_INTENSITY_REPEAT = 0.4

local ZERO_VECTOR2 = Vector2.new(0,0)
local ZERO_VECTOR3 = Vector3.new(0,0,0)

local TOUCH_SENSITIVTY = Vector2.new( 0.002 * math.pi, 0.0015 * math.pi)
local MOUSE_SENSITIVITY = Vector2.new( 0.002 * math.pi, 0.0015 * math.pi )

local MAX_TIME_FOR_DOUBLE_TAP = 1.5
local MAX_TAP_POS_DELTA = 15
local MAX_TAP_TIME_DELTA = 0.75

local SEAT_OFFSET = Vector3.new(0,5,0)
local VR_SEAT_OFFSET = Vector3.new(0,4,0)
local HEAD_OFFSET = Vector3.new(0,1.5,0)
local R15_HEAD_OFFSET = Vector3.new(0,2,0)

local bindAtPriorityFlagExists, bindAtPriorityFlagEnabled = pcall(function()
	return UserSettings():IsUserFeatureEnabled("UserPlayerScriptsBindAtPriority")
end)
local FFlagPlayerScriptsBindAtPriority = bindAtPriorityFlagExists and bindAtPriorityFlagEnabled

local newDefaultCameraAngleFlagExists, newDefaultCameraAngleFlagEnabled = pcall(function()
	return UserSettings():IsUserFeatureEnabled("UserNewDefaultCameraAngle")
end)
local FFlagUserNewDefaultCameraAngle = newDefaultCameraAngleFlagExists and newDefaultCameraAngleFlagEnabled

local Util = require(script.Parent:WaitForChild("CameraUtils"))
local ZoomController = require(script.Parent:WaitForChild("ZoomController"))

--[[ Roblox Services ]]--
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local StarterGui = game:GetService("StarterGui")
local GuiService = game:GetService("GuiService")
local ContextActionService = game:GetService("ContextActionService")
local VRService = game:GetService("VRService")
local UserGameSettings = UserSettings():GetService("UserGameSettings")

--[[ The Module ]]--
local BaseCamera = {}
BaseCamera.__index = BaseCamera

function BaseCamera.new()
	local self = setmetatable({}, BaseCamera)

	-- So that derived classes have access to this
	self.FIRST_PERSON_DISTANCE_THRESHOLD = FIRST_PERSON_DISTANCE_THRESHOLD

	self.cameraType = nil
	self.cameraMovementMode = nil

	local player = Players.LocalPlayer
	self.lastCameraTransform = nil
	self.rotateInput = ZERO_VECTOR2
	self.userPanningCamera = false
	self.lastUserPanCamera = tick()

	self.humanoidRootPart = nil
	self.humanoidCache = {}

	-- Subject and position on last update call
	self.lastSubject = nil
	self.lastSubjectPosition = Vector3.new(0,5,0)

	-- These subject distance members refer to the nominal camera-to-subject follow distance that the camera
	-- is trying to maintain, not the actual measured value.
	-- The default is updated when screen orientation or the min/max distances change,
	-- to be sure the default is always in range and appropriate for the orientation.
	self.defaultSubjectDistance = Util.Clamp(player.CameraMinZoomDistance, player.CameraMaxZoomDistance, DEFAULT_DISTANCE)
	self.currentSubjectDistance = Util.Clamp(player.CameraMinZoomDistance, player.CameraMaxZoomDistance, DEFAULT_DISTANCE)

	self.inFirstPerson = false
	self.inMouseLockedMode = false
	self.portraitMode = false
	self.isSmallTouchScreen = false
	
	-- Used by modules which want to reset the camera angle on respawn.
	self.resetCameraAngle = true

	self.enabled = false

	-- Input Event Connections
	self.inputBeganConn = nil
	self.inputChangedConn = nil
	self.inputEndedConn = nil

	self.startPos = nil
	self.lastPos = nil
	self.panBeginLook = nil

	self.panEnabled = true
	self.keyPanEnabled = true
	self.distanceChangeEnabled = true

	self.PlayerGui = nil

	self.cameraChangedConn = nil
	self.viewportSizeChangedConn = nil
	
	self.boundContextActions = {}

	-- VR Support
	self.shouldUseVRRotation = false
	self.VRRotationIntensityAvailable = false
	self.lastVRRotationIntensityCheckTime = 0
	self.lastVRRotationTime = 0
	self.vrRotateKeyCooldown = {}
	self.cameraTranslationConstraints = Vector3.new(1, 1, 1)
	self.humanoidJumpOrigin = nil
	self.trackingHumanoid = nil
	self.cameraFrozen = false
	self.headHeightR15 = R15_HEAD_OFFSET
	self.heightScaleChangedConn = nil
	self.subjectStateChangedConn = nil
	self.humanoidChildAddedConn = nil
	self.humanoidChildRemovedConn = nil

	-- Gamepad support
	self.activeGamepad = nil
	self.gamepadPanningCamera = false
	self.lastThumbstickRotate = nil
	self.numOfSeconds = 0.7
	self.currentSpeed = 0
	self.maxSpeed = 6
	self.vrMaxSpeed = 4
	self.lastThumbstickPos = Vector2.new(0,0)
	self.ySensitivity = 0.65
	self.lastVelocity = nil
	self.gamepadConnectedConn = nil
	self.gamepadDisconnectedConn = nil
	self.currentZoomSpeed = 1.0
	self.L3ButtonDown = false
	self.dpadLeftDown = false
	self.dpadRightDown = false

	-- Touch input support
	self.isDynamicThumbstickEnabled = false
	self.fingerTouches = {}
	self.numUnsunkTouches = 0
	self.inputStartPositions = {}
	self.inputStartTimes = {}
	self.startingDiff = nil
	self.pinchBeginZoom = nil
	self.userPanningTheCamera = false
	self.touchActivateConn = nil

	-- Mouse locked formerly known as shift lock mode
	self.mouseLockOffset = ZERO_VECTOR3

	-- [[ NOTICE ]] --
	-- Initialization things used to always execute at game load time, but now these camera modules are instantiated
	-- when needed, so the code here may run well after the start of the game

	if player.Character then
		self:OnCharacterAdded(player.Character)
	end

	player.CharacterAdded:Connect(function(char)
		self:OnCharacterAdded(char)
	end)

	if self.cameraChangedConn then self.cameraChangedConn:Disconnect() end
	self.cameraChangedConn = workspace:GetPropertyChangedSignal("CurrentCamera"):Connect(function()
		self:OnCurrentCameraChanged()
	end)
	if FFlagUserNewDefaultCameraAngle then
		self:OnCurrentCameraChanged()
	end

	if self.playerCameraModeChangeConn then self.playerCameraModeChangeConn:Disconnect() end
	self.playerCameraModeChangeConn = player:GetPropertyChangedSignal("CameraMode"):Connect(function()
		self:OnPlayerCameraPropertyChange()
	end)

	if self.minDistanceChangeConn then self.minDistanceChangeConn:Disconnect() end
	self.minDistanceChangeConn = player:GetPropertyChangedSignal("CameraMinZoomDistance"):Connect(function()
		self:OnPlayerCameraPropertyChange()
	end)

	if self.maxDistanceChangeConn then self.maxDistanceChangeConn:Disconnect() end
	self.maxDistanceChangeConn = player:GetPropertyChangedSignal("CameraMaxZoomDistance"):Connect(function()
		self:OnPlayerCameraPropertyChange()
	end)

	if self.playerDevTouchMoveModeChangeConn then self.playerDevTouchMoveModeChangeConn:Disconnect() end
	self.playerDevTouchMoveModeChangeConn = player:GetPropertyChangedSignal("DevTouchMovementMode"):Connect(function()
		self:OnDevTouchMovementModeChanged()
	end)
	self:OnDevTouchMovementModeChanged() -- Init

	if self.gameSettingsTouchMoveMoveChangeConn then self.gameSettingsTouchMoveMoveChangeConn:Disconnect() end
	self.gameSettingsTouchMoveMoveChangeConn = UserGameSettings:GetPropertyChangedSignal("TouchMovementMode"):Connect(function()
		self:OnGameSettingsTouchMovementModeChanged()
	end)
	self:OnGameSettingsTouchMovementModeChanged() -- Init

	UserGameSettings:SetCameraYInvertVisible()
	UserGameSettings:SetGamepadCameraSensitivityVisible()

	self.hasGameLoaded = game:IsLoaded()
	if not self.hasGameLoaded then
		self.gameLoadedConn = game.Loaded:Connect(function()
			self.hasGameLoaded = true
			self.gameLoadedConn:Disconnect()
			self.gameLoadedConn = nil
		end)
	end

	return self
end

function BaseCamera:GetModuleName()
	return "BaseCamera"
end

function BaseCamera:OnCharacterAdded(char)
	if FFlagUserNewDefaultCameraAngle then
		self.resetCameraAngle = self.resetCameraAngle or self:GetEnabled()
		self.humanoidRootPart = nil
	end
	if UserInputService.TouchEnabled then
		self.PlayerGui = Players.LocalPlayer:WaitForChild("PlayerGui")
		for _, child in ipairs(char:GetChildren()) do
			if child:IsA("Tool") then
				self.isAToolEquipped = true
			end
		end
		char.ChildAdded:Connect(function(child)
			if child:IsA("Tool") then
				self.isAToolEquipped = true
			end
		end)
		char.ChildRemoved:Connect(function(child)
			if child:IsA("Tool") then
				self.isAToolEquipped = false
			end
		end)
	end
end

function BaseCamera:GetHumanoidRootPart()
	if not self.humanoidRootPart then
		local player = Players.LocalPlayer
		if player.Character then
			local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
			if humanoid then
				self.humanoidRootPart = humanoid.RootPart
			end
		end
	end
	return self.humanoidRootPart
end

function BaseCamera:GetBodyPartToFollow(humanoid, isDead)
	-- If the humanoid is dead, prefer the head part if one still exists as a sibling of the humanoid
	if humanoid:GetState() == Enum.HumanoidStateType.Dead then
		local character = humanoid.Parent
		if character and character:IsA("Model") then
			return character:FindFirstChild("Head") or humanoid.RootPart
		end
	end

	return humanoid.RootPart
end

function BaseCamera:GetSubjectPosition()
	local result = self.lastSubjectPosition
	local camera = game.Workspace.CurrentCamera
	local cameraSubject = camera and camera.CameraSubject

	if cameraSubject then
		if cameraSubject:IsA("Humanoid") then
			local humanoid = cameraSubject
			local humanoidIsDead = humanoid:GetState() == Enum.HumanoidStateType.Dead

			if VRService.VREnabled and humanoidIsDead and humanoid == self.lastSubject then
				result = self.lastSubjectPosition
			else
				local bodyPartToFollow = humanoid.RootPart

				-- If the humanoid is dead, prefer their head part as a follow target, if it exists
				if humanoidIsDead then
					if humanoid.Parent and humanoid.Parent:IsA("Model") then
						bodyPartToFollow = humanoid.Parent:FindFirstChild("Head") or bodyPartToFollow
					end
				end

				if bodyPartToFollow and bodyPartToFollow:IsA("BasePart") then
					local heightOffset = humanoid.RigType == Enum.HumanoidRigType.R15 and R15_HEAD_OFFSET or HEAD_OFFSET
					if humanoidIsDead then
						heightOffset = ZERO_VECTOR3
					end

					result = bodyPartToFollow.CFrame.p + bodyPartToFollow.CFrame:vectorToWorldSpace(heightOffset + humanoid.CameraOffset)
				end
			end

		elseif cameraSubject:IsA("VehicleSeat") then
			local offset = SEAT_OFFSET
			if VRService.VREnabled then
				offset = VR_SEAT_OFFSET
			end
			result = cameraSubject.CFrame.p + cameraSubject.CFrame:vectorToWorldSpace(offset)
		elseif cameraSubject:IsA("SkateboardPlatform") then
			result = cameraSubject.CFrame.p + SEAT_OFFSET
		elseif cameraSubject:IsA("BasePart") then
			result = cameraSubject.CFrame.p
		elseif cameraSubject:IsA("Model") then
			if cameraSubject.PrimaryPart then
				result = cameraSubject:GetPrimaryPartCFrame().p
			else
				result = cameraSubject:GetModelCFrame().p
			end
		end
	else
		-- cameraSubject is nil
		-- Note: Previous RootCamera did not have this else case and let self.lastSubject and self.lastSubjectPosition
		-- both get set to nil in the case of cameraSubject being nil. This function now exits here to preserve the
		-- last set valid values for these, as nil values are not handled cases
		return
	end

	self.lastSubject = cameraSubject
	self.lastSubjectPosition = result

	return result
end

function BaseCamera:UpdateDefaultSubjectDistance()
	local player = Players.LocalPlayer
	if self.portraitMode then
		self.defaultSubjectDistance = Util.Clamp(player.CameraMinZoomDistance, player.CameraMaxZoomDistance, PORTRAIT_DEFAULT_DISTANCE)
	else
		self.defaultSubjectDistance = Util.Clamp(player.CameraMinZoomDistance, player.CameraMaxZoomDistance, DEFAULT_DISTANCE)
	end
end

function BaseCamera:OnViewportSizeChanged()
	local camera = game.Workspace.CurrentCamera
	local size = camera.ViewportSize
	self.portraitMode = size.X < size.Y
	self.isSmallTouchScreen = UserInputService.TouchEnabled and (size.Y < 500 or size.X < 700)

	self:UpdateDefaultSubjectDistance()
end

-- Listener for changes to workspace.CurrentCamera
function BaseCamera:OnCurrentCameraChanged()
	if UserInputService.TouchEnabled then
		if self.viewportSizeChangedConn then
			self.viewportSizeChangedConn:Disconnect()
			self.viewportSizeChangedConn = nil
		end

		local newCamera = game.Workspace.CurrentCamera

		if newCamera then
			self:OnViewportSizeChanged()
			self.viewportSizeChangedConn = newCamera:GetPropertyChangedSignal("ViewportSize"):Connect(function()
				self:OnViewportSizeChanged()
			end)
		end
	end

	-- VR support additions
	if self.cameraSubjectChangedConn then
		self.cameraSubjectChangedConn:Disconnect()
		self.cameraSubjectChangedConn = nil
	end

	local camera = game.Workspace.CurrentCamera
	if camera then
		self.cameraSubjectChangedConn = camera:GetPropertyChangedSignal("CameraSubject"):Connect(function()
			self:OnNewCameraSubject()
		end)
		self:OnNewCameraSubject()
	end
end

function BaseCamera:OnDynamicThumbstickEnabled()
	if UserInputService.TouchEnabled then
		self.isDynamicThumbstickEnabled = true
	end
end

function BaseCamera:OnDynamicThumbstickDisabled()
	self.isDynamicThumbstickEnabled = false
end

function BaseCamera:OnGameSettingsTouchMovementModeChanged()
	if Players.LocalPlayer.DevTouchMovementMode == Enum.DevTouchMovementMode.UserChoice then
		if UserGameSettings.TouchMovementMode.Name == "DynamicThumbstick" then
			self:OnDynamicThumbstickEnabled()
		else
			self:OnDynamicThumbstickDisabled()
		end
	end
end

function BaseCamera:OnDevTouchMovementModeChanged()
	if Players.LocalPlayer.DevTouchMovementMode.Name == "DynamicThumbstick" then
		self:OnDynamicThumbstickEnabled()
	else
		self:OnGameSettingsTouchMovementModeChanged()
	end
end

function BaseCamera:OnPlayerCameraPropertyChange()
	-- This call forces re-evaluation of player.CameraMode and clamping to min/max distance which may have changed
	self:SetCameraToSubjectDistance(self.currentSubjectDistance)
end

function BaseCamera:GetCameraHeight()
	if VRService.VREnabled and not self.inFirstPerson then
		return math.sin(VR_ANGLE) * self.currentSubjectDistance
	end
	return 0
end

function BaseCamera:InputTranslationToCameraAngleChange(translationVector, sensitivity)
	local camera = game.Workspace.CurrentCamera
	if camera and camera.ViewportSize.X > 0 and camera.ViewportSize.Y > 0 and (camera.ViewportSize.Y > camera.ViewportSize.X) then
		-- Screen has portrait orientation, swap X and Y sensitivity
		return translationVector * Vector2.new( sensitivity.Y, sensitivity.X)
	end
	return translationVector * sensitivity
end

function BaseCamera:Enable(enable)
	if self.enabled ~= enable then
		self.enabled = enable
		if self.enabled then
			self:ConnectInputEvents()
			if FFlagPlayerScriptsBindAtPriority then
				self:BindContextActions()
			end

			if Players.LocalPlayer.CameraMode == Enum.CameraMode.LockFirstPerson then
				self.currentSubjectDistance = 0.5
				if not self.inFirstPerson then
					self:EnterFirstPerson()
				end
			end
		else
			self:DisconnectInputEvents()
			if FFlagPlayerScriptsBindAtPriority then
				self:UnbindContextActions()
			end
			-- Clean up additional event listeners and reset a bunch of properties
			self:Cleanup()
		end
	end
end

function BaseCamera:GetEnabled()
	return self.enabled
end

function BaseCamera:OnInputBegan(input, processed)
	if input.UserInputType == Enum.UserInputType.Touch then
		self:OnTouchBegan(input, processed)
	elseif input.UserInputType == Enum.UserInputType.MouseButton2 then
		self:OnMouse2Down(input, processed)
	elseif input.UserInputType == Enum.UserInputType.MouseButton3 then
		self:OnMouse3Down(input, processed)
	end
	-- Keyboard
	if not FFlagPlayerScriptsBindAtPriority then
		if input.UserInputType == Enum.UserInputType.Keyboard then
			self:OnKeyDown(input, processed)
		end
	end
end

function BaseCamera:OnInputChanged(input, processed)
	if input.UserInputType == Enum.UserInputType.Touch then
		self:OnTouchChanged(input, processed)
	elseif input.UserInputType == Enum.UserInputType.MouseMovement then
		self:OnMouseMoved(input, processed)
	elseif input.UserInputType == Enum.UserInputType.MouseWheel then
		self:OnMouseWheel(input, processed)
	end
end

function BaseCamera:OnInputEnded(input, processed)
	if input.UserInputType == Enum.UserInputType.Touch then
		self:OnTouchEnded(input, processed)
	elseif input.UserInputType == Enum.UserInputType.MouseButton2 then
		self:OnMouse2Up(input, processed)
	elseif input.UserInputType == Enum.UserInputType.MouseButton3 then
		self:OnMouse3Up(input, processed)
	end
	-- Keyboard
	if not FFlagPlayerScriptsBindAtPriority then
		if input.UserInputType == Enum.UserInputType.Keyboard then
			self:OnKeyUp(input, processed)
		end
	end
end

function BaseCamera:ConnectInputEvents()
	self.inputBeganConn = UserInputService.InputBegan:Connect(function(input, processed)
		self:OnInputBegan(input, processed)
	end)

	self.inputChangedConn = UserInputService.InputChanged:Connect(function(input, processed)
		self:OnInputChanged(input, processed)
	end)

	self.inputEndedConn = UserInputService.InputEnded:Connect(function(input, processed)
		self:OnInputEnded(input, processed)
	end)

	self.touchActivateConn = UserInputService.TouchTapInWorld:Connect(function(touchPos, processed)
		self:OnTouchTap(touchPos)
	end)

	self.menuOpenedConn = GuiService.MenuOpened:connect(function()
		self:ResetInputStates()
	end)

	self.gamepadConnectedConn = UserInputService.GamepadDisconnected:connect(function(gamepadEnum)
		if self.activeGamepad ~= gamepadEnum then return end
		self.activeGamepad = nil
		self:AssignActivateGamepad()
	end)

	self.gamepadDisconnectedConn = UserInputService.GamepadConnected:connect(function(gamepadEnum)
		if self.activeGamepad == nil then
			self:AssignActivateGamepad()
		end
	end)

	if not FFlagPlayerScriptsBindAtPriority then
		self:BindGamepadInputActions()
	end
	self:AssignActivateGamepad()
	self:UpdateMouseBehavior()
end

function BaseCamera:BindContextActions()
	self:BindGamepadInputActions()
	self:BindKeyboardInputActions()
end

function BaseCamera:AssignActivateGamepad()
	local connectedGamepads = UserInputService:GetConnectedGamepads()
	if #connectedGamepads > 0 then
		for i = 1, #connectedGamepads do
			if self.activeGamepad == nil then
				self.activeGamepad = connectedGamepads[i]
			elseif connectedGamepads[i].Value < self.activeGamepad.Value then
				self.activeGamepad = connectedGamepads[i]
			end
		end
	end

	if self.activeGamepad == nil then -- nothing is connected, at least set up for gamepad1
		self.activeGamepad = Enum.UserInputType.Gamepad1
	end
end

function BaseCamera:DisconnectInputEvents()
	if self.inputBeganConn then
		self.inputBeganConn:Disconnect()
		self.inputBeganConn = nil
	end
	if self.inputChangedConn then
		self.inputChangedConn:Disconnect()
		self.inputChangedConn = nil
	end
	if self.inputEndedConn then
		self.inputEndedConn:Disconnect()
		self.inputEndedConn = nil
	end
end

function BaseCamera:UnbindContextActions()
	for i = 1, #self.boundContextActions do
		ContextActionService:UnbindAction(self.boundContextActions[i])
	end 
	self.boundContextActions = {}
end

function BaseCamera:Cleanup()
	if self.menuOpenedConn then
		self.menuOpenedConn:Disconnect()
		self.menuOpenedConn = nil
	end
	if self.mouseLockToggleConn then
		self.mouseLockToggleConn:Disconnect()
		self.mouseLockToggleConn = nil
	end
	if self.gamepadConnectedConn then
		self.gamepadConnectedConn:Disconnect()
		self.gamepadConnectedConn = nil
	end
	if self.gamepadDisconnectedConn then
		self.gamepadDisconnectedConn:Disconnect()
		self.gamepadDisconnectedConn = nil
	end
	if self.subjectStateChangedConn then
		self.subjectStateChangedConn:Disconnect()
		self.subjectStateChangedConn = nil
	end
	if self.viewportSizeChangedConn then
		self.viewportSizeChangedConn:Disconnect()
		self.viewportSizeChangedConn = nil
	end
	if self.touchActivateConn then
		self.touchActivateConn:Disconnect()
		self.touchActivateConn = nil
	end

	self.turningLeft = false
	self.turningRight = false
	self.lastCameraTransform = nil
	self.lastSubjectCFrame = nil
	self.userPanningTheCamera = false
	self.rotateInput = Vector2.new()
	self.gamepadPanningCamera = Vector2.new(0,0)

	-- Reset input states
	self.startPos = nil
	self.lastPos = nil
	self.panBeginLook = nil
	self.isRightMouseDown = false
	self.isMiddleMouseDown = false

	self.fingerTouches = {}
	self.numUnsunkTouches = 0

	self.startingDiff = nil
	self.pinchBeginZoom = nil

	-- Unlock mouse for example if right mouse button was being held down
	if UserInputService.MouseBehavior ~= Enum.MouseBehavior.LockCenter then
		UserInputService.MouseBehavior = Enum.MouseBehavior.Default
	end
end

-- This is called when settings menu is opened
function BaseCamera:ResetInputStates()
	self.isRightMouseDown = false
	self.isMiddleMouseDown = false
	self:OnMousePanButtonReleased() -- this function doesn't seem to actually need parameters

	if UserInputService.TouchEnabled then
		--[[menu opening was causing serious touch issues
		this should disable all active touch events if
		they're active when menu opens.]]
		for inputObject in pairs(self.fingerTouches) do
			self.fingerTouches[inputObject] = nil
		end
		self.panBeginLook = nil
		self.startPos = nil
		self.lastPos = nil
		self.userPanningTheCamera = false
		self.startingDiff = nil
		self.pinchBeginZoom = nil
		self.numUnsunkTouches = 0
	end
end

function BaseCamera:GetGamepadPan(name, state, input)
	if input.UserInputType == self.activeGamepad and input.KeyCode == Enum.KeyCode.Thumbstick2 then
--		if self.L3ButtonDown then
--			-- L3 Thumbstick is depressed, right stick controls dolly in/out
--			if (input.Position.Y > THUMBSTICK_DEADZONE) then
--				self.currentZoomSpeed = 0.96
--			elseif (input.Position.Y < -THUMBSTICK_DEADZONE) then
--				self.currentZoomSpeed = 1.04
--			else 
--				self.currentZoomSpeed = 1.00
--			end
--		else
			if state == Enum.UserInputState.Cancel then
				self.gamepadPanningCamera = ZERO_VECTOR2
				return
			end

			local inputVector = Vector2.new(input.Position.X, -input.Position.Y)
			if inputVector.magnitude > THUMBSTICK_DEADZONE then
				self.gamepadPanningCamera = Vector2.new(input.Position.X, -input.Position.Y)
			else
				self.gamepadPanningCamera = ZERO_VECTOR2
			end
		--end
		if FFlagPlayerScriptsBindAtPriority then
			return Enum.ContextActionResult.Sink
		end
	end
	if FFlagPlayerScriptsBindAtPriority then
		return Enum.ContextActionResult.Pass
	end
end

function BaseCamera:DoKeyboardPanTurn(name, state, input)
	if not self.hasGameLoaded and VRService.VREnabled then
		return Enum.ContextActionResult.Pass
	end
	
	if state == Enum.UserInputState.Cancel then 
		self.turningLeft = false 
		self.turningRight = false
		return Enum.ContextActionResult.Sink
	end

	if self.panBeginLook == nil and self.keyPanEnabled then
		if input.KeyCode == Enum.KeyCode.Left then
			self.turningLeft = state == Enum.UserInputState.Begin
		elseif input.KeyCode == Enum.KeyCode.Right then
			self.turningRight = state == Enum.UserInputState.Begin
		end
		return Enum.ContextActionResult.Sink
	end
	return Enum.ContextActionResult.Pass
end

function BaseCamera:DoPanRotateCamera(rotateAngle)
	local angle = Util.RotateVectorByAngleAndRound(self:GetCameraLookVector() * Vector3.new(1,0,1), rotateAngle, math.pi*0.25)
	if angle ~= 0 then
		self.rotateInput = self.rotateInput + Vector2.new(angle, 0)
		self.lastUserPanCamera = tick()
		self.lastCameraTransform = nil
	end
end

function BaseCamera:DoKeyboardPan(name, state, input)
	if not self.hasGameLoaded and VRService.VREnabled then
		return Enum.ContextActionResult.Pass
	end
	
	if state ~= Enum.UserInputState.Begin then 
		return Enum.ContextActionResult.Pass
	end

	if self.panBeginLook == nil and self.keyPanEnabled then
		if input.KeyCode == Enum.KeyCode.Comma then
			self:DoPanRotateCamera(-math.pi*0.1875)
		elseif input.KeyCode == Enum.KeyCode.Period then
			self:DoPanRotateCamera(math.pi*0.1875)
		elseif input.KeyCode == Enum.KeyCode.PageUp then
			self.rotateInput = self.rotateInput + Vector2.new(0,math.rad(15))
			self.lastCameraTransform = nil
		elseif input.KeyCode == Enum.KeyCode.PageDown then
			self.rotateInput = self.rotateInput + Vector2.new(0,math.rad(-15))
			self.lastCameraTransform = nil
		end
		return Enum.ContextActionResult.Sink
	end
	return Enum.ContextActionResult.Pass
end

function BaseCamera:DoGamepadZoom(name, state, input)
	if input.UserInputType == self.activeGamepad then
		if input.KeyCode == Enum.KeyCode.ButtonR3 then
			if state == Enum.UserInputState.Begin then			
				if self.distanceChangeEnabled then
					if self:GetCameraToSubjectDistance() > 0.5 then
						self:SetCameraToSubjectDistance(0)
					else
						self:SetCameraToSubjectDistance(10)
					end
				end
			end
		elseif input.KeyCode == Enum.KeyCode.DPadLeft then
			self.dpadLeftDown = (state == Enum.UserInputState.Begin)
		elseif input.KeyCode == Enum.KeyCode.DPadRight then
			self.dpadRightDown = (state == Enum.UserInputState.Begin)
		end

		if self.dpadLeftDown then
			self.currentZoomSpeed = 1.04
		elseif self.dpadRightDown then
			self.currentZoomSpeed = 0.96
		else
			self.currentZoomSpeed = 1.00
		end
		if FFlagPlayerScriptsBindAtPriority then
			return Enum.ContextActionResult.Sink
		end
	end
	if FFlagPlayerScriptsBindAtPriority then
		return Enum.ContextActionResult.Pass
	end
--	elseif input.UserInputType == self.activeGamepad and input.KeyCode == Enum.KeyCode.ButtonL3 then
--		if (state == Enum.UserInputState.Begin) then
--			self.L3ButtonDown = true
--		elseif (state == Enum.UserInputState.End) then
--			self.L3ButtonDown = false
--			self.currentZoomSpeed = 1.00
--		end
--	end
end

function BaseCamera:DoKeyboardZoom(name, state, input)
	if not self.hasGameLoaded and VRService.VREnabled then
		return Enum.ContextActionResult.Pass
	end

	if state ~= Enum.UserInputState.Begin then 
		return Enum.ContextActionResult.Pass
	end

	if self.distanceChangeEnabled then
		if input.KeyCode == Enum.KeyCode.I then
			self:SetCameraToSubjectDistance( self.currentSubjectDistance - 5 )
		elseif input.KeyCode == Enum.KeyCode.O then
			self:SetCameraToSubjectDistance( self.currentSubjectDistance + 5 )
		end
		return Enum.ContextActionResult.Sink
	end
	return Enum.ContextActionResult.Pass
end

function BaseCamera:BindAction(actionName, actionFunc, createTouchButton, ...)
	table.insert(self.boundContextActions, actionName)
	ContextActionService:BindActionAtPriority(actionName, actionFunc, createTouchButton, 
		CAMERA_ACTION_PRIORITY, ...)
end

function BaseCamera:BindGamepadInputActions()
	if FFlagPlayerScriptsBindAtPriority then 
		self:BindAction("BaseCameraGamepadPan", function(name, state, input) return self:GetGamepadPan(name, state, input) end,
			false, Enum.KeyCode.Thumbstick2)
		self:BindAction("BaseCameraGamepadZoom", function(name, state, input) return self:DoGamepadZoom(name, state, input) end,
			false, Enum.KeyCode.DPadLeft, Enum.KeyCode.DPadRight, Enum.KeyCode.ButtonR3)
	else 
		ContextActionService:BindAction("RootCamGamepadPan", function(name, state, input) self:GetGamepadPan(name, state, input) end, false, Enum.KeyCode.Thumbstick2)
		ContextActionService:BindAction("RootCamGamepadZoom", function(name, state, input) self:DoGamepadZoom(name, state, input) end, false, Enum.KeyCode.ButtonR3)
		--ContextActionService:BindAction("RootGamepadZoomAlt", function(name, state, input) self:DoGamepadZoom(name, state, input) end, false, Enum.KeyCode.ButtonL3)
		ContextActionService:BindAction("RootGamepadZoomOut", function(name, state, input) self:DoGamepadZoom(name, state, input) end, false, Enum.KeyCode.DPadLeft)
		ContextActionService:BindAction("RootGamepadZoomIn", function(name, state, input) self:DoGamepadZoom(name, state, input) end, false, Enum.KeyCode.DPadRight)
	end
end

function BaseCamera:BindKeyboardInputActions()
	self:BindAction("BaseCameraKeyboardPanArrowKeys", function(name, state, input) return self:DoKeyboardPanTurn(name, state, input) end,
		false, Enum.KeyCode.Left, Enum.KeyCode.Right)
	self:BindAction("BaseCameraKeyboardPan", function(name, state, input) return self:DoKeyboardPan(name, state, input) end,
		false, Enum.KeyCode.Comma, Enum.KeyCode.Period, Enum.KeyCode.PageUp, Enum.KeyCode.PageDown)
	self:BindAction("BaseCameraKeyboardZoom", function(name, state, input) return self:DoKeyboardZoom(name, state, input) end,
		false, Enum.KeyCode.I, Enum.KeyCode.O)
end

function BaseCamera:OnTouchBegan(input, processed)
	local canUseDynamicTouch = self.isDynamicThumbstickEnabled and not processed
	if canUseDynamicTouch then
		self.fingerTouches[input] = processed
		if not processed then
			self.inputStartPositions[input] = input.Position
			self.inputStartTimes[input] = tick()
			self.numUnsunkTouches = self.numUnsunkTouches + 1
		end
	end
end

function BaseCamera:OnTouchChanged(input, processed)
	if self.fingerTouches[input] == nil then
		if self.isDynamicThumbstickEnabled then
			return
		end
		self.fingerTouches[input] = processed
		if not processed then
			self.numUnsunkTouches = self.numUnsunkTouches + 1
		end
	end

	if self.numUnsunkTouches == 1 then
		if self.fingerTouches[input] == false then
			self.panBeginLook = self.panBeginLook or self:GetCameraLookVector()
			self.startPos = self.startPos or input.Position
			self.lastPos = self.lastPos or self.startPos
			self.userPanningTheCamera = true

			local delta = input.Position - self.lastPos
			delta = Vector2.new(delta.X, delta.Y * UserGameSettings:GetCameraYInvertValue())
			if self.panEnabled then
				local desiredXYVector = self:InputTranslationToCameraAngleChange(delta, TOUCH_SENSITIVTY)
				self.rotateInput = self.rotateInput + desiredXYVector
			end
			self.lastPos = input.Position
		end
	else
		self.panBeginLook = nil
		self.startPos = nil
		self.lastPos = nil
		self.userPanningTheCamera = false
	end
	if self.numUnsunkTouches == 2 then
		local unsunkTouches = {}
		for touch, wasSunk in pairs(self.fingerTouches) do
			if not wasSunk then
				table.insert(unsunkTouches, touch)
			end
		end
		if #unsunkTouches == 2 then
			local difference = (unsunkTouches[1].Position - unsunkTouches[2].Position).magnitude
			if self.startingDiff and self.pinchBeginZoom then
				local scale = difference / math.max(0.01, self.startingDiff)
				local clampedScale = Util.Clamp(0.1, 10, scale)
				if self.distanceChangeEnabled then
					self:SetCameraToSubjectDistance(self.pinchBeginZoom / clampedScale)
				end
			else
				self.startingDiff = difference
				self.pinchBeginZoom = self:GetCameraToSubjectDistance()
			end
		end
	else
		self.startingDiff = nil
		self.pinchBeginZoom = nil
	end	
end

function BaseCamera:CalcLookBehindRotateInput()
	if not self.humanoidRootPart or not game.Workspace.CurrentCamera then
		return nil
	end

	local cameraLookVector = game.Workspace.CurrentCamera.CFrame.lookVector
	local newDesiredLook = (self.humanoidRootPart.CFrame.lookVector - Vector3.new(0,0.23,0)).unit
	local horizontalShift = Util.GetAngleBetweenXZVectors(newDesiredLook, cameraLookVector)
	local vertShift = math.asin(cameraLookVector.Y) - math.asin(newDesiredLook.Y)
	if not Util.IsFinite(horizontalShift) then
		horizontalShift = 0
	end
	if not Util.IsFinite(vertShift) then
		vertShift = 0
	end

	return Vector2.new(horizontalShift, vertShift)
end

function BaseCamera:OnTouchTap(position)
	if self.isDynamicThumbstickEnabled and not self.isAToolEquipped then
		if self.lastTapTime and tick() - self.lastTapTime < MAX_TIME_FOR_DOUBLE_TAP then
			self:SetCameraToSubjectDistance(self.defaultSubjectDistance)
		else
			if self.humanoidRootPart then
				self.rotateInput = self:CalcLookBehindRotateInput()
			end
		end
		self.lastTapTime = tick()
	end
end

function BaseCamera:IsTouchTap(input)
	-- We can't make the assumption that the input exists in the inputStartPositions because we may have switched from a different camera type.
	if self.inputStartPositions[input] then
		local posDelta = (self.inputStartPositions[input] - input.Position).magnitude
		if posDelta < MAX_TAP_POS_DELTA then
			local timeDelta = self.inputStartTimes[input] - tick()
			if timeDelta < MAX_TAP_TIME_DELTA then
				return true
			end
		end
	end
	return false
end

function BaseCamera:OnTouchEnded(input, processed)
	if self.fingerTouches[input] == false then
		if self.numUnsunkTouches == 1 then
			self.panBeginLook = nil
			self.startPos = nil
			self.lastPos = nil
			self.userPanningTheCamera = false
			if self:IsTouchTap(input) then
				self:OnTouchTap(input.Position)
			end
		elseif self.numUnsunkTouches == 2 then
			self.startingDiff = nil
			self.pinchBeginZoom = nil
		end
	end

	if self.fingerTouches[input] ~= nil and self.fingerTouches[input] == false then
		self.numUnsunkTouches = self.numUnsunkTouches - 1
	end
	self.fingerTouches[input] = nil
	self.inputStartPositions[input] = nil
	self.inputStartTimes[input] = nil
end

function BaseCamera:OnMouse2Down(input, processed)
	if processed then return end

	self.isRightMouseDown = true
	self:OnMousePanButtonPressed(input, processed)
end

function BaseCamera:OnMouse2Up(input, processed)
	self.isRightMouseDown = false
	self:OnMousePanButtonReleased(input, processed)
end

function BaseCamera:OnMouse3Down(input, processed)
	if processed then return end

	self.isMiddleMouseDown = true
	self:OnMousePanButtonPressed(input, processed)
end

function BaseCamera:OnMouse3Up(input, processed)
	self.isMiddleMouseDown = false
	self:OnMousePanButtonReleased(input, processed)
end

function BaseCamera:OnMouseMoved(input, processed)
	if not self.hasGameLoaded and VRService.VREnabled then
		return
	end

	local inputDelta = input.Delta
	inputDelta = Vector2.new(inputDelta.X, inputDelta.Y * UserGameSettings:GetCameraYInvertValue())

	if self.panEnabled and ((self.startPos and self.lastPos and self.panBeginLook) or self.inFirstPerson or self.inMouseLockedMode) then
		local desiredXYVector = self:InputTranslationToCameraAngleChange(inputDelta,MOUSE_SENSITIVITY)
		self.rotateInput = self.rotateInput + desiredXYVector
	end

	if self.startPos and self.lastPos and self.panBeginLook then
		self.lastPos = self.lastPos + input.Delta
	end
end

function BaseCamera:OnMousePanButtonPressed(input, processed)
	if processed then return end
	self:UpdateMouseBehavior()
	self.panBeginLook = self.panBeginLook or self:GetCameraLookVector()
	self.startPos = self.startPos or input.Position
	self.lastPos = self.lastPos or self.startPos
	self.userPanningTheCamera = true
end

function BaseCamera:OnMousePanButtonReleased(input, processed)
	self:UpdateMouseBehavior()
	if not (self.isRightMouseDown or self.isMiddleMouseDown) then
		self.panBeginLook = nil
		self.startPos = nil
		self.lastPos = nil
		self.userPanningTheCamera = false
	end
end

function BaseCamera:OnMouseWheel(input, processed)
	if not self.hasGameLoaded and VRService.VREnabled then
		return
	end
	if not processed then
		if self.distanceChangeEnabled then
			local wheelInput = Util.Clamp(-1, 1, -input.Position.Z)

			local newDistance
			if self.inFirstPerson and wheelInput > 0 then
				newDistance = FIRST_PERSON_DISTANCE_THRESHOLD
			else
				-- The 0.156 and 1.7 values are the slope and intercept of a line that is replacing the old
				-- rk4Integrator function which was not being used as an integrator, only to get a delta as a function of distance,
				-- which was linear as it was being used. These constants preserve the status quo behavior.
				newDistance = self.currentSubjectDistance + 0.156 * self.currentSubjectDistance * wheelInput + 1.7 * math.sign(wheelInput)
			end

			self:SetCameraToSubjectDistance(newDistance)
		end
	end
end

--Remove with FFlagPlayerScriptsBindAtPriority
function BaseCamera:OnKeyDown(input, processed)
	if not self.hasGameLoaded and VRService.VREnabled then
		return
	end

	if processed then
		return
	end

	if self.distanceChangeEnabled then
		if input.KeyCode == Enum.KeyCode.I then
			self:SetCameraToSubjectDistance( self.currentSubjectDistance - 5 )
		elseif input.KeyCode == Enum.KeyCode.O then
			self:SetCameraToSubjectDistance( self.currentSubjectDistance + 5 )
		end
	end

	if self.panBeginLook == nil and self.keyPanEnabled then
		if input.KeyCode == Enum.KeyCode.Left then
			self.turningLeft = true
		elseif input.KeyCode == Enum.KeyCode.Right then
			self.turningRight = true
		elseif input.KeyCode == Enum.KeyCode.Comma then
			local angle = Util.RotateVectorByAngleAndRound(self:GetCameraLookVector() * Vector3.new(1,0,1), -math.pi*0.1875, math.pi*0.25)
			if angle ~= 0 then
				self.rotateInput = self.rotateInput + Vector2.new(angle, 0)
				self.lastUserPanCamera = tick()
				self.lastCameraTransform = nil
			end
		elseif input.KeyCode == Enum.KeyCode.Period then
			local angle = Util.RotateVectorByAngleAndRound(self:GetCameraLookVector() * Vector3.new(1,0,1), math.pi*0.1875, math.pi*0.25)
			if angle ~= 0 then
				self.rotateInput = self.rotateInput + Vector2.new(angle, 0)
				self.lastUserPanCamera = tick()
				self.lastCameraTransform = nil
			end
		elseif input.KeyCode == Enum.KeyCode.PageUp then
			self.rotateInput = self.rotateInput + Vector2.new(0,math.rad(15))
			self.lastCameraTransform = nil
		elseif input.KeyCode == Enum.KeyCode.PageDown then
			self.rotateInput = self.rotateInput + Vector2.new(0,math.rad(-15))
			self.lastCameraTransform = nil
		end
	end
end

--Remove with FFlagPlayerScriptsBindAtPriority
function BaseCamera:OnKeyUp(input, processed)
	if input.KeyCode == Enum.KeyCode.Left then
		self.turningLeft = false
	elseif input.KeyCode == Enum.KeyCode.Right then
		self.turningRight = false
	end
end

function BaseCamera:UpdateMouseBehavior()
	-- first time transition to first person mode or mouse-locked third person
	if self.inFirstPerson or self.inMouseLockedMode then
		UserGameSettings.RotationType = Enum.RotationType.CameraRelative
		UserInputService.MouseBehavior = Enum.MouseBehavior.LockCenter
	else
		UserGameSettings.RotationType = Enum.RotationType.MovementRelative
		if self.isRightMouseDown or self.isMiddleMouseDown then
			UserInputService.MouseBehavior = Enum.MouseBehavior.LockCurrentPosition
		else
			UserInputService.MouseBehavior = Enum.MouseBehavior.Default
		end
	end
end

function BaseCamera:UpdateForDistancePropertyChange()
	-- Calling this setter with the current value will force checking that it is still
	-- in range after a change to the min/max distance limits
	self:SetCameraToSubjectDistance(self.currentSubjectDistance)
end

function BaseCamera:SetCameraToSubjectDistance(desiredSubjectDistance)
	local player = Players.LocalPlayer

	local lastSubjectDistance = self.currentSubjectDistance

	-- By default, camera modules will respect LockFirstPerson and override the currentSubjectDistance with 0
	-- regardless of what Player.CameraMinZoomDistance is set to, so that first person can be made
	-- available by the developer without needing to allow players to mousewheel dolly into first person.
	-- Some modules will override this function to remove or change first-person capability.
	if player.CameraMode == Enum.CameraMode.LockFirstPerson then
		self.currentSubjectDistance = 0.5
		if not self.inFirstPerson then
			self:EnterFirstPerson()
		end
	else
		local newSubjectDistance = Util.Clamp(player.CameraMinZoomDistance, player.CameraMaxZoomDistance, desiredSubjectDistance)
		if newSubjectDistance < FIRST_PERSON_DISTANCE_THRESHOLD then
			self.currentSubjectDistance = 0.5
			if not self.inFirstPerson then
				self:EnterFirstPerson()
			end
		else
			self.currentSubjectDistance = newSubjectDistance
			if self.inFirstPerson then
				self:LeaveFirstPerson()
			end
		end
	end

	-- Pass target distance and zoom direction to the zoom controller
	ZoomController.SetZoomParameters(self.currentSubjectDistance, math.sign(desiredSubjectDistance - lastSubjectDistance))

	-- Returned only for convenience to the caller to know the outcome
	return self.currentSubjectDistance
end

function BaseCamera:SetCameraType( cameraType )
	--Used by derived classes
	self.cameraType = cameraType
end

function BaseCamera:GetCameraType()
	return self.cameraType
end

-- Movement mode standardized to Enum.ComputerCameraMovementMode values
function BaseCamera:SetCameraMovementMode( cameraMovementMode )
	self.cameraMovementMode = cameraMovementMode
end

function BaseCamera:GetCameraMovementMode()
	return self.cameraMovementMode
end

function BaseCamera:SetIsMouseLocked(mouseLocked)
	self.inMouseLockedMode = mouseLocked
	self:UpdateMouseBehavior()
end

function BaseCamera:GetIsMouseLocked()
	return self.inMouseLockedMode
end

function BaseCamera:SetMouseLockOffset(offsetVector)
	self.mouseLockOffset = offsetVector
end

function BaseCamera:GetMouseLockOffset()
	return self.mouseLockOffset
end

function BaseCamera:InFirstPerson()
	return self.inFirstPerson
end

function BaseCamera:EnterFirstPerson()
	-- Overridden in ClassicCamera, the only module which supports FirstPerson
end

function BaseCamera:LeaveFirstPerson()
	-- Overridden in ClassicCamera, the only module which supports FirstPerson
end

-- Nominal distance, set by dollying in and out with the mouse wheel or equivalent, not measured distance
function BaseCamera:GetCameraToSubjectDistance()
	return self.currentSubjectDistance
end

-- Actual measured distance to the camera Focus point, which may be needed in special circumstances, but should
-- never be used as the starting point for updating the nominal camera-to-subject distance (self.currentSubjectDistance)
-- since that is a desired target value set only by mouse wheel (or equivalent) input, PopperCam, and clamped to min max camera distance
function BaseCamera:GetMeasuredDistanceToFocus()
	local camera = game.Workspace.CurrentCamera
	if camera then
		return (camera.CoordinateFrame.p - camera.Focus.p).magnitude
	end
	return nil
end

function BaseCamera:GetCameraLookVector()
	return game.Workspace.CurrentCamera and game.Workspace.CurrentCamera.CFrame.lookVector or UNIT_Z
end

-- Replacements for RootCamera:RotateCamera() which did not actually rotate the camera
-- suppliedLookVector is not normally passed in, it's used only by Watch camera
function BaseCamera:CalculateNewLookCFrame(suppliedLookVector)
	local currLookVector = suppliedLookVector or self:GetCameraLookVector()
	local currPitchAngle = math.asin(currLookVector.y)
	local yTheta = Util.Clamp(-MAX_Y + currPitchAngle, -MIN_Y + currPitchAngle, self.rotateInput.y)
	local constrainedRotateInput = Vector2.new(self.rotateInput.x, yTheta)
	local startCFrame = CFrame.new(ZERO_VECTOR3, currLookVector)
	local newLookCFrame = CFrame.Angles(0, -constrainedRotateInput.x, 0) * startCFrame * CFrame.Angles(-constrainedRotateInput.y,0,0)
	return newLookCFrame
end
function BaseCamera:CalculateNewLookVector(suppliedLookVector)
	local newLookCFrame = self:CalculateNewLookCFrame(suppliedLookVector)
	return newLookCFrame.lookVector
end

function BaseCamera:CalculateNewLookVectorVR()
	local subjectPosition = self:GetSubjectPosition()
	local vecToSubject = (subjectPosition - game.Workspace.CurrentCamera.CFrame.p)
	local currLookVector = (vecToSubject * X1_Y0_Z1).unit
	local vrRotateInput = Vector2.new(self.rotateInput.x, 0)
	local startCFrame = CFrame.new(ZERO_VECTOR3, currLookVector)
	local yawRotatedVector = (CFrame.Angles(0, -vrRotateInput.x, 0) * startCFrame * CFrame.Angles(-vrRotateInput.y,0,0)).lookVector
	return (yawRotatedVector * X1_Y0_Z1).unit
end

function BaseCamera:GetHumanoid()
	local player = Players.LocalPlayer
	local character = player and player.Character
	if character then
		local resultHumanoid = self.humanoidCache[player]
		if resultHumanoid and resultHumanoid.Parent == character then
			return resultHumanoid
		else
			self.humanoidCache[player] = nil -- Bust Old Cache
			local humanoid = character:FindFirstChildOfClass("Humanoid")
			if humanoid then
				self.humanoidCache[player] = humanoid
			end
			return humanoid
		end
	end
	return nil
end

function BaseCamera:GetHumanoidPartToFollow(humanoid, humanoidStateType)
	if humanoidStateType == Enum.HumanoidStateType.Dead then
		local character = humanoid.Parent
		if character then
			return character:FindFirstChild("Head") or humanoid.Torso
		else
			return humanoid.Torso
		end
	else
		return humanoid.Torso
	end
end

function BaseCamera:UpdateGamepad()
	local gamepadPan = self.gamepadPanningCamera
	if gamepadPan and (self.hasGameLoaded or not VRService.VREnabled) then
		gamepadPan = Util.GamepadLinearToCurve(gamepadPan)
		local currentTime = tick()
		if gamepadPan.X ~= 0 or gamepadPan.Y ~= 0 then
			self.userPanningTheCamera = true
		elseif gamepadPan == ZERO_VECTOR2 then
			self.lastThumbstickRotate = nil
			if self.lastThumbstickPos == ZERO_VECTOR2 then
				self.currentSpeed = 0
			end
		end

		local finalConstant = 0

		if self.lastThumbstickRotate then
			if VRService.VREnabled then
				self.currentSpeed = self.vrMaxSpeed
			else
				local elapsedTime = (currentTime - self.lastThumbstickRotate) * 10
				self.currentSpeed = self.currentSpeed + (self.maxSpeed * ((elapsedTime*elapsedTime)/self.numOfSeconds))

				if self.currentSpeed > self.maxSpeed then self.currentSpeed = self.maxSpeed end

				if self.lastVelocity then
					local velocity = (gamepadPan - self.lastThumbstickPos)/(currentTime - self.lastThumbstickRotate)
					local velocityDeltaMag = (velocity - self.lastVelocity).magnitude

					if velocityDeltaMag > 12 then
						self.currentSpeed = self.currentSpeed * (20/velocityDeltaMag)
						if self.currentSpeed > self.maxSpeed then self.currentSpeed = self.maxSpeed end
					end
				end
			end

			finalConstant = UserGameSettings.GamepadCameraSensitivity * self.currentSpeed
			self.lastVelocity = (gamepadPan - self.lastThumbstickPos)/(currentTime - self.lastThumbstickRotate)
		end

		self.lastThumbstickPos = gamepadPan
		self.lastThumbstickRotate = currentTime

		return Vector2.new( gamepadPan.X * finalConstant, gamepadPan.Y * finalConstant * self.ySensitivity * UserGameSettings:GetCameraYInvertValue())
	end

	return ZERO_VECTOR2
end

-- [[ VR Support Section ]] --

function BaseCamera:ApplyVRTransform()
	if not VRService.VREnabled then
		return
	end

	--we only want this to happen in first person VR
	local rootJoint = self.humanoidRootPart and self.humanoidRootPart:FindFirstChild("RootJoint")
	if not rootJoint then
		return
	end

	local cameraSubject = game.Workspace.CurrentCamera.CameraSubject
	local isInVehicle = cameraSubject and cameraSubject:IsA("VehicleSeat")

	if self.inFirstPerson and not isInVehicle then
		local vrFrame = VRService:GetUserCFrame(Enum.UserCFrame.Head)
		local vrRotation = vrFrame - vrFrame.p
		rootJoint.C0 = CFrame.new(vrRotation:vectorToObjectSpace(vrFrame.p)) * CFrame.new(0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 1, 0)
	else
		rootJoint.C0 = CFrame.new(0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 1, 0)
	end
end

function BaseCamera:IsInFirstPerson()
	return self.inFirstPerson
end

function BaseCamera:ShouldUseVRRotation()
	if not VRService.VREnabled then
		return false
	end

	if not self.VRRotationIntensityAvailable and tick() - self.lastVRRotationIntensityCheckTime < 1 then
		return false
	end

	local success, vrRotationIntensity = pcall(function() return StarterGui:GetCore("VRRotationIntensity") end)
	self.VRRotationIntensityAvailable = success and vrRotationIntensity ~= nil
	self.lastVRRotationIntensityCheckTime = tick()

	self.shouldUseVRRotation = success and vrRotationIntensity ~= nil and vrRotationIntensity ~= "Smooth"

	return self.shouldUseVRRotation
end

function BaseCamera:GetVRRotationInput()
	local vrRotateSum = ZERO_VECTOR2
	local success, vrRotationIntensity = pcall(function() return StarterGui:GetCore("VRRotationIntensity") end)

	if not success then
		return
	end

	local vrGamepadRotation = self.GamepadPanningCamera or ZERO_VECTOR2
	local delayExpired = (tick() - self.lastVRRotationTime) >= self:GetRepeatDelayValue(vrRotationIntensity)

	if math.abs(vrGamepadRotation.x) >= self:GetActivateValue() then
		if (delayExpired or not self.vrRotateKeyCooldown[Enum.KeyCode.Thumbstick2]) then
			local sign = 1
			if vrGamepadRotation.x < 0 then
				sign = -1
			end
			vrRotateSum = vrRotateSum + self:GetRotateAmountValue(vrRotationIntensity) * sign
			self.vrRotateKeyCooldown[Enum.KeyCode.Thumbstick2] = true
		end
	elseif math.abs(vrGamepadRotation.x) < self:GetActivateValue() - 0.1 then
		self.vrRotateKeyCooldown[Enum.KeyCode.Thumbstick2] = nil
	end
	if self.turningLeft then
		if delayExpired or not self.vrRotateKeyCooldown[Enum.KeyCode.Left] then
			vrRotateSum = vrRotateSum - self:GetRotateAmountValue(vrRotationIntensity)
			self.vrRotateKeyCooldown[Enum.KeyCode.Left] = true
		end
	else
		self.vrRotateKeyCooldown[Enum.KeyCode.Left] = nil
	end
	if self.turningRight then
		if (delayExpired or not self.vrRotateKeyCooldown[Enum.KeyCode.Right]) then
			vrRotateSum = vrRotateSum + self:GetRotateAmountValue(vrRotationIntensity)
			self.vrRotateKeyCooldown[Enum.KeyCode.Right] = true
		end
	else
		self.vrRotateKeyCooldown[Enum.KeyCode.Right] = nil
	end

	if vrRotateSum ~= ZERO_VECTOR2 then
		self.lastVRRotationTime = tick()
	end

	return vrRotateSum
end

function BaseCamera:CancelCameraFreeze(keepConstraints)
	if not keepConstraints then
		self.cameraTranslationConstraints = Vector3.new(self.cameraTranslationConstraints.x, 1, self.cameraTranslationConstraints.z)
	end
	if self.cameraFrozen then
		self.trackingHumanoid = nil
		self.cameraFrozen = false
	end
end

function BaseCamera:StartCameraFreeze(subjectPosition, humanoidToTrack)
	if not self.cameraFrozen then
		self.humanoidJumpOrigin = subjectPosition
		self.trackingHumanoid = humanoidToTrack
		self.cameraTranslationConstraints = Vector3.new(self.cameraTranslationConstraints.x, 0, self.cameraTranslationConstraints.z)
		self.cameraFrozen = true
	end
end

function BaseCamera:RescaleCameraOffset(newScaleFactor)
	self.headHeightR15 = R15_HEAD_OFFSET * newScaleFactor
end

function BaseCamera:OnHumanoidSubjectChildAdded(child)
	if child.Name == "BodyHeightScale" and child:IsA("NumberValue") then
		if self.heightScaleChangedConn then
			self.heightScaleChangedConn:Disconnect()
		end
		self.heightScaleChangedConn = child.Changed:Connect(function(newScaleFactor)
			self:RescaleCameraOffset(newScaleFactor)
		end)
		self:RescaleCameraOffset(child.Value)
	end
end

function BaseCamera:OnHumanoidSubjectChildRemoved(child)
	if child.Name == "BodyHeightScale" then
		self:RescaleCameraOffset(1)
		if self.heightScaleChangedConn then
			self.heightScaleChangedConn:Disconnect()
			self.heightScaleChangedConn = nil
		end
	end
end

function BaseCamera:OnNewCameraSubject()
	if self.subjectStateChangedConn then
		self.subjectStateChangedConn:Disconnect()
		self.subjectStateChangedConn = nil
	end
	if self.humanoidChildAddedConn then
		self.humanoidChildAddedConn:Disconnect()
		self.humanoidChildAddedConn = nil
	end
	if self.humanoidChildRemovedConn then
		self.humanoidChildRemovedConn:Disconnect()
		self.humanoidChildRemovedConn = nil
	end
	if self.heightScaleChangedConn then
		self.heightScaleChangedConn:Disconnect()
		self.heightScaleChangedConn = nil
	end

	local humanoid = workspace.CurrentCamera and workspace.CurrentCamera.CameraSubject
	if self.trackingHumanoid ~= humanoid then
		self:CancelCameraFreeze()
	end
	if humanoid and humanoid:IsA("Humanoid") then
		self.humanoidChildAddedConn = humanoid.ChildAdded:Connect(function(child)
			self:OnHumanoidSubjectChildAdded(child)
		end)
		self.humanoidChildRemovedConn = humanoid.ChildRemoved:Connect(function(child)
			self:OnHumanoidSubjectChildRemoved(child)
		end)
		for _, child in pairs(humanoid:GetChildren()) do
			self:OnHumanoidSubjectChildAdded(child)
		end

		self.subjectStateChangedConn = humanoid.StateChanged:Connect(function(oldState, newState)
			if VRService.VREnabled and newState == Enum.HumanoidStateType.Jumping and not self.inFirstPerson then
				self:StartCameraFreeze(self:GetSubjectPosition(), humanoid)
			elseif newState ~= Enum.HumanoidStateType.Jumping and newState ~= Enum.HumanoidStateType.Freefall then
				self:CancelCameraFreeze(true)
			end
		end)
	end
end

function BaseCamera:GetVRFocus(subjectPosition, timeDelta)
	local lastFocus = self.LastCameraFocus or subjectPosition
	if not self.cameraFrozen then
		self.cameraTranslationConstraints = Vector3.new(self.cameraTranslationConstraints.x, math.min(1, self.cameraTranslationConstraints.y + 0.42 * timeDelta), self.cameraTranslationConstraints.z)
	end

	local newFocus
	if self.cameraFrozen and self.humanoidJumpOrigin and self.humanoidJumpOrigin.y > lastFocus.y then
		newFocus = CFrame.new(Vector3.new(subjectPosition.x, math.min(self.humanoidJumpOrigin.y, lastFocus.y + 5 * timeDelta), subjectPosition.z))
	else
		newFocus = CFrame.new(Vector3.new(subjectPosition.x, lastFocus.y, subjectPosition.z):lerp(subjectPosition, self.cameraTranslationConstraints.y))
	end

	if self.cameraFrozen then
		-- No longer in 3rd person
		if self.inFirstPerson then -- not VRService.VREnabled
			self:CancelCameraFreeze()
		end
		-- This case you jumped off a cliff and want to keep your character in view
		-- 0.5 is to fix floating point error when not jumping off cliffs
		if self.humanoidJumpOrigin and subjectPosition.y < (self.humanoidJumpOrigin.y - 0.5) then
			self:CancelCameraFreeze()
		end
	end

	return newFocus
end

function BaseCamera:GetRotateAmountValue(vrRotationIntensity)
	vrRotationIntensity = vrRotationIntensity or StarterGui:GetCore("VRRotationIntensity")
	if vrRotationIntensity then
		if vrRotationIntensity == "Low" then
			return VR_LOW_INTENSITY_ROTATION
		elseif vrRotationIntensity == "High" then
			return VR_HIGH_INTENSITY_ROTATION
		end
	end
	return ZERO_VECTOR2
end

function BaseCamera:GetRepeatDelayValue(vrRotationIntensity)
	vrRotationIntensity = vrRotationIntensity or StarterGui:GetCore("VRRotationIntensity")
	if vrRotationIntensity then
		if vrRotationIntensity == "Low" then
			return VR_LOW_INTENSITY_REPEAT
		elseif vrRotationIntensity == "High" then
			return VR_HIGH_INTENSITY_REPEAT
		end
	end
	return 0
end

function BaseCamera:Test()
	print("BaseCamera:Test()")
end

function BaseCamera:Update(dt)
	warn("BaseCamera:Update() This is a virtual function that should never be getting called.")
	return game.Workspace.CurrentCamera.CFrame, game.Workspace.CurrentCamera.Focus
end

return BaseCamera
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX733B083D8BAF4D1AA4313C37556AAB7D">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Poppercam_Classic</string>
							<string name="ScriptGuid">{57BE156F-CAD3-4AC0-BD73-A71D64C60027}</string>
							<ProtectedString name="Source"><![CDATA[--[[
	Poppercam - Occlusion module that brings the camera closer to the subject when objects are blocking the view
	Refactored for 2018 Camera Update but functionality is unchanged - AllYourBlox		
--]]

--[[ Camera Maths Utilities Library ]]--
local Util = require(script.Parent:WaitForChild("CameraUtils"))

local PlayersService = game:GetService("Players")
local POP_RESTORE_RATE = 0.3
local MIN_CAMERA_ZOOM = 0.5
local VALID_SUBJECTS = {
	'Humanoid',
	'VehicleSeat',
	'SkateboardPlatform',
}

local portraitPopperFixFlagExists, portraitPopperFixFlagEnabled = pcall(function()
	return UserSettings():IsUserFeatureEnabled("UserPortraitPopperFix")
end)
local FFlagUserPortraitPopperFix = portraitPopperFixFlagExists and portraitPopperFixFlagEnabled


--[[ The Module ]]--
local BaseOcclusion = require(script.Parent:WaitForChild("BaseOcclusion"))
local Poppercam = setmetatable({}, BaseOcclusion)
Poppercam.__index = Poppercam

function Poppercam.new()
	local self = setmetatable(BaseOcclusion.new(), Poppercam)
	
	self.camera = nil
	self.cameraSubjectChangeConn = nil
	
	self.subjectPart = nil
	
	self.playerCharacters = {} 	-- For ignoring in raycasts
	self.vehicleParts = {} 		-- Also just for ignoring
	
	self.lastPopAmount = 0
	self.lastZoomLevel = 0
	self.popperEnabled = false
	
	return self
end

function Poppercam:GetOcclusionMode()
	return Enum.DevCameraOcclusionMode.Zoom
end

function Poppercam:Enable(enable)
	
end

-- Called when character is added
function Poppercam:CharacterAdded(char, player)
	self.playerCharacters[player] = char
end

-- Called when character is about to be removed
function Poppercam:CharacterRemoving(char, player)
	self.playerCharacters[player] = nil
end

function Poppercam:Update(dt, desiredCameraCFrame, desiredCameraFocus)
	if self.popperEnabled then
		self.camera = game.Workspace.CurrentCamera
		local newCameraCFrame = desiredCameraCFrame
		local focusPoint = desiredCameraFocus.p

		if FFlagUserPortraitPopperFix and self.subjectPart then
			focusPoint = self.subjectPart.CFrame.p
		end

		local ignoreList = {}
		for _, character in pairs(self.playerCharacters) do
			ignoreList[#ignoreList + 1] = character
		end
		for i = 1, #self.vehicleParts do
			ignoreList[#ignoreList + 1] = self.vehicleParts[i]
		end
		
		-- Get largest cutoff distance
		-- Note that the camera CFrame must be set here, because the current implementation of GetLargestCutoffDistance
		-- uses the current camera CFrame directly (it cannot yet be passed the desiredCameraCFrame).
		local prevCameraCFrame = self.camera.CFrame
		self.camera.CFrame = desiredCameraCFrame
		self.camera.Focus = desiredCameraFocus
		local largest = self.camera:GetLargestCutoffDistance(ignoreList)

		-- Then check if the player zoomed since the last frame,
		-- and if so, reset our pop history so we stop tweening
		local zoomLevel = (desiredCameraCFrame.p - focusPoint).Magnitude
		if math.abs(zoomLevel - self.lastZoomLevel) > 0.001 then
			self.lastPopAmount = 0
		end
		
		-- Finally, zoom the camera in (pop) by that most-cut-off amount, or the last pop amount if that's more
		local popAmount = largest
		if self.lastPopAmount > popAmount then
			popAmount = self.lastPopAmount
		end

		if popAmount > 0 then
			newCameraCFrame = desiredCameraCFrame + (desiredCameraCFrame.lookVector * popAmount)
			self.lastPopAmount = popAmount - POP_RESTORE_RATE -- Shrink it for the next frame
			if self.lastPopAmount < 0 then
				self.lastPopAmount = 0
			end
		end

		self.lastZoomLevel = zoomLevel
		
		-- Stop shift lock being able to see through walls by manipulating Camera focus inside the wall
--		if EnabledCamera and EnabledCamera:GetShiftLock() and not EnabledCamera:IsInFirstPerson() then
--			if EnabledCamera:GetCameraActualZoom() < 1 then
--				local subjectPosition = EnabledCamera.lastSubjectPosition 
--				if subjectPosition then
--					Camera.Focus = CFrame_new(subjectPosition)
--					Camera.CFrame = CFrame_new(subjectPosition - MIN_CAMERA_ZOOM*EnabledCamera:GetCameraLook(), subjectPosition)
--				end
--			end
--		end
		return newCameraCFrame, desiredCameraFocus
	end
	
	-- Return unchanged values
	return desiredCameraCFrame, desiredCameraFocus
end

function Poppercam:OnCameraSubjectChanged(newSubject)
	self.vehicleParts = {}

	self.lastPopAmount = 0

	if newSubject then
		-- Determine if we should be popping at all
		self.popperEnabled = false
		for _, subjectType in pairs(VALID_SUBJECTS) do
			if newSubject:IsA(subjectType) then
				self.popperEnabled = true
				break
			end
		end

		-- Get all parts of the vehicle the player is controlling
		if newSubject:IsA('VehicleSeat') then
			self.vehicleParts = newSubject:GetConnectedParts(true)
		end
	
		if FFlagUserPortraitPopperFix then
			if newSubject:IsA("BasePart") then
				self.subjectPart = newSubject
			elseif newSubject:IsA("Model") then
				if newSubject.PrimaryPart then
					self.subjectPart = newSubject.PrimaryPart
				else
					-- Model has no PrimaryPart set, just use first BasePart
					-- we can find as better-than-nothing solution (can still fail)
					for _, child in pairs(newSubject:GetChildren()) do
						if child:IsA("BasePart") then
							self.subjectPart = child
							break
						end
					end	
				end
			elseif newSubject:IsA("Humanoid") then
				self.subjectPart = newSubject.RootPart
  			end
  		end
  	end
end

return Poppercam]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX921AE44F071A4319BC6A16E96B915243">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">ZoomController</string>
							<string name="ScriptGuid">{360D7A3D-DDB7-48D1-B471-B75FA215E81E}</string>
							<ProtectedString name="Source"><![CDATA[-- Zoom
-- Controls the distance between the focus and the camera.

local ZOOM_STIFFNESS = 4.5
local ZOOM_DEFAULT = 12.5
local ZOOM_ACCELERATION = 0.0375

local DIST_OPAQUE = 1

local Popper = require(script:WaitForChild("Popper"))

local clamp = math.clamp
local exp = math.exp
local min = math.min
local max = math.max
local pi = math.pi

local cameraMinZoomDistance, cameraMaxZoomDistance do
	local Player = game:GetService("Players").LocalPlayer

	local function updateBounds()
		cameraMinZoomDistance = Player.CameraMinZoomDistance
		cameraMaxZoomDistance = Player.CameraMaxZoomDistance
	end

	updateBounds()

	Player:GetPropertyChangedSignal("CameraMinZoomDistance"):Connect(updateBounds)
	Player:GetPropertyChangedSignal("CameraMaxZoomDistance"):Connect(updateBounds)
end

local ConstrainedSpring = {} do
	ConstrainedSpring.__index = ConstrainedSpring

	function ConstrainedSpring.new(freq, x, minValue, maxValue)
		x = clamp(x, minValue, maxValue)
		return setmetatable({
			freq = freq, -- Undamped frequency (Hz)
			x = x, -- Current position
			v = 0, -- Current velocity
			minValue = minValue, -- Minimum bound
			maxValue = maxValue, -- Maximum bound
			goal = x, -- Goal position
		}, ConstrainedSpring)
	end

	function ConstrainedSpring:Step(dt)
		local freq = self.freq*2*pi -- Convert from Hz to rad/s
		local x = self.x
		local v = self.v
		local minValue = self.minValue
		local maxValue = self.maxValue
		local goal = self.goal

		-- Solve the spring ODE for position and velocity after time t, assuming critical damping:
		--   2*f*x'[t] + x''[t] = f^2*(g - x[t])
		-- Knowns are x[0] and x'[0].
		-- Solve for x[t] and x'[t].

		local offset = goal - x
		local step = freq*dt
		local decay = exp(-step)

		local x1 = goal + (v*dt - offset*(step + 1))*decay
		local v1 = ((offset*freq - v)*step + v)*decay

		-- Constrain
		if x1 < minValue then
			x1 = minValue
			v1 = 0
		elseif x1 > maxValue then
			x1 = maxValue
			v1 = 0
		end

		self.x = x1
		self.v = v1

		return x1
	end
end

local zoomSpring = ConstrainedSpring.new(ZOOM_STIFFNESS, ZOOM_DEFAULT, cameraMinZoomDistance, cameraMaxZoomDistance)

local function stepTargetZoom(z, dz, zoomMin, zoomMax)
	z = clamp(z + dz*(1 + z*ZOOM_ACCELERATION), zoomMin, zoomMax)
	if z < DIST_OPAQUE then
		z = dz <= 0 and zoomMin or DIST_OPAQUE
	end
	return z
end

local zoomDelta = 0

local Zoom = {} do
	function Zoom.Update(renderDt, focus, extrapolation)
		local poppedZoom = math.huge

		if zoomSpring.goal > DIST_OPAQUE then
			-- Make a pessimistic estimate of zoom distance for this step without accounting for poppercam
			local maxPossibleZoom = max(
				zoomSpring.x,
				stepTargetZoom(zoomSpring.goal, zoomDelta, cameraMinZoomDistance, cameraMaxZoomDistance)
			)

			-- Run the Popper algorithm on the feasible zoom range, [cameraMinZoomDistance, maxPossibleZoom]
			poppedZoom = Popper(
				focus*CFrame.new(0, 0, cameraMinZoomDistance),
				maxPossibleZoom - cameraMinZoomDistance,
				extrapolation
			) + cameraMinZoomDistance
		end

		zoomSpring.minValue = cameraMinZoomDistance
		zoomSpring.maxValue = min(cameraMaxZoomDistance, poppedZoom)

		return zoomSpring:Step(renderDt)
	end

	function Zoom.SetZoomParameters(targetZoom, newZoomDelta)
		zoomSpring.goal = targetZoom
		zoomDelta = newZoomDelta
	end
end

return Zoom
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBXF2A2DE1B06044F7A955179E892C77D32">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Popper</string>
								<string name="ScriptGuid">{8AB64531-7400-4EF1-A0B3-335AEF88E361}</string>
								<ProtectedString name="Source"><![CDATA[--------------------------------------------------------------------------------
-- Popper.lua
-- Prevents your camera from clipping through walls.
--------------------------------------------------------------------------------

local Players = game:GetService('Players')
local Collection = game:GetService("CollectionService")

local FFlagUserPoppercamLooseOpacityThreshold do
	local success, enabled = pcall(function()
		return UserSettings():IsUserFeatureEnabled("UserPoppercamLooseOpacityThreshold")
	end)
	FFlagUserPoppercamLooseOpacityThreshold = success and enabled
end

local camera = game.Workspace.CurrentCamera

local min = math.min
local tan = math.tan
local rad = math.rad
local inf = math.huge
local ray = Ray.new

local function eraseFromEnd(t, toSize)
	for i = #t, toSize + 1, -1 do
		t[i] = nil
	end
end

local nearPlaneZ, projX, projY do
	local function updateProjection()
		local fov = rad(camera.FieldOfView)
		local view = camera.ViewportSize
		local ar = view.X/view.Y

		projY = 2*tan(fov/2)
		projX = ar*projY
	end

	camera:GetPropertyChangedSignal('FieldOfView'):Connect(updateProjection)
	camera:GetPropertyChangedSignal('ViewportSize'):Connect(updateProjection)

	updateProjection()

	nearPlaneZ = camera.NearPlaneZ
	camera:GetPropertyChangedSignal('NearPlaneZ'):Connect(function()
		nearPlaneZ = camera.NearPlaneZ
	end)
end

local blacklist = {} do
	local charMap = {}

	local function refreshIgnoreList()
		blacklist = {unpack(Collection:GetTagged("IgnoreCamera"))}
		local n = #blacklist + 1
		for _, character in pairs(charMap) do
			blacklist[n] = character
			n = n + 1
		end
	end
	
	local function OnIgnoreCollectionUpdated(instance)
		refreshIgnoreList()
	end

	local function playerAdded(player)
		local function characterAdded(character)
			charMap[player] = character
			refreshIgnoreList()
		end
		local function characterRemoving()
			charMap[player] = nil
			refreshIgnoreList()
		end

		player.CharacterAdded:Connect(characterAdded)
		player.CharacterRemoving:Connect(characterRemoving)
		if player.Character then
			characterAdded(player.Character)
		end
	end

	local function playerRemoving(player)
		charMap[player] = nil
		refreshIgnoreList()
	end
	
	Collection:GetInstanceAddedSignal("IgnoreCamera"):Connect(OnIgnoreCollectionUpdated)
	Collection:GetInstanceRemovedSignal("IgnoreCamera"):Connect(OnIgnoreCollectionUpdated)
	Players.PlayerAdded:Connect(playerAdded)
	Players.PlayerRemoving:Connect(playerRemoving)
	
	for _, instance in next,Collection:GetTagged("IgnoreCamera") do
		OnIgnoreCollectionUpdated(instance)
	end
	for _, player in ipairs(Players:GetPlayers()) do
		playerAdded(player)
	end
	refreshIgnoreList()
end

--------------------------------------------------------------------------------------------
-- Popper uses the level geometry find an upper bound on subject-to-camera distance.
--
-- Hard limits are applied immediately and unconditionally. They're generally caused
-- when level geometry intersects with the near plane (with exceptions, see below).
--
-- Soft limits are only applied under certain conditions.
-- They're caused when level geometry occludes the subject without actually intersecting
-- with the near plane at the target distance.
--
-- Soft limits can be promoted to hard limits and hard limits can be demoted to soft limits.
-- We usually don't want the latter to happen.
--
-- A soft limit will be promoted to a hard limit if an obstruction
-- lies between the current and target camera positions.
--------------------------------------------------------------------------------------------

local subjectRoot
local subjectPart

camera:GetPropertyChangedSignal('CameraSubject'):Connect(function()
	local subject = camera.CameraSubject
	if subject:IsA('Humanoid') then
		subjectPart = subject.RootPart
	elseif subject:IsA('BasePart') then
		subjectPart = subject
	else
		subjectPart = nil
	end
end)

local function canOcclude(part)
	-- Occluders must be:
	-- 1. Opaque
	-- 2. Interactable
	-- 3. Not in the same assembly as the subject

	if FFlagUserPoppercamLooseOpacityThreshold then
		return
			part.Transparency < 0.25 and
			part.CanCollide and
			subjectRoot ~= (part:GetRootPart() or part) and
			not part:IsA('TrussPart')
	else
		return
			part.Transparency < 0.95 and
			part.CanCollide and
			subjectRoot ~= (part:GetRootPart() or part)
	end
end

-- Offsets for the volume visibility test
local SCAN_SAMPLE_OFFSETS = {
	Vector2.new( 0.4, 0.0),
	Vector2.new(-0.4, 0.0),
	Vector2.new( 0.0,-0.4),
	Vector2.new( 0.0, 0.4),
	Vector2.new( 0.0, 0.2),
}

--------------------------------------------------------------------------------
-- Piercing raycasts

local function getCollisionPoint(origin, dir)
	local originalSize = #blacklist
	repeat
		local hitPart, hitPoint = workspace:FindPartOnRayWithIgnoreList(
			ray(origin, dir), blacklist, false, true
		)

		if hitPart then
			if hitPart.CanCollide and not Collection:HasTag(hitPart,"IgnoreCamera") then
				eraseFromEnd(blacklist, originalSize)
				return hitPoint, true
			end
			blacklist[#blacklist + 1] = hitPart
		end
	until not hitPart

	eraseFromEnd(blacklist, originalSize)
	return origin + dir, false
end

--------------------------------------------------------------------------------

local function queryPoint(origin, unitDir, dist, lastPos)
	debug.profilebegin('queryPoint')

	local originalSize = #blacklist

	dist = dist + nearPlaneZ
	local target = origin + unitDir*dist

	local softLimit = inf
	local hardLimit = inf
	local movingOrigin = origin

	repeat
		local entryPart, entryPos = workspace:FindPartOnRayWithIgnoreList(ray(movingOrigin, target - movingOrigin), blacklist, false, true)

		if entryPart then
			if canOcclude(entryPart) then
				local wl = {entryPart}
				local exitPart = workspace:FindPartOnRayWithWhitelist(ray(target, entryPos - target), wl, true)

				local lim = (entryPos - origin).Magnitude

				if exitPart then
					local promote = false
					if lastPos then
						promote =
							workspace:FindPartOnRayWithWhitelist(ray(lastPos, target - lastPos), wl, true) or
							workspace:FindPartOnRayWithWhitelist(ray(target, lastPos - target), wl, true)
					end

					if promote then
						-- Ostensibly a soft limit, but the camera has passed through it in the last frame, so promote to a hard limit.
						hardLimit = lim
					elseif dist < softLimit then
						-- Trivial soft limit
						softLimit = lim
					end
				else
					-- Trivial hard limit
					hardLimit = lim
				end
			end

			blacklist[#blacklist + 1] = entryPart
			movingOrigin = entryPos - unitDir*1e-3
		end
	until hardLimit < inf or not entryPart

	eraseFromEnd(blacklist, originalSize)

	debug.profileend()
	return softLimit - nearPlaneZ, hardLimit - nearPlaneZ
end

local function queryViewport(focus, dist)
	debug.profilebegin('queryViewport')

	local fP =  focus.p
	local fX =  focus.rightVector
	local fY =  focus.upVector
	local fZ = -focus.lookVector

	local viewport = camera.ViewportSize

	local hardBoxLimit = inf
	local softBoxLimit = inf

	-- Center the viewport on the PoI, sweep points on the edge towards the target, and take the minimum limits
	for viewX = 0, 1 do
		local worldX = fX*((viewX - 0.5)*projX)

		for viewY = 0, 1 do
			local worldY = fY*((viewY - 0.5)*projY)

			local origin = fP + nearPlaneZ*(worldX + worldY)
			local lastPos = camera:ViewportPointToRay(
				viewport.x*viewX,
				viewport.y*viewY
			).Origin

			local softPointLimit, hardPointLimit = queryPoint(origin, fZ, dist, lastPos)

			if hardPointLimit < hardBoxLimit then
				hardBoxLimit = hardPointLimit
			end
			if softPointLimit < softBoxLimit then
				softBoxLimit = softPointLimit
			end
		end
	end
	debug.profileend()

	return softBoxLimit, hardBoxLimit
end

local function testPromotion(focus, dist, focusExtrapolation)
	debug.profilebegin('testPromotion')

	local fP = focus.p
	local fX = focus.rightVector
	local fY = focus.upVector
	local fZ = -focus.lookVector

	do
		-- Dead reckoning the camera rotation and focus
		debug.profilebegin('extrapolate')

		local SAMPLE_DT = 0.0625
		local SAMPLE_MAX_T = 1.25

		local maxDist = (getCollisionPoint(fP, focusExtrapolation.posVelocity*SAMPLE_MAX_T) - fP).Magnitude
		-- Metric that decides how many samples to take
		local combinedSpeed = focusExtrapolation.posVelocity.magnitude

		for dt = 0, min(SAMPLE_MAX_T, focusExtrapolation.rotVelocity.magnitude + maxDist/combinedSpeed), SAMPLE_DT do
			local cfDt = focusExtrapolation.extrapolate(dt) -- Extrapolated CFrame at time dt

			if queryPoint(cfDt.p, -cfDt.lookVector, dist) >= dist then
				return false
			end
		end

		debug.profileend()
	end

	do
		-- Test screen-space offsets from the focus for the presence of soft limits
		debug.profilebegin('testOffsets')

		for _, offset in ipairs(SCAN_SAMPLE_OFFSETS) do
			local scaledOffset = offset
			local pos, isHit = getCollisionPoint(fP, fX*scaledOffset.x + fY*scaledOffset.y)
			if queryPoint(pos, (fP + fZ*dist - pos).Unit, dist) == inf then
				return false
			end
		end

		debug.profileend()
	end

	debug.profileend()
	return true
end

local function Popper(focus, targetDist, focusExtrapolation)
	debug.profilebegin('popper')

	subjectRoot = subjectPart and subjectPart:GetRootPart() or subjectPart

	local dist = targetDist
	local soft, hard = queryViewport(focus, targetDist)
	if hard < dist then
		dist = hard
	end
	if soft < dist and testPromotion(focus, targetDist, focusExtrapolation) then
		dist = soft
	end

	subjectRoot = nil

	debug.profileend()
	return dist
end

return Popper
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
				</Item>
			</Item>
		</Item>
	</Item>
	<Item class="StarterPack" referent="RBXF33EEF60F2ED4B38AB296E3FBAF6F31C">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">StarterPack</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="StarterGui" referent="2">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">StarterGui</string>
			<bool name="ResetPlayerGuiOnSpawn">true</bool>
			<token name="ScreenOrientation">2</token>
			<bool name="ShowDevelopmentGui">true</bool>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<token name="VirtualCursorMode">0</token>
		</Properties>
	</Item>
	<Item class="LocalizationService" referent="RBX93BBD1CF17294E879189B3711231095E">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">LocalizationService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="TeleportService" referent="RBX35C0909ABF30424E8C8437CEFA6A353F">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">Teleport Service</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="CollectionService" referent="RBXA38F49E7F03648428AAD8D224B75351B">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">CollectionService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="PhysicsService" referent="RBX467D5AAF6BE04B7FA85B553D5AF184B6">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">PhysicsService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="Geometry" referent="RBXF271060F225E474EBC39929103632647">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">Geometry</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="InsertService" referent="RBXC7F3D558159F4A60B46D177AB137A908">
		<Properties>
			<bool name="AllowClientInsertModels">false</bool>
			<bool name="AllowInsertFreeModels">false</bool>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">InsertService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
		<Item class="StringValue" referent="RBX6DBBB4A883AA44BD9CF3FD8884AFE407">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<string name="Name">InsertionHash</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<string name="Value">{0FFB0D66-B740-41F8-8935-3F8350EF6D41}</string>
			</Properties>
		</Item>
	</Item>
	<Item class="GamePassService" referent="RBX4C44C0593F914EB29AB47483F8D5D43A">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">GamePassService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="Debris" referent="RBX483489046FB949D3BF76769054B044CD">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<int name="MaxItems">1000</int>
			<string name="Name">Debris</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="CookiesService" referent="RBX7DC34D86CFAC4D6D8852C543CC73CFFD">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">CookiesService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="VRService" referent="RBXA176E037FA9A46228CE0588BE6E7CA0E">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">VRService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="ContextActionService" referent="RBX8E429B80732943EE99581078BB223AD2">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">ContextActionService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="ScriptService" referent="RBX45DFFB51F281410CA25F156D55600EAA">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">Instance</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="AssetService" referent="RBX873741456EFE40CBBDD9A2BEC93C7EB7">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">AssetService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="TouchInputService" referent="RBXF5F6A3327AC64EA1862A5264C5E42736">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">TouchInputService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="AnalyticsService" referent="RBXBF72CFFD744C4C9388B3516B0A1F7059">
		<Properties>
			<string name="ApiKey"></string>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">AnalyticsService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="Selection" referent="RBX90563BEF30EF4735A6B8F5E87D99FE2E">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">Selection</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="ServerScriptService" referent="1">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<bool name="LoadStringEnabled">false</bool>
			<string name="Name">ServerScriptService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="ServerStorage" referent="RBXE361BC3B92864FC9B3AA5F31DCDCDF84">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">ServerStorage</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="ReplicatedStorage" referent="0">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">ReplicatedStorage</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
		<Item class="Folder" referent="RBXF3E76F26C22F4E5BA897E13BE5100017">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<string name="Name">Assets</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="Folder" referent="RBXF5025A108E414EC091369B18067689F0">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<string name="Name">Weapons</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="Model" referent="RBXC17B12EB34884AE6BF6B4F66B1DF0633">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<token name="LevelOfDetail">0</token>
						<CoordinateFrame name="ModelMeshCFrame">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<SharedString name="ModelMeshData">yuZpQdnvvUBOTYh1jqZ2cA==</SharedString>
						<Vector3 name="ModelMeshSize">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<string name="Name">M4</string>
						<bool name="NeedsPivotMigration">false</bool>
						<Ref name="PrimaryPart">null</Ref>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<OptionalCoordinateFrame name="WorldPivotData">
							<CFrame>
								<X>17</X>
								<Y>1010.19476</Y>
								<Z>-4.73099995</Z>
								<R00>1</R00>
								<R01>0</R01>
								<R02>0</R02>
								<R10>0</R10>
								<R11>1</R11>
								<R12>0</R12>
								<R20>0</R20>
								<R21>0</R21>
								<R22>1</R22>
							</CFrame>
						</OptionalCoordinateFrame>
					</Properties>
					<Item class="MeshPart" referent="RBX68949B4925BA49D497588E6586E34FD2">
						<Properties>
							<bool name="Anchored">false</bool>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<float name="BackParamA">-0.5</float>
							<float name="BackParamB">0.5</float>
							<token name="BackSurface">0</token>
							<token name="BackSurfaceInput">0</token>
							<float name="BottomParamA">-0.5</float>
							<float name="BottomParamB">0.5</float>
							<token name="BottomSurface">0</token>
							<token name="BottomSurfaceInput">0</token>
							<CoordinateFrame name="CFrame">
								<X>17</X>
								<Y>1009.9353</Y>
								<Z>-4.77148914</Z>
								<R00>1</R00>
								<R01>0</R01>
								<R02>0</R02>
								<R10>0</R10>
								<R11>1</R11>
								<R12>0</R12>
								<R20>0</R20>
								<R21>0</R21>
								<R22>1</R22>
							</CoordinateFrame>
							<bool name="CanCollide">true</bool>
							<bool name="CanQuery">true</bool>
							<bool name="CanTouch">true</bool>
							<bool name="CastShadow">true</bool>
							<int name="CollisionGroupId">0</int>
							<Color3uint8 name="Color3uint8">4281479730</Color3uint8>
							<PhysicalProperties name="CustomPhysicalProperties">
								<CustomPhysics>false</CustomPhysics>
							</PhysicalProperties>
							<bool name="DoubleSided">false</bool>
							<float name="FrontParamA">-0.5</float>
							<float name="FrontParamB">0.5</float>
							<token name="FrontSurface">0</token>
							<token name="FrontSurfaceInput">0</token>
							<bool name="HasJointOffset">false</bool>
							<bool name="HasSkinnedMesh">false</bool>
							<Vector3 name="InitialSize">
								<X>2.4009006</X>
								<Y>20.0743732</Y>
								<Z>8.91827393</Z>
							</Vector3>
							<Vector3 name="JointOffset">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<BinaryString name="LODData"></BinaryString>
							<float name="LeftParamA">-0.5</float>
							<float name="LeftParamB">0.5</float>
							<token name="LeftSurface">0</token>
							<token name="LeftSurfaceInput">0</token>
							<bool name="Locked">false</bool>
							<bool name="Massless">false</bool>
							<token name="Material">1088</token>
							<Content name="MeshID"><url>rbxassetid://7381333200</url></Content>
							<Content name="MeshId"><url>rbxassetid://7381333200</url></Content>
							<string name="Name">Mag</string>
							<SharedString name="PhysicalConfigData">q3NWt6od6We8loSdYnixLg==</SharedString>
							<BinaryString name="PhysicsData"></BinaryString>
							<CoordinateFrame name="PivotOffset">
								<X>-0.0885657221</X>
								<Y>0.211334005</Y>
								<Z>-0.394059896</Z>
								<R00>1</R00>
								<R01>0</R01>
								<R02>0</R02>
								<R10>0</R10>
								<R11>1</R11>
								<R12>0</R12>
								<R20>0</R20>
								<R21>0</R21>
								<R22>1</R22>
							</CoordinateFrame>
							<float name="Reflectance">0</float>
							<token name="RenderFidelity">0</token>
							<float name="RightParamA">-0.5</float>
							<float name="RightParamB">0.5</float>
							<token name="RightSurface">0</token>
							<token name="RightSurfaceInput">0</token>
							<int name="RootPriority">0</int>
							<Vector3 name="RotVelocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<Content name="TextureID"><null></null></Content>
							<float name="TopParamA">-0.5</float>
							<float name="TopParamB">0.5</float>
							<token name="TopSurface">0</token>
							<token name="TopSurfaceInput">0</token>
							<float name="Transparency">0</float>
							<Vector3 name="Velocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<Vector3 name="size">
								<X>0.131005436</X>
								<Y>1.09536064</Y>
								<Z>0.486626714</Z>
							</Vector3>
						</Properties>
					</Item>
					<Item class="MeshPart" referent="RBXFC4EDE5E195E40D3BADB80C2D74615C4">
						<Properties>
							<bool name="Anchored">false</bool>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<float name="BackParamA">-0.5</float>
							<float name="BackParamB">0.5</float>
							<token name="BackSurface">0</token>
							<token name="BackSurfaceInput">0</token>
							<float name="BottomParamA">-0.5</float>
							<float name="BottomParamB">0.5</float>
							<token name="BottomSurface">0</token>
							<token name="BottomSurfaceInput">0</token>
							<CoordinateFrame name="CFrame">
								<X>17</X>
								<Y>1010.35577</Y>
								<Z>-4.73099995</Z>
								<R00>1</R00>
								<R01>0</R01>
								<R02>0</R02>
								<R10>0</R10>
								<R11>1</R11>
								<R12>0</R12>
								<R20>0</R20>
								<R21>0</R21>
								<R22>1</R22>
							</CoordinateFrame>
							<bool name="CanCollide">true</bool>
							<bool name="CanQuery">true</bool>
							<bool name="CanTouch">true</bool>
							<bool name="CastShadow">true</bool>
							<int name="CollisionGroupId">0</int>
							<Color3uint8 name="Color3uint8">4284702562</Color3uint8>
							<PhysicalProperties name="CustomPhysicalProperties">
								<CustomPhysics>false</CustomPhysics>
							</PhysicalProperties>
							<bool name="DoubleSided">false</bool>
							<float name="FrontParamA">-0.5</float>
							<float name="FrontParamB">0.5</float>
							<token name="FrontSurface">0</token>
							<token name="FrontSurfaceInput">0</token>
							<bool name="HasJointOffset">false</bool>
							<bool name="HasSkinnedMesh">false</bool>
							<Vector3 name="InitialSize">
								<X>6.65884542</X>
								<Y>23.6787701</Y>
								<Z>76.7003784</Z>
							</Vector3>
							<Vector3 name="JointOffset">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<BinaryString name="LODData"></BinaryString>
							<float name="LeftParamA">-0.5</float>
							<float name="LeftParamB">0.5</float>
							<token name="LeftSurface">0</token>
							<token name="LeftSurfaceInput">0</token>
							<bool name="Locked">false</bool>
							<bool name="Massless">false</bool>
							<token name="Material">1088</token>
							<Content name="MeshID"><url>rbxassetid://7381334964</url></Content>
							<Content name="MeshId"><url>rbxassetid://7381334964</url></Content>
							<string name="Name">Body</string>
							<SharedString name="PhysicalConfigData">PFZCldh6bgipWdWjn0oM7w==</SharedString>
							<BinaryString name="PhysicsData"></BinaryString>
							<CoordinateFrame name="PivotOffset">
								<X>-0.0883762687</X>
								<Y>-0.152695686</Y>
								<Z>-0.437355876</Z>
								<R00>1</R00>
								<R01>0</R01>
								<R02>0</R02>
								<R10>0</R10>
								<R11>1</R11>
								<R12>0</R12>
								<R20>0</R20>
								<R21>0</R21>
								<R22>1</R22>
							</CoordinateFrame>
							<float name="Reflectance">0</float>
							<token name="RenderFidelity">0</token>
							<float name="RightParamA">-0.5</float>
							<float name="RightParamB">0.5</float>
							<token name="RightSurface">0</token>
							<token name="RightSurfaceInput">0</token>
							<int name="RootPriority">0</int>
							<Vector3 name="RotVelocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<Content name="TextureID"><null></null></Content>
							<float name="TopParamA">-0.5</float>
							<float name="TopParamB">0.5</float>
							<token name="TopSurface">0</token>
							<token name="TopSurfaceInput">0</token>
							<float name="Transparency">0</float>
							<Vector3 name="Velocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<Vector3 name="size">
								<X>0.363340706</X>
								<Y>1.29203486</Y>
								<Z>4.18516588</Z>
							</Vector3>
						</Properties>
					</Item>
					<Item class="Folder" referent="RBXAAB0F5A18B2D459095E626C8D63C8258">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<string name="Name">GunComponents</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="Part" referent="RBX708115CCA8284B8E865E4441C44BF8B5">
							<Properties>
								<bool name="Anchored">false</bool>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<float name="BackParamA">-0.5</float>
								<float name="BackParamB">0.5</float>
								<token name="BackSurface">0</token>
								<token name="BackSurfaceInput">0</token>
								<float name="BottomParamA">-0.5</float>
								<float name="BottomParamB">0.5</float>
								<token name="BottomSurface">0</token>
								<token name="BottomSurfaceInput">0</token>
								<CoordinateFrame name="CFrame">
									<X>17</X>
									<Y>1010.04163</Y>
									<Z>-5.66924143</Z>
									<R00>-1</R00>
									<R01>0</R01>
									<R02>0</R02>
									<R10>0</R10>
									<R11>1</R11>
									<R12>0</R12>
									<R20>0</R20>
									<R21>0</R21>
									<R22>-1</R22>
								</CoordinateFrame>
								<bool name="CanCollide">false</bool>
								<bool name="CanQuery">true</bool>
								<bool name="CanTouch">true</bool>
								<bool name="CastShadow">true</bool>
								<int name="CollisionGroupId">0</int>
								<Color3uint8 name="Color3uint8">4288914085</Color3uint8>
								<PhysicalProperties name="CustomPhysicalProperties">
									<CustomPhysics>false</CustomPhysics>
								</PhysicalProperties>
								<float name="FrontParamA">-0.5</float>
								<float name="FrontParamB">0.5</float>
								<token name="FrontSurface">0</token>
								<token name="FrontSurfaceInput">0</token>
								<float name="LeftParamA">-0.5</float>
								<float name="LeftParamB">0.5</float>
								<token name="LeftSurface">0</token>
								<token name="LeftSurfaceInput">0</token>
								<bool name="Locked">false</bool>
								<bool name="Massless">false</bool>
								<token name="Material">256</token>
								<string name="Name">Handle</string>
								<CoordinateFrame name="PivotOffset">
									<X>0</X>
									<Y>0</Y>
									<Z>0</Z>
									<R00>1</R00>
									<R01>0</R01>
									<R02>0</R02>
									<R10>0</R10>
									<R11>1</R11>
									<R12>0</R12>
									<R20>0</R20>
									<R21>0</R21>
									<R22>1</R22>
								</CoordinateFrame>
								<float name="Reflectance">0</float>
								<float name="RightParamA">-0.5</float>
								<float name="RightParamB">0.5</float>
								<token name="RightSurface">0</token>
								<token name="RightSurfaceInput">0</token>
								<int name="RootPriority">0</int>
								<Vector3 name="RotVelocity">
									<X>0</X>
									<Y>0</Y>
									<Z>0</Z>
								</Vector3>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<float name="TopParamA">-0.5</float>
								<float name="TopParamB">0.5</float>
								<token name="TopSurface">0</token>
								<token name="TopSurfaceInput">0</token>
								<float name="Transparency">0.5</float>
								<Vector3 name="Velocity">
									<X>0</X>
									<Y>0</Y>
									<Z>0</Z>
								</Vector3>
								<token name="formFactorRaw">1</token>
								<token name="shape">1</token>
								<Vector3 name="size">
									<X>0.329554826</X>
									<Y>0.621945918</Y>
									<Z>0.431572884</Z>
								</Vector3>
							</Properties>
							<Item class="Decal" referent="RBX4378B3ADB53A4F5196599AFECFA7E72E">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<Color3 name="Color3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<token name="Face">1</token>
									<string name="Name">Decal</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<Content name="Texture"><null></null></Content>
									<float name="Transparency">0</float>
									<int name="ZIndex">1</int>
								</Properties>
							</Item>
						</Item>
						<Item class="Part" referent="RBXCAC9726C3EED4D7BA8E0071DE3DE4484">
							<Properties>
								<bool name="Anchored">false</bool>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<float name="BackParamA">-0.5</float>
								<float name="BackParamB">0.5</float>
								<token name="BackSurface">0</token>
								<token name="BackSurfaceInput">0</token>
								<float name="BottomParamA">-0.5</float>
								<float name="BottomParamB">0.5</float>
								<token name="BottomSurface">0</token>
								<token name="BottomSurfaceInput">0</token>
								<CoordinateFrame name="CFrame">
									<X>17</X>
									<Y>1010.99506</Y>
									<Z>-5.71866035</Z>
									<R00>0</R00>
									<R01>1</R01>
									<R02>0</R02>
									<R10>1</R10>
									<R11>0</R11>
									<R12>0</R12>
									<R20>0</R20>
									<R21>0</R21>
									<R22>-1</R22>
								</CoordinateFrame>
								<bool name="CanCollide">false</bool>
								<bool name="CanQuery">true</bool>
								<bool name="CanTouch">true</bool>
								<bool name="CastShadow">true</bool>
								<int name="CollisionGroupId">0</int>
								<Color3uint8 name="Color3uint8">4288914085</Color3uint8>
								<PhysicalProperties name="CustomPhysicalProperties">
									<CustomPhysics>false</CustomPhysics>
								</PhysicalProperties>
								<float name="FrontParamA">-0.5</float>
								<float name="FrontParamB">0.5</float>
								<token name="FrontSurface">0</token>
								<token name="FrontSurfaceInput">0</token>
								<float name="LeftParamA">-0.5</float>
								<float name="LeftParamB">0.5</float>
								<token name="LeftSurface">0</token>
								<token name="LeftSurfaceInput">0</token>
								<bool name="Locked">false</bool>
								<bool name="Massless">false</bool>
								<token name="Material">256</token>
								<string name="Name">Sight</string>
								<CoordinateFrame name="PivotOffset">
									<X>0</X>
									<Y>0</Y>
									<Z>0</Z>
									<R00>1</R00>
									<R01>0</R01>
									<R02>0</R02>
									<R10>0</R10>
									<R11>1</R11>
									<R12>0</R12>
									<R20>0</R20>
									<R21>0</R21>
									<R22>1</R22>
								</CoordinateFrame>
								<float name="Reflectance">0</float>
								<float name="RightParamA">-0.5</float>
								<float name="RightParamB">0.5</float>
								<token name="RightSurface">0</token>
								<token name="RightSurfaceInput">0</token>
								<int name="RootPriority">0</int>
								<Vector3 name="RotVelocity">
									<X>0</X>
									<Y>0</Y>
									<Z>0</Z>
								</Vector3>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<float name="TopParamA">-0.5</float>
								<float name="TopParamB">0.5</float>
								<token name="TopSurface">0</token>
								<token name="TopSurfaceInput">0</token>
								<float name="Transparency">0.5</float>
								<Vector3 name="Velocity">
									<X>0</X>
									<Y>0</Y>
									<Z>0</Z>
								</Vector3>
								<token name="formFactorRaw">1</token>
								<token name="shape">1</token>
								<Vector3 name="size">
									<X>0.114006862</X>
									<Y>0.132193923</Y>
									<Z>0.189999998</Z>
								</Vector3>
							</Properties>
						</Item>
						<Item class="Part" referent="RBX6957828D15D24977B5E935591FBC83BE">
							<Properties>
								<bool name="Anchored">false</bool>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<float name="BackParamA">-0.5</float>
								<float name="BackParamB">0.5</float>
								<token name="BackSurface">0</token>
								<token name="BackSurfaceInput">0</token>
								<float name="BottomParamA">-0.5</float>
								<float name="BottomParamB">0.5</float>
								<token name="BottomSurface">0</token>
								<token name="BottomSurfaceInput">0</token>
								<CoordinateFrame name="CFrame">
									<X>17</X>
									<Y>1010.60382</Y>
									<Z>-2.52460909</Z>
									<R00>0</R00>
									<R01>1</R01>
									<R02>0</R02>
									<R10>1</R10>
									<R11>0</R11>
									<R12>0</R12>
									<R20>0</R20>
									<R21>0</R21>
									<R22>-1</R22>
								</CoordinateFrame>
								<bool name="CanCollide">false</bool>
								<bool name="CanQuery">true</bool>
								<bool name="CanTouch">true</bool>
								<bool name="CastShadow">true</bool>
								<int name="CollisionGroupId">0</int>
								<Color3uint8 name="Color3uint8">4288914085</Color3uint8>
								<PhysicalProperties name="CustomPhysicalProperties">
									<CustomPhysics>false</CustomPhysics>
								</PhysicalProperties>
								<float name="FrontParamA">-0.5</float>
								<float name="FrontParamB">0.5</float>
								<token name="FrontSurface">0</token>
								<token name="FrontSurfaceInput">0</token>
								<float name="LeftParamA">-0.5</float>
								<float name="LeftParamB">0.5</float>
								<token name="LeftSurface">0</token>
								<token name="LeftSurfaceInput">0</token>
								<bool name="Locked">false</bool>
								<bool name="Massless">false</bool>
								<token name="Material">256</token>
								<string name="Name">Barrel</string>
								<CoordinateFrame name="PivotOffset">
									<X>0</X>
									<Y>0</Y>
									<Z>0</Z>
									<R00>1</R00>
									<R01>0</R01>
									<R02>0</R02>
									<R10>0</R10>
									<R11>1</R11>
									<R12>0</R12>
									<R20>0</R20>
									<R21>0</R21>
									<R22>1</R22>
								</CoordinateFrame>
								<float name="Reflectance">0</float>
								<float name="RightParamA">-0.5</float>
								<float name="RightParamB">0.5</float>
								<token name="RightSurface">0</token>
								<token name="RightSurfaceInput">0</token>
								<int name="RootPriority">0</int>
								<Vector3 name="RotVelocity">
									<X>0</X>
									<Y>0</Y>
									<Z>0</Z>
								</Vector3>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<float name="TopParamA">-0.5</float>
								<float name="TopParamB">0.5</float>
								<token name="TopSurface">0</token>
								<token name="TopSurfaceInput">0</token>
								<float name="Transparency">0.5</float>
								<Vector3 name="Velocity">
									<X>0</X>
									<Y>0</Y>
									<Z>0</Z>
								</Vector3>
								<token name="formFactorRaw">1</token>
								<token name="shape">1</token>
								<Vector3 name="size">
									<X>0.114006862</X>
									<Y>0.132193923</Y>
									<Z>0.189999998</Z>
								</Vector3>
							</Properties>
							<Item class="ParticleEmitter" referent="RBX3FB7C2D808904512BE93E3571A9556A1">
								<Properties>
									<Vector3 name="Acceleration">
										<X>0</X>
										<Y>0</Y>
										<Z>0</Z>
									</Vector3>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<ColorSequence name="Color">0 1 1 1 0 1 1 1 1 0 </ColorSequence>
									<float name="Drag">0</float>
									<token name="EmissionDirection">5</token>
									<bool name="Enabled">false</bool>
									<NumberRange name="Lifetime">0.1 0.1 </NumberRange>
									<float name="LightEmission">0.400000006</float>
									<float name="LightInfluence">0</float>
									<bool name="LockedToPart">true</bool>
									<string name="Name">MuzzleEffect</string>
									<token name="Orientation">0</token>
									<float name="Rate">500</float>
									<NumberRange name="RotSpeed">360 360 </NumberRange>
									<NumberRange name="Rotation">45 45 </NumberRange>
									<NumberSequence name="Size">0 0 0 0.4 1 0 0.698 1.5 0 1 0.125 0 </NumberSequence>
									<int64 name="SourceAssetId">-1</int64>
									<NumberRange name="Speed">0 0 </NumberRange>
									<Vector2 name="SpreadAngle">
										<X>0</X>
										<Y>0</Y>
									</Vector2>
									<BinaryString name="Tags"></BinaryString>
									<Content name="Texture"><url>rbxassetid://421803006</url></Content>
									<float name="TimeScale">1</float>
									<NumberSequence name="Transparency">0 1 0 0.1 0 0 0.75 0 0 1 1 0 </NumberSequence>
									<float name="VelocityInheritance">0</float>
									<float name="ZOffset">0</float>
								</Properties>
							</Item>
						</Item>
					</Item>
					<Item class="Folder" referent="RBX80C98505729348EC86762EBA73B38897">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<string name="Name">Sound</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="Folder" referent="RBXC06E6F67AFBC4CA8A6D84BF4512DCA32">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<string name="Name">Anim</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
			</Item>
			<Item class="MeshPart" referent="RBX65A791CC2C7B464ABA8C1E5E22C4683D">
				<Properties>
					<bool name="Anchored">false</bool>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<float name="BackParamA">-0.5</float>
					<float name="BackParamB">0.5</float>
					<token name="BackSurface">0</token>
					<token name="BackSurfaceInput">0</token>
					<float name="BottomParamA">-0.5</float>
					<float name="BottomParamB">0.5</float>
					<token name="BottomSurface">0</token>
					<token name="BottomSurfaceInput">0</token>
					<CoordinateFrame name="CFrame">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<bool name="CanCollide">true</bool>
					<bool name="CanQuery">true</bool>
					<bool name="CanTouch">true</bool>
					<bool name="CastShadow">true</bool>
					<int name="CollisionGroupId">0</int>
					<Color3uint8 name="Color3uint8">4288914085</Color3uint8>
					<PhysicalProperties name="CustomPhysicalProperties">
						<CustomPhysics>false</CustomPhysics>
					</PhysicalProperties>
					<bool name="DoubleSided">false</bool>
					<float name="FrontParamA">-0.5</float>
					<float name="FrontParamB">0.5</float>
					<token name="FrontSurface">0</token>
					<token name="FrontSurfaceInput">0</token>
					<bool name="HasJointOffset">false</bool>
					<bool name="HasSkinnedMesh">false</bool>
					<Vector3 name="InitialSize">
						<X>35.5803146</X>
						<Y>18.7247047</Y>
						<Z>35.5803185</Z>
					</Vector3>
					<Vector3 name="JointOffset">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<BinaryString name="LODData"></BinaryString>
					<float name="LeftParamA">-0.5</float>
					<float name="LeftParamB">0.5</float>
					<token name="LeftSurface">0</token>
					<token name="LeftSurfaceInput">0</token>
					<bool name="Locked">false</bool>
					<bool name="Massless">false</bool>
					<token name="Material">256</token>
					<Content name="MeshID"><url>rbxassetid://7402483824</url></Content>
					<Content name="MeshId"><url>rbxassetid://7402483824</url></Content>
					<string name="Name">Table</string>
					<SharedString name="PhysicalConfigData">FSjZieUXNuAHM4qeNl45ag==</SharedString>
					<BinaryString name="PhysicsData"></BinaryString>
					<CoordinateFrame name="PivotOffset">
						<X>-0.27946049</X>
						<Y>2.50771928</Y>
						<Z>0.742670119</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<float name="Reflectance">0</float>
					<token name="RenderFidelity">0</token>
					<float name="RightParamA">-0.5</float>
					<float name="RightParamB">0.5</float>
					<token name="RightSurface">0</token>
					<token name="RightSurfaceInput">0</token>
					<int name="RootPriority">0</int>
					<Vector3 name="RotVelocity">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<Content name="TextureID"><url>rbxassetid://7402484012</url></Content>
					<float name="TopParamA">-0.5</float>
					<float name="TopParamB">0.5</float>
					<token name="TopSurface">0</token>
					<token name="TopSurfaceInput">0</token>
					<float name="Transparency">0</float>
					<Vector3 name="Velocity">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<Vector3 name="size">
						<X>14</X>
						<Y>7</Y>
						<Z>14</Z>
					</Vector3>
				</Properties>
				<Item class="WedgePart" referent="RBXC94B56A398734DA19D673706330708CB">
					<Properties>
						<bool name="Anchored">false</bool>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<float name="BackParamA">-0.5</float>
						<float name="BackParamB">0.5</float>
						<token name="BackSurface">0</token>
						<token name="BackSurfaceInput">0</token>
						<float name="BottomParamA">-0.5</float>
						<float name="BottomParamB">0.5</float>
						<token name="BottomSurface">0</token>
						<token name="BottomSurfaceInput">0</token>
						<CoordinateFrame name="CFrame">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<bool name="CanCollide">false</bool>
						<bool name="CanQuery">true</bool>
						<bool name="CanTouch">true</bool>
						<bool name="CastShadow">true</bool>
						<int name="CollisionGroupId">0</int>
						<Color3uint8 name="Color3uint8">4288914085</Color3uint8>
						<PhysicalProperties name="CustomPhysicalProperties">
							<CustomPhysics>false</CustomPhysics>
						</PhysicalProperties>
						<float name="FrontParamA">-0.5</float>
						<float name="FrontParamB">0.5</float>
						<token name="FrontSurface">0</token>
						<token name="FrontSurfaceInput">0</token>
						<float name="LeftParamA">-0.5</float>
						<float name="LeftParamB">0.5</float>
						<token name="LeftSurface">0</token>
						<token name="LeftSurfaceInput">0</token>
						<bool name="Locked">false</bool>
						<bool name="Massless">false</bool>
						<token name="Material">256</token>
						<string name="Name">Wedge</string>
						<CoordinateFrame name="PivotOffset">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<float name="Reflectance">0</float>
						<float name="RightParamA">-0.5</float>
						<float name="RightParamB">0.5</float>
						<token name="RightSurface">0</token>
						<token name="RightSurfaceInput">0</token>
						<int name="RootPriority">0</int>
						<Vector3 name="RotVelocity">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<float name="TopParamA">-0.5</float>
						<float name="TopParamB">0.5</float>
						<token name="TopSurface">0</token>
						<token name="TopSurfaceInput">0</token>
						<float name="Transparency">1</float>
						<Vector3 name="Velocity">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<token name="formFactorRaw">1</token>
						<Vector3 name="size">
							<X>14</X>
							<Y>7</Y>
							<Z>14</Z>
						</Vector3>
					</Properties>
				</Item>
			</Item>
		</Item>
	</Item>
	<Item class="LuaWebService" referent="RBXEFCED0586CE94F02B4E5A56F2B0833B6">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">Instance</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="Lighting" referent="RBXCBF50A6EABAB4F43B994EF2EA4D9D266">
		<Properties>
			<Color3 name="Ambient">
				<R>0.5</R>
				<G>0.5</G>
				<B>0.5</B>
			</Color3>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<float name="Brightness">1</float>
			<Color3 name="ColorShift_Bottom">
				<R>0</R>
				<G>0</G>
				<B>0</B>
			</Color3>
			<Color3 name="ColorShift_Top">
				<R>0</R>
				<G>0</G>
				<B>0</B>
			</Color3>
			<float name="EnvironmentDiffuseScale">0</float>
			<float name="EnvironmentSpecularScale">0</float>
			<float name="ExposureCompensation">0</float>
			<Color3 name="FogColor">
				<R>0.75</R>
				<G>0.75</G>
				<B>0.75</B>
			</Color3>
			<float name="FogEnd">100000</float>
			<float name="FogStart">0</float>
			<float name="GeographicLatitude">41.7332993</float>
			<bool name="GlobalShadows">false</bool>
			<string name="Name">Lighting</string>
			<Color3 name="OutdoorAmbient">
				<R>0.5</R>
				<G>0.5</G>
				<B>0.5</B>
			</Color3>
			<bool name="Outlines">true</bool>
			<float name="ShadowSoftness">0.5</float>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<token name="Technology">2</token>
			<string name="TimeOfDay">14:00:00</string>
		</Properties>
	</Item>
	<Item class="HttpService" referent="RBX9865F51242A24BBB9CA702A2D3CB2B19">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<bool name="HttpEnabled">false</bool>
			<string name="Name">HttpService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<Item class="LanguageService" referent="RBXF370D4C848E94220AEFF0D3F13451A81">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="Name">LanguageService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
	</Item>
	<SharedStrings>
		<SharedString md5="FSjZieUXNuAHM4qeNl45ag==">Q1NHUEhTBwAAAAKZO0xFZxYnvF8E7kDj5MM6h9y8SHgTPkMA4lFDaHw6SQhXh8Jmtc9IEAAA
AAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAACAPxgAAAAEAAAAzvWFQQAAAAAq
w0jBXhJwQQAAAAAqw0jBzvWFQQAAAAASPGfBdfWFQS7MlUCxxEjBXhJwQS7MlUCxxEjBXhJw
QQAAAAASPGfBdfWFQS7MlUASPGfBXhJwQS7MlUASPGfBJAAAAAAAAAABAAAABQAAAAAAAAAF
AAAAAgAAAAAAAAACAAAABgAAAAAAAAAGAAAAAwAAAAAAAAADAAAABAAAAAAAAAAEAAAAAQAA
AAEAAAAEAAAABwAAAAEAAAAHAAAABQAAAAIAAAAFAAAABwAAAAIAAAAHAAAABgAAAAMAAAAG
AAAABwAAAAMAAAAHAAAABAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAA
AAAAgD8YAAAABAAAAM71hUEAAIA2GZVmQV4ScEEAAIA2GZVmQc71hUEAAIA2MBxIQXX1hUE2
zJVAVpRmQV4ScEE2zJVAVpRmQV4ScEEAAIA2MBxIQXX1hUE2zJVAbRtIQV4ScEE2zJVAbRtI
QSQAAAAAAAAAAQAAAAUAAAAAAAAABQAAAAIAAAAAAAAAAgAAAAYAAAAAAAAABgAAAAMAAAAA
AAAAAwAAAAQAAAAAAAAABAAAAAEAAAABAAAABAAAAAcAAAABAAAABwAAAAUAAAACAAAABQAA
AAcAAAACAAAABwAAAAYAAAADAAAABgAAAAcAAAADAAAABwAAAAQAAAAQAAAAAAAAAAAAAAAA
AAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAIA/GAAAAAQAAADYM27BAAAAtirDSMHkBoXBAAAA
tirDSMHYM27BAAAAthI8Z8E9NW7BKcyVQLHESME9B4XBKcyVQLHESMHkBoXBAAAAthI8Z8E9
NW7BKcyVQBI8Z8E9B4XBKcyVQBI8Z8EkAAAAAAAAAAEAAAAFAAAAAAAAAAUAAAACAAAAAAAA
AAIAAAAGAAAAAAAAAAYAAAADAAAAAAAAAAMAAAAEAAAAAAAAAAQAAAABAAAAAQAAAAQAAAAH
AAAAAQAAAAcAAAAFAAAAAgAAAAUAAAAHAAAAAgAAAAcAAAAGAAAAAwAAAAYAAAAHAAAAAwAA
AAcAAAAEAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAACAPxgAAAAE
AAAA2DNuwQAAgDUZlWZB5AaFwQAAgDUZlWZB2DNuwQAAgDUwHEhBPTVuwTDMlUBWlGZBPQeF
wTDMlUBWlGZB5AaFwQAAgDUwHEhBPTVuwTDMlUBtG0hBPQeFwTDMlUBtG0hBJAAAAAAAAAAB
AAAABQAAAAAAAAAFAAAAAgAAAAAAAAACAAAABgAAAAAAAAAGAAAAAwAAAAAAAAADAAAABAAA
AAAAAAAEAAAAAQAAAAEAAAAEAAAABwAAAAEAAAAHAAAABQAAAAIAAAAFAAAABwAAAAIAAAAH
AAAABgAAAAMAAAAGAAAABwAAAAMAAAAHAAAABAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAEAAA
AAAAAAAAAAAAAAAAAAAAgD8YAAAABAAAAM/1hUEAAIA2WJRmQRETcEEAAIA2WJRmQc/1hUEq
zBXBWJRmQc/1hUEAAIA2MxxIQRETcEEAAIA2MxxIQRETcEEqzBXBWJRmQc/1hUEqzBXBMxxI
QRETcEEqzBXBMxxIQSQAAAAAAAAAAQAAAAUAAAAAAAAABQAAAAIAAAAAAAAAAgAAAAYAAAAA
AAAABgAAAAMAAAAAAAAAAwAAAAQAAAAAAAAABAAAAAEAAAABAAAABAAAAAcAAAABAAAABwAA
AAUAAAACAAAABQAAAAcAAAACAAAABwAAAAYAAAADAAAABgAAAAcAAAADAAAABwAAAAQAAAAQ
AAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAIA/GAAAAAQAAAA7NW7BAACA
NViUZkE8B4XBAACANViUZkHWM27BbcgVwViUZkE7NW7BAACANTMcSEE8B4XBAACANTMcSEHj
BoXBLswVwTMcSEHjBoXBbcgVwViUZkHWM27BLswVwTMcSEEkAAAAAAAAAAEAAAAGAAAAAAAA
AAYAAAACAAAAAAAAAAIAAAADAAAAAAAAAAMAAAAEAAAAAAAAAAQAAAABAAAAAQAAAAQAAAAF
AAAAAQAAAAUAAAAGAAAAAgAAAAYAAAAFAAAAAgAAAAUAAAAHAAAAAgAAAAcAAAADAAAAAwAA
AAcAAAAFAAAAAwAAAAUAAAAEAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAA
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
wTzLFUE+Ug7BPlKOwT/rAkE+Ug7BPAAAAAAAAAABAAAABQAAAAAAAAAFAAAAAgAAAAAAAAAC
AAAABgAAAAAAAAAGAAAAAwAAAAAAAAADAAAABwAAAAAAAAAHAAAACAAAAAAAAAAIAAAABAAA
AAAAAAAEAAAAAQAAAAEAAAAEAAAACQAAAAEAAAAJAAAABQAAAAIAAAAFAAAACQAAAAIAAAAJ
AAAACwAAAAIAAAALAAAACgAAAAIAAAAKAAAABgAAAAMAAAAGAAAACgAAAAMAAAAKAAAABwAA
AAQAAAAIAAAACwAAAAQAAAALAAAACQAAAAcAAAAKAAAACwAAAAcAAAALAAAACAAAABAAAAAA
AAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAgD8kAAAABAAAAM1VDsEFtuBAAACA
Nc1VDsG26wJBAABkug/gFMEszBVBAABkuuzNUcEszBVBAABkulx7VcG26wJBAABkulx7VcEF
tuBAAABkus1VDsEFtuBAPlIOwc1VDsG26wJBPlIOwQ/gFME8yxVBPlIOwezNUcE8yxVBPlIO
wVx7VcG26wJBPlIOwVx7VcEFtuBAPlIOwTwAAAAAAAAAAQAAAAIAAAAAAAAAAgAAAAMAAAAA
AAAAAwAAAAQAAAAAAAAABAAAAAUAAAAAAAAABQAAAAsAAAAAAAAACwAAAAYAAAAAAAAABgAA
AAcAAAAAAAAABwAAAAEAAAABAAAABwAAAAIAAAACAAAABwAAAAgAAAACAAAACAAAAAkAAAAC
AAAACQAAAAMAAAADAAAACQAAAAoAAAADAAAACgAAAAQAAAAEAAAACgAAAAsAAAAEAAAACwAA
AAUAAAAGAAAACwAAAAoAAAAGAAAACgAAAAkAAAAGAAAACQAAAAgAAAAGAAAACAAAAAcAAAAQ
AAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAIA/JAAAAAQAAACQeVVBQ+sC
QT9SDkGQeVVBLLTgQD9SDkGQeVVBQ+sCQQAAAACvIFNBQMsVQT9SDkE0Ug5BLLTgQD9SDkGQ
eVVBLLTgQAAAAACvIFNBQMsVQQAAAADNMhZBQMsVQT9SDkE0Ug5BQ+sCQT9SDkE0Ug5BLLTg
QAAAAADNMhZBQMsVQQAAAAA0Ug5BQ+sCQQAAAAA8AAAAAAAAAAEAAAAFAAAAAAAAAAUAAAAC
AAAAAAAAAAIAAAAGAAAAAAAAAAYAAAADAAAAAAAAAAMAAAAHAAAAAAAAAAcAAAAIAAAAAAAA
AAgAAAAEAAAAAAAAAAQAAAABAAAAAQAAAAQAAAAJAAAAAQAAAAkAAAAFAAAAAgAAAAUAAAAJ
AAAAAgAAAAkAAAALAAAAAgAAAAsAAAAKAAAAAgAAAAoAAAAGAAAAAwAAAAYAAAAKAAAAAwAA
AAoAAAAHAAAABAAAAAgAAAALAAAABAAAAAsAAAAJAAAABwAAAAoAAAALAAAABwAAAAsAAAAI
AAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAACAPyQAAAAEAAAAkHlV
QUHrAkEAAAAAkHlVQSi04EAAAAAAkHlVQUHrAkE/Ug7BryBTQT7LFUEAAAAANFIOQSi04EAA
AAAAkHlVQSi04EA/Ug7BryBTQT7LFUE/Ug7BzTIWQT7LFUEAAAAANFIOQUHrAkEAAAAANFIO
QSi04EA/Ug7BzTIWQT7LFUE/Ug7BNFIOQUHrAkE/Ug7BPAAAAAAAAAABAAAABQAAAAAAAAAF
AAAAAgAAAAAAAAACAAAABgAAAAAAAAAGAAAAAwAAAAAAAAADAAAABwAAAAAAAAAHAAAACAAA
AAAAAAAIAAAABAAAAAAAAAAEAAAAAQAAAAEAAAAEAAAACQAAAAEAAAAJAAAABQAAAAIAAAAF
AAAACQAAAAIAAAAJAAAACwAAAAIAAAALAAAACgAAAAIAAAAKAAAABgAAAAMAAAAGAAAACgAA
AAMAAAAKAAAABwAAAAQAAAAIAAAACwAAAAQAAAALAAAACQAAAAcAAAAKAAAACwAAAAcAAAAL
AAAACAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAgD8kAAAABAAA
AB1SjkBA6wJBAAAAAB1SjkAmtOBAAAAAAB1SjkBA6wJBP1IOwb1EhkA9yxVBAAAAAAAAsLcm
tOBAAAAAAB1SjkAmtOBAP1IOwb1EhkA9yxVBP1IOwaglxj49yxVBAAAAAABA2TlA6wJBAAAA
AABA2TlA6wJBP1IOwQBA2TkmtOBAP1IOwaglxj49yxVBP1IOwTwAAAAAAAAAAQAAAAUAAAAA
AAAABQAAAAIAAAAAAAAAAgAAAAYAAAAAAAAABgAAAAMAAAAAAAAAAwAAAAcAAAAAAAAABwAA
AAgAAAAAAAAACAAAAAQAAAAAAAAABAAAAAEAAAABAAAABAAAAAoAAAABAAAACgAAAAUAAAAC
AAAABQAAAAoAAAACAAAACgAAAAkAAAACAAAACQAAAAsAAAACAAAACwAAAAYAAAADAAAABgAA
AAsAAAADAAAACwAAAAcAAAAEAAAACAAAAAkAAAAEAAAACQAAAAoAAAAHAAAACwAAAAkAAAAH
AAAACQAAAAgAAAAQAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAIA/JwAA
AAQAAABrUA5BuusCQT9SDkFrUA5BLLTgQD9SDkFrUA5BuusCQQAAAADLHwtBQMsVQT9SDkEe
Uo5ALLTgQD9SDkEeUo5ATLLgQNnOgEBrUA5BLLTgQAAAAADLHwtBQMsVQQAAAADTY5xAQMsV
QT9SDkEeUo5AuusCQT9SDkEeUo5ATLLgQAAAAADTY5xAQMsVQQAAAAAeUo5AuusCQQAAAABC
AAAAAAAAAAEAAAAGAAAAAAAAAAYAAAACAAAAAAAAAAIAAAAHAAAAAAAAAAcAAAADAAAAAAAA
AAMAAAAIAAAAAAAAAAgAAAAJAAAAAAAAAAkAAAAEAAAAAAAAAAQAAAABAAAAAQAAAAQAAAAF
AAAAAQAAAAUAAAAKAAAAAQAAAAoAAAAGAAAAAgAAAAYAAAAKAAAAAgAAAAoAAAAMAAAAAgAA
AAwAAAALAAAAAgAAAAsAAAAHAAAAAwAAAAcAAAALAAAAAwAAAAsAAAAIAAAABAAAAAkAAAAM
AAAABAAAAAwAAAAKAAAABAAAAAoAAAAFAAAACAAAAAsAAAAMAAAACAAAAAwAAAAJAAAAEAAA
AAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAACAPyoAAAAEAAAAa1AOQbjrAkEA
AAAAyx8LQT7LFUEAAAAAa1AOQSi04EAAAAAAa1AOQbjrAkE/Ug7B02OcQD7LFUEAAAAAyx8L
QT7LFUE/Ug7BHlKOQCi04EAAAAAAHlKOQEiy4EDE/uLAKzrIQEiy4EA/Ug7Ba1AOQSi04EA/
Ug7BHlKOQLjrAkEAAAAA02OcQD7LFUE/Ug7BHlKOQEiy4EA/Ug7BHlKOQLjrAkE/Ug7BSAAA
AAAAAAABAAAABAAAAAAAAAAEAAAACgAAAAAAAAAKAAAABgAAAAAAAAAGAAAAAgAAAAAAAAAC
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
yxVBP1IOQT5SDsFB6wJBP1IOQXLeFME+yxVB0FWOQHLeFME+yxVBP1IOQTwAAAAAAAAAAQAA
AAQAAAAAAAAABAAAAAIAAAAAAAAAAgAAAAYAAAAAAAAABgAAAAoAAAAAAAAACgAAAAcAAAAA
AAAABwAAAAMAAAAAAAAAAwAAAAUAAAAAAAAABQAAAAEAAAABAAAABQAAAAkAAAABAAAACQAA
AAsAAAABAAAACwAAAAgAAAABAAAACAAAAAQAAAACAAAABAAAAAgAAAACAAAACAAAAAYAAAAD
AAAABwAAAAkAAAADAAAACQAAAAUAAAAGAAAACAAAAAsAAAAGAAAACwAAAAoAAAAHAAAACgAA
AAsAAAAHAAAACwAAAAkAAAAQAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAA
AIA/JAAAAAQAAAA+Ug7BJrTgQDxSjsA+Ug7BJrTgQAAA47k+Ug7BQOsCQTxSjsAAAAAAJrTg
QDxSjsA+Ug7BQOsCQQAA47kAAAAAJrTgQAAA47m8zgnBPcsVQTxSjsAAAAAAQOsCQTxSjsC8
zgnBPcsVQQAA47kAAAAAQOsCQQAA47mQB5y+PcsVQTxSjsCQB5y+PcsVQQAA47k8AAAAAAAA
AAEAAAAEAAAAAAAAAAQAAAACAAAAAAAAAAIAAAAGAAAAAAAAAAYAAAAKAAAAAAAAAAoAAAAH
AAAAAAAAAAcAAAADAAAAAAAAAAMAAAAFAAAAAAAAAAUAAAABAAAAAQAAAAUAAAAJAAAAAQAA
AAkAAAALAAAAAQAAAAsAAAAIAAAAAQAAAAgAAAAEAAAAAgAAAAQAAAAIAAAAAgAAAAgAAAAG
AAAAAwAAAAcAAAAJAAAAAwAAAAkAAAAFAAAABgAAAAgAAAALAAAABgAAAAsAAAAKAAAABwAA
AAoAAAALAAAABwAAAAsAAAAJAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAA
AAAAAACAPycAAAAEAAAAPlIOwQu24EDPVQ5BPlIOwQu24EBee1VBPlIOwbnrAkHPVQ5BAAAA
AAu24EDPVQ5BPlIOwbnrAkFee1VBAAAAAAu24EBee1VBvM4JwU7KFUHPVQ5BAAAAALnrAkHP
VQ5BvM4JwU7KFUFee1VBAAAAALnrAkFee1VB8abWwC/MFUFee1VBkAecvk7KFUHPVQ5BkAec
vi/MFUFee1VBQgAAAAAAAAABAAAABAAAAAAAAAAEAAAAAgAAAAAAAAACAAAABgAAAAAAAAAG
AAAACwAAAAAAAAALAAAABwAAAAAAAAAHAAAAAwAAAAAAAAADAAAABQAAAAAAAAAFAAAAAQAA
AAEAAAAFAAAACQAAAAEAAAAJAAAADAAAAAEAAAAMAAAACgAAAAEAAAAKAAAACAAAAAEAAAAI
AAAABAAAAAIAAAAEAAAACAAAAAIAAAAIAAAABgAAAAMAAAAHAAAACQAAAAMAAAAJAAAABQAA
AAYAAAAIAAAACgAAAAYAAAAKAAAADAAAAAYAAAAMAAAACwAAAAcAAAALAAAADAAAAAcAAAAM
AAAACQAAABAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAgD8qAAAABAAA
AAAAAAANtuBAz1UOQQAAAAANtuBAXntVQQAAAAC66wJBz1UOQTNSDkENtuBAz1UOQQAAAAC6
6wJBXntVQTNSDkENtuBAXntVQVBhxj5AyxVBz1UOQTNSDkG66wJBz1UOQVBhxj5AyxVBXntV
QTNSDkG66wJBXntVQb7H90AwzBVBz1UOQe4dC0EwzBVBz1UOQb7H90AwzBVBXntVQe4dC0Ew
zBVBXntVQUgAAAAAAAAAAQAAAAQAAAAAAAAABAAAAAIAAAAAAAAAAgAAAAYAAAAAAAAABgAA
AAoAAAAAAAAACgAAAAsAAAAAAAAACwAAAAcAAAAAAAAABwAAAAMAAAAAAAAAAwAAAAUAAAAA
AAAABQAAAAEAAAABAAAABQAAAAkAAAABAAAACQAAAA0AAAABAAAADQAAAAwAAAABAAAADAAA
AAgAAAABAAAACAAAAAQAAAACAAAABAAAAAgAAAACAAAACAAAAAYAAAADAAAABwAAAAkAAAAD
AAAACQAAAAUAAAAGAAAACAAAAAwAAAAGAAAADAAAAAoAAAAHAAAACwAAAA0AAAAHAAAADQAA
AAkAAAAKAAAADAAAAA0AAAAKAAAADQAAAAsAAAAQAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAA
AAAAAAAAAAAAAAAAAIA/JAAAAAQAAAAAAAAABbbgQF57VcEAAAAABbbgQM9VDsEAAAAAtusC
QV57VcEzUg5BBbbgQF57VcEAAAAAtusCQc9VDsEzUg5BBbbgQM9VDsFQYcY+LMwVQc9VDsFQ
YcY+PMsVQV57VcEzUg5BtusCQV57VcEzUg5BtusCQc9VDsHuHQtBLMwVQc9VDsHuHQtBLMwV
QV57VcE8AAAAAAAAAAEAAAAEAAAAAAAAAAQAAAACAAAAAAAAAAIAAAAHAAAAAAAAAAcAAAAL
AAAAAAAAAAsAAAAIAAAAAAAAAAgAAAADAAAAAAAAAAMAAAAFAAAAAAAAAAUAAAABAAAAAQAA
AAUAAAAJAAAAAQAAAAkAAAAKAAAAAQAAAAoAAAAGAAAAAQAAAAYAAAAEAAAAAgAAAAQAAAAG
AAAAAgAAAAYAAAAHAAAAAwAAAAgAAAAJAAAAAwAAAAkAAAAFAAAABgAAAAoAAAALAAAABgAA
AAsAAAAHAAAACAAAAAsAAAAKAAAACAAAAAoAAAAJAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAQ
AAAAAAAAAAAAAAAAAAAAAACAPycAAAAEAAAAPlIOwUyy4EDQVY5APlIOwUyy4EA/Ug5BPlIO
wbnrAkHQVY5AAAAAAEyy4EDQVY5APlIOwbnrAkE/Ug5BAAAAAEyy4EBOBZBAAAAAACy04EA/
Ug5BvM4JwU7KFUHQVY5AAAAAALnrAkHQVY5AvM4JwU7KFUE/Ug5BAAAAALnrAkE/Ug5BkAec
vk7KFUHQVY5AkAecvk7KFUE/Ug5BQgAAAAAAAAABAAAABAAAAAAAAAAEAAAAAgAAAAAAAAAC
AAAABwAAAAAAAAAHAAAACwAAAAAAAAALAAAACAAAAAAAAAAIAAAAAwAAAAAAAAADAAAABQAA
AAAAAAAFAAAAAQAAAAEAAAAFAAAABgAAAAEAAAAGAAAACgAAAAEAAAAKAAAADAAAAAEAAAAM
AAAACQAAAAEAAAAJAAAABAAAAAIAAAAEAAAACQAAAAIAAAAJAAAABwAAAAMAAAAIAAAACgAA
AAMAAAAKAAAABgAAAAMAAAAGAAAABQAAAAcAAAAJAAAADAAAAAcAAAAMAAAACwAAAAgAAAAL
AAAADAAAAAgAAAAMAAAACgAAABAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAA
AAAAgD8kAAAABAAAAD5SDsEotOBAAAAAAD5SDsFB6wJBAEDkObzOCcE+yxVBAAAAAAAAAAAo
tOBAAAAAAD5SDsEotOBAP1KOQD5SDsFB6wJBP1KOQLzOCcE+yxVBP1KOQJAHnL4+yxVBAAAA
AAAAAABB6wJBAEDkOQAAAAAotOBAP1KOQJAHnL4+yxVBP1KOQAAAAABB6wJBP1KOQDwAAAAA
AAAAAQAAAAIAAAAAAAAAAgAAAAcAAAAAAAAABwAAAAMAAAAAAAAAAwAAAAkAAAAAAAAACQAA
AAQAAAAAAAAABAAAAAUAAAAAAAAABQAAAAEAAAABAAAABQAAAAYAAAABAAAABgAAAAIAAAAC
AAAABgAAAAoAAAACAAAACgAAAAcAAAADAAAABwAAAAgAAAADAAAACAAAAAsAAAADAAAACwAA
AAkAAAAEAAAACQAAAAsAAAAEAAAACwAAAAoAAAAEAAAACgAAAAYAAAAEAAAABgAAAAUAAAAH
AAAACgAAAAsAAAAHAAAACwAAAAgAAAAQAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAA
AAAAAAAAAIA/JAAAAAQAAAA+Uo7BJrTgQAAAAAA+Uo7BJrTgQD9SjkA+Uo7BQOsCQQAAAAA+
Ug7BJrTgQAAAAAA+Uo7BQOsCQT9SjkA+Ug7BJrTgQD9SjkCw5IzBPcsVQQAAAABy3hTBPcsV
QQAAAAA+Ug7BQOsCQQBA5Dmw5IzBPcsVQT9SjkA+Ug7BQOsCQT9SjkBy3hTBPcsVQT9SjkA8
AAAAAAAAAAEAAAAEAAAAAAAAAAQAAAACAAAAAAAAAAIAAAAGAAAAAAAAAAYAAAAHAAAAAAAA
AAcAAAADAAAAAAAAAAMAAAAFAAAAAAAAAAUAAAABAAAAAQAAAAUAAAAKAAAAAQAAAAoAAAAL
AAAAAQAAAAsAAAAJAAAAAQAAAAkAAAAEAAAAAgAAAAQAAAAJAAAAAgAAAAkAAAAGAAAAAwAA
AAcAAAAIAAAAAwAAAAgAAAAKAAAAAwAAAAoAAAAFAAAABgAAAAkAAAALAAAABgAAAAsAAAAH
AAAABwAAAAsAAAAKAAAABwAAAAoAAAAIAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAA
AAAAAAAAAAAAAACAPyQAAAAEAAAAPlIOwSS04EBee1XBPlIOwSS04EA+Ug7BPlIOwT/rAkFe
e1XBAAAAACS04EBee1XBPlIOwT/rAkE+Ug7BAAAAACS04EA+Ug7BvM4JwTzLFUFee1XBAAAA
AD/rAkFee1XBvM4JwTzLFUE+Ug7BAAAAAD/rAkE+Ug7BkAecvjzLFUFee1XBkAecvjzLFUE+
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</SharedString>
		<SharedString md5="PFZCldh6bgipWdWjn0oM7w==">Q1NHUEhTBwAAAAK2AQxFSgecvKC4F0AVEvTANd9KSQ/NN0FFNoJDUB5DSbDfd8cschZHEAAA
AAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAACAP4cAAAAEAAAAKk+Ev79ih0Cx
CAhCKk+Ev79ih0AgTApCKk+Ev13cnECxCAhCrRpTvwqNiUDGOQZC/34Cv1tZd0DGOQZC5X4j
v3H6a0CxCAhCrRpTvwqNiUDcBAtCKk+Ev13cnEAgTApC5X4jv3H6a0AgTApC/34Cv1tZd0Dc
BAtCrRpTvxKymkDGOQZC5X4jv+RBrkCxCAhC/34Cv7CQqEDGOQZCZv4Av/s5d0DGOQZCAAAA
APyvXkCxCAhCrRpTvxKymkDcBAtC/34Cv7CQqEDcBAtC5X4jv+RBrkAgTApCAAAAAPyvXkAg
TApCAAAAAKPEbEDcBAtCAAAAAB7ntECxCAhCCKu5u5fQrUDGOQZCAAAAAKPEbEDGOQZCfwmz
OwrdbEDGOQZCvHECP1tZd0DGOQZConEjP3H6a0CxCAhCAAAAAInerUDcBAtCAAAAAB7ntEAg
TApConEjP3H6a0AgTApCvHECP1tZd0DcBAtConEjP+RBrkCxCAhCAAAAAInerUDGOQZCag1T
PwqNiUDGOQZCKk+EP79ih0CxCAhCvHECP7CQqEDcBAtConEjP+RBrkAgTApCKk+EP79ih0Ag
TApCag1TPwqNiUDcBAtCvHECP7CQqEDGOQZCI/EAP2CgqEDGOQZCKk+EP13cnECxCAhCag1T
PxKymkDGOQZC6TIsP8JhoUDcBAtCKk+EP13cnEAgTApCag1TPxKymkDcBAtCAgEAAAAAAAAB
AAAABwAAAAAAAAAHAAAAAgAAAAAAAAACAAAACgAAAAAAAAAKAAAAAwAAAAAAAAADAAAABAAA
AAAAAAAEAAAABQAAAAAAAAAFAAAACAAAAAAAAAAIAAAAAQAAAAEAAAAGAAAADwAAAAEAAAAP
AAAABwAAAAEAAAAIAAAACQAAAAEAAAAJAAAABgAAAAIAAAAHAAAAEQAAAAIAAAARAAAACwAA
AAIAAAALAAAADAAAAAIAAAAMAAAACgAAAAMAAAAKAAAADAAAAAMAAAAMAAAAFQAAAAMAAAAV
AAAAHwAAAAMAAAAfAAAAJwAAAAMAAAAnAAAAJgAAAAMAAAAmAAAAKQAAAAMAAAApAAAAIAAA
AAMAAAAgAAAAGAAAAAMAAAAYAAAAFwAAAAMAAAAXAAAAFgAAAAMAAAAWAAAADQAAAAMAAAAN
AAAABAAAAAQAAAANAAAABQAAAAUAAAAOAAAAEgAAAAUAAAASAAAACAAAAAUAAAANAAAADgAA
AAYAAAAJAAAAEwAAAAYAAAATAAAAHQAAAAYAAAAdAAAAJQAAAAYAAAAlAAAALAAAAAYAAAAs
AAAAKgAAAAYAAAAqAAAAIgAAAAYAAAAiAAAAGgAAAAYAAAAaAAAAEAAAAAYAAAAQAAAADwAA
AAcAAAAQAAAAEQAAAAcAAAAPAAAAEAAAAAgAAAASAAAACQAAAAkAAAASAAAAEwAAAAsAAAAR
AAAAGwAAAAsAAAAbAAAAFAAAAAsAAAAUAAAAFQAAAAsAAAAVAAAADAAAAA0AAAAWAAAADgAA
AA4AAAAWAAAAFwAAAA4AAAAXAAAAGAAAAA4AAAAYAAAAGQAAAA4AAAAZAAAAHAAAAA4AAAAc
AAAAEgAAABAAAAAaAAAAGwAAABAAAAAbAAAAEQAAABIAAAAcAAAAHQAAABIAAAAdAAAAEwAA
ABQAAAAeAAAAHwAAABQAAAAfAAAAFQAAABQAAAAbAAAAIwAAABQAAAAjAAAAHgAAABgAAAAg
AAAAIQAAABgAAAAhAAAAGQAAABkAAAAhAAAAJAAAABkAAAAkAAAAHAAAABoAAAAiAAAAIwAA
ABoAAAAjAAAAGwAAABwAAAAkAAAAHQAAAB0AAAAkAAAAJQAAAB4AAAAmAAAAJwAAAB4AAAAn
AAAAHwAAAB4AAAAjAAAAKwAAAB4AAAArAAAAKAAAAB4AAAAoAAAAJgAAACAAAAApAAAAKAAA
ACAAAAAoAAAAIQAAACEAAAAoAAAAKwAAACEAAAArAAAAJAAAACIAAAAqAAAAKwAAACIAAAAr
AAAAIwAAACQAAAArAAAALAAAACQAAAAsAAAAJQAAACYAAAAoAAAAKQAAACoAAAAsAAAAKwAA
ABAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAgD9gAAAABAAAAAbZir9G
2oZAbcsLQr95Ar9cW3dA+gQLQkuTK7/lNWlAbcsLQgbZir9G2oZALtAPQgbZir/XZJ1AbcsL
QignU7+kjYlA+gQLQgAAAAAXwWxA+gQLQgAAAACkQ1tAbcsLQgAAAAD8P1tALtAPQkuTK7/l
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
AAAADwAAABQAAAAVAAAADwAAABUAAAAQAAAAEgAAABYAAAATAAAAEwAAABYAAAAZAAAAEwAA
ABkAAAAXAAAAFAAAABcAAAAYAAAAFAAAABgAAAAVAAAAFwAAABkAAAAYAAAAEAAAAAAAAAAA
AAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAACAP1cAAAAEAAAABtmKvxLZhkBM0A9CS5Mr
v5QyaUBM0A9CdvpQvyQPdkBimxRCBtmKvxLZhkBimxRCBtmKvwhmnUBM0A9CAAAAAKJDW0BM
0A9CAAAAAPo/W0BimxRCS5Mrv5QyaUBimxRCBtmKvwhmnUBimxRCofFKv5hCqkBM0A9CS5Mr
P5QyaUBM0A9CTj7ePhZIZEBimxRCbEk7vzT0rEBimxRCS5Mrv9Clr0BM0A9CofFKPwT5c0BM
0A9CbEk7P8yVbkBimxRCS5MrP5QyaUBimxRCS5Mrv9Clr0BimxRCTj7evg8bskBimxRCAAAA
AB2ftkBM0A9CBtmKPxLZhkBM0A9CBtmKPxLZhkBimxRCAAAAAEmdtkBimxRCkdBxPt4ptEBi
mxRCS5MrP9Clr0BimxRCS5MrP9Clr0BM0A9CBtmKPwhmnUBM0A9CBtmKPwhmnUBimxRCdvpQ
P4g3qUBimxRCogAAAAAAAAABAAAAAgAAAAAAAAACAAAAAwAAAAAAAAADAAAACAAAAAAAAAAI
AAAABAAAAAAAAAAEAAAACQAAAAAAAAAJAAAADQAAAAAAAAANAAAAEwAAAAAAAAATAAAAGQAA
AAAAAAAZAAAAGgAAAAAAAAAaAAAAFAAAAAAAAAAUAAAADgAAAAAAAAAOAAAACgAAAAAAAAAK
AAAABQAAAAAAAAAFAAAAAQAAAAEAAAAFAAAABgAAAAEAAAAGAAAABwAAAAEAAAAHAAAAAgAA
AAIAAAAHAAAABgAAAAIAAAAGAAAACwAAAAIAAAALAAAAEAAAAAIAAAAQAAAADwAAAAIAAAAP
AAAAFQAAAAIAAAAVAAAAGwAAAAIAAAAbAAAAHAAAAAIAAAAcAAAAGAAAAAIAAAAYAAAAFwAA
AAIAAAAXAAAAFgAAAAIAAAAWAAAAEgAAAAIAAAASAAAAEQAAAAIAAAARAAAADAAAAAIAAAAM
AAAACAAAAAIAAAAIAAAAAwAAAAQAAAAIAAAACQAAAAUAAAAKAAAABgAAAAYAAAAKAAAACwAA
AAgAAAAMAAAACQAAAAkAAAAMAAAADQAAAAoAAAAOAAAADwAAAAoAAAAPAAAAEAAAAAoAAAAQ
AAAACwAAAAwAAAARAAAADQAAAA0AAAARAAAAEgAAAA0AAAASAAAAEwAAAA4AAAAUAAAAFQAA
AA4AAAAVAAAADwAAABIAAAAWAAAAEwAAABMAAAAWAAAAFwAAABMAAAAXAAAAGAAAABMAAAAY
AAAAGQAAABQAAAAaAAAAGwAAABQAAAAbAAAAFQAAABgAAAAcAAAAGQAAABkAAAAcAAAAGgAA
ABoAAAAcAAAAGwAAABAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAgD8h
AAAABAAAACL0JUBnD9BAgmeZQQAABTpnD9BA5HC0QQAABTqZ/P5AgmeZQUzs/z82MepAgmeZ
QUQS/j8ckOlA5HC0QRoaJEBnD9BA5HC0QQAABTpnD9BA5wO6QQAABTqxNP5A5HC0QTCZIz/R
NPtAuP+9QTCZIz9nD9BAuP+9QQAABTrRNPtAuP+9QTYAAAAAAAAAAQAAAAIAAAAAAAAAAgAA
AAMAAAAAAAAAAwAAAAQAAAAAAAAABAAAAAUAAAAAAAAABQAAAAkAAAAAAAAACQAAAAYAAAAA
AAAABgAAAAEAAAABAAAABgAAAAoAAAABAAAACgAAAAcAAAABAAAABwAAAAIAAAACAAAABwAA
AAgAAAACAAAACAAAAAMAAAADAAAACAAAAAQAAAAEAAAACAAAAAUAAAAFAAAACAAAAAkAAAAG
AAAACQAAAAoAAAAHAAAACgAAAAgAAAAIAAAACgAAAAkAAAAQAAAAAAAAAAAAAAAAAAAAAAAA
ABAAAAAAAAAAAAAAAAAAAAAAAIA/JwAAAAQAAAAAAIA0gZDWQORwtEEA8IS50TT7QLj/vUEA
AIA0Zw/QQORwtEEA8IS5mfz+QIJnmUEA8IS5sTT+QORwtEGljCO/Zw/QQLj/vUEA8IS5Zw/Q
QOcDukGljCO/0TT7QLj/vUEh9CXAZw/QQIJnmUG08v+/NjHqQIJnmUE2HiTAZw/QQORwtEGg
GP6/HJDpQORwtEEyChDA8iPfQIJnmUFCAAAAAAAAAAEAAAACAAAAAAAAAAIAAAADAAAAAAAA
AAMAAAAEAAAAAAAAAAQAAAABAAAAAQAAAAUAAAAGAAAAAQAAAAYAAAACAAAAAQAAAAQAAAAH
AAAAAQAAAAcAAAAFAAAAAgAAAAYAAAAFAAAAAgAAAAUAAAAKAAAAAgAAAAoAAAAIAAAAAgAA
AAgAAAADAAAAAwAAAAgAAAAMAAAAAwAAAAwAAAAJAAAAAwAAAAkAAAAHAAAAAwAAAAcAAAAE
AAAABQAAAAcAAAAKAAAABwAAAAkAAAALAAAABwAAAAsAAAAKAAAACAAAAAoAAAAMAAAACQAA
AAwAAAALAAAACgAAAAsAAAAMAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAA
AAAAAACAPy0AAAAEAAAAgIEjv+m6EkFgXMZBgIEjP+m6EkFgXMZBgIEjv+m6EkGumuJBOB5h
vzDDO0HyBddBjOMivx9uPUHyBddBax3kvrBMNkFhANRBax3kPrBMNkFhANRBjOMiPx9uPUHy
BddBOB5hPzDDO0HyBddBgIEjP+m6EkGumuJBpwdhvzDDO0GumuJBjOMivx9uPUGumuJBjOMi
Px9uPUGumuJBOB5hPzDDO0H5LNtB7xJhPzDDO0GumuJBTgAAAAAAAAABAAAACQAAAAAAAAAJ
AAAAAgAAAAAAAAACAAAAAwAAAAAAAAADAAAABAAAAAAAAAAEAAAABQAAAAAAAAAFAAAABgAA
AAAAAAAGAAAAAQAAAAEAAAAGAAAABwAAAAEAAAAHAAAACAAAAAEAAAAIAAAADQAAAAEAAAAN
AAAACQAAAAIAAAAJAAAADgAAAAIAAAAOAAAADAAAAAIAAAAMAAAACwAAAAIAAAALAAAACgAA
AAIAAAAKAAAAAwAAAAMAAAAKAAAACwAAAAMAAAALAAAABAAAAAQAAAALAAAADAAAAAQAAAAM
AAAABwAAAAQAAAAHAAAABgAAAAQAAAAGAAAABQAAAAcAAAAMAAAADQAAAAcAAAANAAAACAAA
AAkAAAANAAAADgAAAAwAAAAOAAAADQAAABAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAA
AAAAAAAAAAAAgD+EAAAABAAAAAAAAABB3q1A5BnmQed+Iz+PCtBA15niQaRxI7+PCtBA15ni
QQF/Ar8tkahA5BnmQQF/Aj8tkahA5BnmQbAaUz9jtZpA5BnmQSxPhD9V4JxA15niQed+Iz+P
CtBAjO3SQaRxI7+PCtBAjO3SQSxPhL9V4JxA15niQW0NU79jtZpA5BnmQWhyML+tqaBA5Bnm
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
AAAAFgAAACEAAAAXAAAAGAAAACIAAAAjAAAAGAAAABsAAAAiAAAAGQAAACMAAAAkAAAAGQAA
ACQAAAAlAAAAGQAAACUAAAAeAAAAGwAAACYAAAAiAAAAHAAAACgAAAApAAAAHAAAACkAAAAn
AAAAHwAAACcAAAAiAAAAHwAAACIAAAAgAAAAIAAAACIAAAAqAAAAIgAAACcAAAArAAAAIgAA
ACsAAAAjAAAAIgAAACYAAAAqAAAAIwAAACsAAAAkAAAAJAAAACsAAAAsAAAAJwAAACkAAAAr
AAAAKQAAAC0AAAArAAAAKwAAAC0AAAAsAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAA
AAAAAAAAAAAAAACAPx4AAAAEAAAAEIsjv4oR0ECOAb5BEIsjv/My+0COAb5BEIsjP4oR0ECO
Ab5BEIsjv4oR0EDEmeJBEIsjP/My+0COAb5BEIsjv+m6EkEoXcZBEIsjP4oR0EDEmeJBEIsj
v+m6EkHEmeJBEIsjP+m6EkEoXcZBEIsjP+m6EkHEmeJBMAAAAAAAAAABAAAABAAAAAAAAAAE
AAAAAgAAAAAAAAACAAAABgAAAAAAAAAGAAAAAwAAAAAAAAADAAAABwAAAAAAAAAHAAAABQAA
AAAAAAAFAAAAAQAAAAEAAAAFAAAACAAAAAEAAAAIAAAABAAAAAIAAAAEAAAACAAAAAIAAAAI
AAAACQAAAAIAAAAJAAAABgAAAAMAAAAGAAAACQAAAAMAAAAJAAAABwAAAAUAAAAHAAAACQAA
AAUAAAAJAAAACAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAgD8q
AAAABAAAAD6Dx7/EXXPAaR8Bwj6Dx7857kLAMkf5wT6Dx7+cDGC/DtIAwhmUo7/Ymh2/xTkG
whmUo7/L+RHAxTkGwj6Dxz/EXXPAaR8Bwj6Dxz857kLAMkf5wT6Dx7/Ymh2/Mkf5wT6Dx7/Y
mh2/wxL+wRmUoz/Ymh2/xTkGwhmUoz/L+RHAxTkGwj6Dxz+cDGC/DtIAwj6Dxz/Ymh2/Mkf5
wT6Dxz/Ymh2/wxL+wUgAAAAAAAAAAQAAAAcAAAAAAAAABwAAAAgAAAAAAAAACAAAAAIAAAAA
AAAAAgAAAAMAAAAAAAAAAwAAAAQAAAAAAAAABAAAAAoAAAAAAAAACgAAAAUAAAAAAAAABQAA
AAYAAAAAAAAABgAAAAEAAAABAAAABgAAAAwAAAABAAAADAAAAAcAAAACAAAACAAAAAMAAAAD
AAAACAAAAAcAAAADAAAABwAAAAwAAAADAAAADAAAAA0AAAADAAAADQAAAAkAAAADAAAACQAA
AAoAAAADAAAACgAAAAQAAAAFAAAACgAAAAkAAAAFAAAACQAAAAsAAAAFAAAACwAAAA0AAAAF
AAAADQAAAAwAAAAFAAAADAAAAAYAAAAJAAAADQAAAAsAAAAQAAAAAAAAAAAAAAAAAAAAAAAA
ABAAAAAAAAAAAAAAAAAAAAAAAIA/JwAAAAQAAABEkbK/ZwMcQJhmmUAAAAAAYPj9P5hmmUAt
rAPA+fndP/DGrUDYZyTAZwMcQPDGrUDJgLI/ZwMcQJhmmUAAAAAAbGWIP/DGrUDwowNA+fnd
P/DGrUDLiwLAXQnhP5hmGUESJyLAZwMcQJhmGUHYZyRAZwMcQPDGrUCNgwJAXQnhP5hmGUEA
AAAA3TqMP5hmGUESJyJAZwMcQJhmGUFCAAAAAAAAAAEAAAACAAAAAAAAAAIAAAADAAAAAAAA
AAMAAAAIAAAAAAAAAAgAAAAMAAAAAAAAAAwAAAAJAAAAAAAAAAkAAAAEAAAAAAAAAAQAAAAB
AAAAAQAAAAUAAAACAAAAAQAAAAQAAAAGAAAAAQAAAAYAAAAFAAAAAgAAAAUAAAAHAAAAAgAA
AAcAAAADAAAAAwAAAAcAAAAIAAAABAAAAAkAAAAGAAAABQAAAAYAAAAKAAAABQAAAAoAAAAL
AAAABQAAAAsAAAAHAAAABgAAAAkAAAAKAAAABwAAAAsAAAAKAAAABwAAAAoAAAAMAAAABwAA
AAwAAAAIAAAACQAAAAwAAAAKAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAA
AAAAAACAPxUAAAAEAAAAUR/KvzCWMsGYZpnBUR/KvxhDJsGUD7DBUR/KPzCWMsGYZpnBUR/K
v5CF0MCYZpnBUR/KPxhDJsGUD7DBUR/KPwON0MCYZpnBAMdTP5CF0MCYZpnBHgAAAAAAAAAB
AAAABAAAAAAAAAAEAAAAAgAAAAAAAAACAAAABQAAAAAAAAAFAAAABgAAAAAAAAAGAAAAAwAA
AAAAAAADAAAAAQAAAAEAAAADAAAABgAAAAEAAAAGAAAABAAAAAIAAAAEAAAABQAAAAQAAAAG
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
AAAACwAAAAIAAAALAAAADAAAAAIAAAAMAAAACAAAAAIAAAAIAAAABwAAAAIAAAAHAAAABgAA
AAMAAAAHAAAACAAAAAMAAAAIAAAACQAAAAMAAAAGAAAABwAAAAQAAAAKAAAADAAAAAQAAAAM
AAAACwAAAAgAAAAMAAAACgAAAAgAAAAKAAAACQAAABAAAAAAAAAAAAAAAAAAAAAAAAAAEAAA
AAAAAAAAAAAAAAAAAAAAgD8YAAAABAAAAFEfyr8fbj3B/2+FwVEfyj8fbj3B/2+FwVEfyr8e
3dvAZtRfwVEfyr8bkzLBl2aZwVEfyj8bkzLBl2aZwVEfyj8e3dvAZtRfwVEfyr8e3dvAl2aZ
wVEfyj8e3dvAl2aZwSQAAAAAAAAAAQAAAAUAAAAAAAAABQAAAAIAAAAAAAAAAgAAAAYAAAAA
AAAABgAAAAMAAAAAAAAAAwAAAAQAAAAAAAAABAAAAAEAAAABAAAABAAAAAcAAAABAAAABwAA
AAUAAAACAAAABQAAAAcAAAACAAAABwAAAAYAAAADAAAABgAAAAcAAAADAAAABwAAAAQAAAAQ
AAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAIA/IQAAAAQAAAC2kaO/2pod
v8U5BsK2kaM/2podv8U5BsJpgce/2podv+wR/sFO/96/1AxFQMU5BsJO/94/1AxFQMU5BsJp
gcc/2podv+wR/sFpgce/2podv+QZ5sF8Ct+/1AxFQOQZ5sF8Ct8/1AxFQKyh7cFpgcc/2pod
v+QZ5sF8Ct8/1AxFQOQZ5sE2AAAAAAAAAAEAAAAFAAAAAAAAAAUAAAAJAAAAAAAAAAkAAAAG
AAAAAAAAAAYAAAACAAAAAAAAAAIAAAADAAAAAAAAAAMAAAAEAAAAAAAAAAQAAAABAAAAAQAA
AAQAAAAFAAAAAgAAAAYAAAAHAAAAAgAAAAcAAAADAAAAAwAAAAcAAAAKAAAAAwAAAAoAAAAI
AAAAAwAAAAgAAAAEAAAABAAAAAgAAAAFAAAABQAAAAgAAAAKAAAABQAAAAoAAAAJAAAABgAA
AAkAAAAKAAAABgAAAAoAAAAHAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAA
AAAAAACAPz8AAAAEAAAAAAAAAIQm8L8glNbBrjQLP4Qm8L82EdTBrjQLv4Qm8L82EdTBAAAA
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
AAMAAAAGAAAACQAAAAMAAAAJAAAACgAAAAMAAAAKAAAAEQAAAAMAAAARAAAACAAAAAQAAAAI
AAAAEwAAAAQAAAATAAAACwAAAAQAAAALAAAADAAAAAQAAAAMAAAADQAAAAYAAAAPAAAAGAAA
AAYAAAAYAAAAEAAAAAYAAAAQAAAACQAAAAcAAAAOAAAAGAAAAAcAAAAYAAAADwAAAAgAAAAR
AAAAEgAAAAgAAAASAAAAEwAAAAkAAAAQAAAAFAAAAAkAAAAUAAAACgAAAAoAAAAUAAAAFQAA
AAoAAAAVAAAAEQAAAAsAAAATAAAAHgAAAAsAAAAeAAAAFgAAAAsAAAAWAAAAFwAAAAsAAAAX
AAAADQAAAAsAAAANAAAADAAAAA4AAAAZAAAAIQAAAA4AAAAhAAAAGAAAABAAAAAYAAAAIgAA
ABAAAAAiAAAAJgAAABAAAAAmAAAAJQAAABAAAAAlAAAAJwAAABAAAAAnAAAAIwAAABAAAAAj
AAAAHwAAABAAAAAfAAAAHQAAABAAAAAdAAAAHAAAABAAAAAcAAAAGwAAABAAAAAbAAAAGgAA
ABAAAAAaAAAAFQAAABAAAAAVAAAAFAAAABEAAAAVAAAAGgAAABEAAAAaAAAAGwAAABEAAAAb
AAAAEgAAABIAAAAbAAAAHAAAABIAAAAcAAAAHQAAABIAAAAdAAAAEwAAABMAAAAdAAAAHwAA
ABMAAAAfAAAAHgAAABYAAAAeAAAAHwAAABYAAAAfAAAAFwAAABcAAAAfAAAAJAAAABcAAAAk
AAAAIAAAABgAAAAhAAAAIgAAABkAAAAgAAAAJAAAABkAAAAkAAAAJwAAABkAAAAnAAAAJQAA
ABkAAAAlAAAAIQAAAB8AAAAjAAAAJAAAACEAAAAlAAAAJgAAACEAAAAmAAAAIgAAACMAAAAn
AAAAJAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAgD8nAAAABAAA
AGQ+vT8kWkRAAAAAAGQ+vT8kWkRAmGaZwLb5EsAkWkRAAAAAAGQ+vT8gWPO/AAAAAMU7vb8k
WkRAmGaZwGQ+vT8gWPO/mGaZwLb5EsAkWkRASYWUwLb5EsBGkhNAAAAAAMU7vb8gWPO/AAAA
AMU7vb8gWPO/mGaZwLb5EsAAHihASYWUwLb5EsBGkhNAIDyKwLb5EsBYlBlAynyRwEIAAAAA
AAAAAQAAAAQAAAAAAAAABAAAAAYAAAAAAAAABgAAAAIAAAAAAAAAAgAAAAcAAAAAAAAABwAA
AAgAAAAAAAAACAAAAAMAAAAAAAAAAwAAAAUAAAAAAAAABQAAAAEAAAABAAAABQAAAAkAAAAB
AAAACQAAAAQAAAACAAAABgAAAAoAAAACAAAACgAAAAwAAAACAAAADAAAAAsAAAACAAAACwAA
AAcAAAADAAAACAAAAAkAAAADAAAACQAAAAUAAAAEAAAACQAAAAoAAAAEAAAACgAAAAYAAAAH
AAAACwAAAAkAAAAHAAAACQAAAAgAAAAJAAAACwAAAAwAAAAJAAAADAAAAAoAAAA=</SharedString>
		<SharedString md5="q3NWt6od6We8loSdYnixLg==">Q1NHUEhTBwAAAAIucZ5DyelyuZVCtD6VTBO/4k8rRs4rPz8Zfea9aHO8RFAKYERbghhGEAAA
AAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAACAPyoAAAAEAAAAUHR/v5/bE0GA
D4m/XKiZv0eFDEGiBIm/UHR/vyYxH0GAD4m/XKiZP0eFDEGiBIm/XKiZv0eFDEGjix8/XKiZ
vyYxH0GiBIm/3eP9vlGYIEGiBIm/XKiZPyYxH0GiBIm/XKiZP0eFDEGjix8/XKiZvyYxH0Gj
ix8/UHR/P0eFDEGClh8/3eP9vlGYIEGs2L2+XKiZPyYxH0Gjix8/UHR/P8rvFEGClh8/SAAA
AAAAAAABAAAABQAAAAAAAAAFAAAAAgAAAAAAAAACAAAABwAAAAAAAAAHAAAAAwAAAAAAAAAD
AAAAAQAAAAEAAAAEAAAACQAAAAEAAAAJAAAABQAAAAEAAAADAAAACAAAAAEAAAAIAAAACgAA
AAEAAAAKAAAABAAAAAIAAAAGAAAABwAAAAIAAAAFAAAABgAAAAMAAAAHAAAADAAAAAMAAAAM
AAAACAAAAAQAAAAKAAAADQAAAAQAAAANAAAACQAAAAUAAAAJAAAACwAAAAUAAAALAAAABgAA
AAYAAAALAAAADAAAAAYAAAAMAAAABwAAAAgAAAAMAAAADQAAAAgAAAANAAAACgAAAAkAAAAN
AAAADAAAAAkAAAAMAAAACwAAABAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAA
AAAAgD8kAAAABAAAAFyomb9HhQxB4q+OwFyomb9HhQxB1vcwwFyomb8mMR9B4q+OwFyomT9H
hQxB4q+OwFB0f79HhQxBHvUwwFyomb8mMR9BHvUwwN3j/b5RmCBBPOqBwFyomT8mMR9B4q+O
wFyomT9HhQxBHvUwwIV1iz8mMR9BHvUwwN3j/b5RmCBB1vcwwFyomT8mMR9B1vcwwDwAAAAA
AAAAAQAAAAUAAAAAAAAABQAAAAIAAAAAAAAAAgAAAAcAAAAAAAAABwAAAAMAAAAAAAAAAwAA
AAgAAAAAAAAACAAAAAQAAAAAAAAABAAAAAEAAAABAAAABAAAAAUAAAACAAAABQAAAAoAAAAC
AAAACgAAAAYAAAACAAAABgAAAAcAAAADAAAABwAAAAsAAAADAAAACwAAAAgAAAAEAAAACAAA
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
AAYAAAAKAAAABwAAAAcAAAAKAAAACAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAA
AAAAAAAAAAAAgD8kAAAABAAAAFyomb8x0QtBHvUwwFyomb9HhQxBHvUwwO6O+T6LzwhBHvUw
wFyomb965PBAr+8wwFyomb9HhQxBfg+Jv9mJYz9HhQxBHvUwwFB0fz+XhAhBHvUwwFyomT96
5PBAr+8wwFyomb965PBAfg+Jv1yomT9HhQxBfg+Jv1yomT9HhQxBr+8wwFyomT965PBA7RSJ
vzwAAAAAAAAAAQAAAAUAAAAAAAAABQAAAAYAAAAAAAAABgAAAAIAAAAAAAAAAgAAAAMAAAAA
AAAAAwAAAAgAAAAAAAAACAAAAAQAAAAAAAAABAAAAAEAAAABAAAABAAAAAkAAAABAAAACQAA
AAoAAAABAAAACgAAAAUAAAACAAAABgAAAAMAAAADAAAABgAAAAcAAAADAAAABwAAAAsAAAAD
AAAACwAAAAgAAAAEAAAACAAAAAkAAAAFAAAACgAAAAYAAAAGAAAACgAAAAcAAAAHAAAACgAA
AAkAAAAHAAAACQAAAAsAAAAIAAAACwAAAAkAAAAQAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAA
AAAAAAAAAAAAAAAAAIA/GwAAAAQAAACooJm/UZggwAhRpb5cqJk/UZggwAhRpb6ooJm/UZgg
wFIbQ0BcqJm/kO+avghRpb5cqJk/AAAAAAhRpb5cqJk/UZggwFIbQ0BcqJm/AAAAAO5oKEBc
qJm/AAAAAAhRpb5cqJk/AAAAAO5oKEAqAAAAAAAAAAEAAAAFAAAAAAAAAAUAAAACAAAAAAAA
AAIAAAADAAAAAAAAAAMAAAAHAAAAAAAAAAcAAAAEAAAAAAAAAAQAAAABAAAAAQAAAAQAAAAI
AAAAAQAAAAgAAAAFAAAAAgAAAAUAAAAIAAAAAgAAAAgAAAAGAAAAAgAAAAYAAAADAAAAAwAA
AAYAAAAHAAAABAAAAAcAAAAGAAAABAAAAAYAAAAIAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAQ
AAAAAAAAAAAAAAAAAAAAAACAPxgAAAAEAAAAXKiZv1KYIEC952m/XKiZP1KYIEC952m/XKiZ
v1KYIEDYzBdAXKiZv06WoEC952m/XKiZP06WoEC952m/XKiZP1KYIEDYzBdAXKiZv06WoEBX
UhRAXKiZP06WoEBXUhRAJAAAAAAAAAABAAAABQAAAAAAAAAFAAAAAgAAAAAAAAACAAAABgAA
AAAAAAAGAAAAAwAAAAAAAAADAAAABAAAAAAAAAAEAAAAAQAAAAEAAAAEAAAABwAAAAEAAAAH
AAAABQAAAAIAAAAFAAAABwAAAAIAAAAHAAAABgAAAAMAAAAGAAAABwAAAAMAAAAHAAAABAAA
ABAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAgD8YAAAABAAAAFyomb9U
mqBAP7GOwFyomT9UmqBAP7GOwFyomb9UmqBAXBqJv1yomb924vBA0KuOwFyomT924vBA0KuO
wFyomT9UmqBAXBqJv1yomb924vBAXBqJv1yomT924vBAXBqJvyQAAAAAAAAAAQAAAAUAAAAA
AAAABQAAAAIAAAAAAAAAAgAAAAYAAAAAAAAABgAAAAMAAAAAAAAAAwAAAAQAAAAAAAAABAAA
AAEAAAABAAAABAAAAAcAAAABAAAABwAAAAUAAAACAAAABQAAAAcAAAACAAAABwAAAAYAAAAD
AAAABgAAAAcAAAADAAAABwAAAAQAAAAQAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAA
AAAAAAAAAIA/HgAAAAQAAABcqJm/VJqgQIAPib9cqJm/gAPSQIAPib9cqJk/gAPSQIAPib9c
qJk/VJqgQKIEib9cqJm/VJqgQI5NFEBcqJm/duLwQKIEib9cqJk/duLwQKIEib9cqJk/VJqg
QI5NFEBcqJm/duLwQP1SFEBcqJk/duLwQP1SFEAwAAAAAAAAAAEAAAACAAAAAAAAAAIAAAAD
AAAAAAAAAAMAAAAHAAAAAAAAAAcAAAAEAAAAAAAAAAQAAAAIAAAAAAAAAAgAAAAFAAAAAAAA
AAUAAAABAAAAAQAAAAUAAAAGAAAAAQAAAAYAAAACAAAAAgAAAAYAAAAJAAAAAgAAAAkAAAAH
AAAAAgAAAAcAAAADAAAABAAAAAcAAAAJAAAABAAAAAkAAAAIAAAABQAAAAgAAAAJAAAABQAA
AAkAAAAGAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAACAPxsAAAAE
AAAAXKiZvwAAAAAD0Wm/XKiZv98SnT/B52m/XKiZPwAAAAAD0Wm/XKiZvwAAAACgbihAXKiZ
v1GYIEAD0Wm/XKiZP1GYIEAD0Wm/XKiZPwAAAACgbihAXKiZv1GYIEDIyxdAXKiZP1GYIEDI
yxdAKgAAAAAAAAABAAAAAgAAAAAAAAACAAAABgAAAAAAAAAGAAAAAwAAAAAAAAADAAAABwAA
AAAAAAAHAAAABAAAAAAAAAAEAAAAAQAAAAEAAAAEAAAABQAAAAEAAAAFAAAAAgAAAAIAAAAF
AAAACAAAAAIAAAAIAAAABgAAAAMAAAAGAAAACAAAAAMAAAAIAAAABwAAAAQAAAAHAAAACAAA
AAQAAAAIAAAABQAAABAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAgD8e
AAAABAAAAFuomb9OlqDA4B2lvluomb9SmCDA4B2lvluomT9OlqDA4B2lvqigmb9OlqDA9JRq
QFuomb/NfT7A8QdIQFuomT9SmCDA4B2lvluomb9SmCDAoBVDQFuomT/NfT7A8QdIQKigmT9O
lqDA9JRqQFuomT9SmCDAoBVDQDAAAAAAAAAAAQAAAAUAAAAAAAAABQAAAAIAAAAAAAAAAgAA
AAgAAAAAAAAACAAAAAMAAAAAAAAAAwAAAAQAAAAAAAAABAAAAAYAAAAAAAAABgAAAAEAAAAB
AAAABgAAAAkAAAABAAAACQAAAAUAAAACAAAABQAAAAkAAAACAAAACQAAAAcAAAACAAAABwAA
AAgAAAADAAAABgAAAAQAAAADAAAACAAAAAkAAAADAAAACQAAAAYAAAAHAAAACQAAAAgAAAAQ
AAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAIA/HgAAAAQAAABcqJk/UZig
QMDnab9cqJk/UZigQGiujsBcqJm/UZigQMDnab9cqJk/AAAAAMDnab9cqJm/UZigQGiujsBc
qJk/QFfoP0CxjsBcqJm/AAAAAMDnab9cqJk/AAAAACD2icBcqJm/QFfoP0CxjsBcqJm/AAAA
ACD2icAwAAAAAAAAAAEAAAAEAAAAAAAAAAQAAAACAAAAAAAAAAIAAAAGAAAAAAAAAAYAAAAD
AAAAAAAAAAMAAAAHAAAAAAAAAAcAAAAFAAAAAAAAAAUAAAABAAAAAQAAAAUAAAAIAAAAAQAA
AAgAAAAEAAAAAgAAAAQAAAAIAAAAAgAAAAgAAAAJAAAAAgAAAAkAAAAGAAAAAwAAAAYAAAAJ
AAAAAwAAAAkAAAAHAAAABQAAAAcAAAAJAAAABQAAAAkAAAAIAAAAEAAAAAAAAAAAAAAAAAAA
AAAAAAAQAAAAAAAAAAAAAAAAAAAAAACAPycAAAAEAAAAXKiZPwAAAAAwhKW+XKiZPwAAAACb
9InAXKiZvwAAAAAwhKW+XKiZP1GYoMAwhKW+XKiZPzqXNL+JHojAXKiZvwAAAACb9InAXKiZ
v5Dvmr4whKW+qKCZv1GYoMAwhKW+XKiZP1GYoMCC317AXKiZPxbOlMBkHmXAXKiZvzqXNL+J
HojAqKCZv1GYoMCC317AqKCZvxbOlMBkHmXAQgAAAAAAAAABAAAABQAAAAAAAAAFAAAAAgAA
AAAAAAACAAAABgAAAAAAAAAGAAAABwAAAAAAAAAHAAAAAwAAAAAAAAADAAAACAAAAAAAAAAI
AAAACQAAAAAAAAAJAAAABAAAAAAAAAAEAAAAAQAAAAEAAAAEAAAACgAAAAEAAAAKAAAABQAA
AAIAAAAFAAAACgAAAAIAAAAKAAAABgAAAAMAAAAHAAAACwAAAAMAAAALAAAACAAAAAQAAAAJ
AAAADAAAAAQAAAAMAAAACgAAAAYAAAAKAAAABwAAAAcAAAAKAAAACwAAAAgAAAALAAAADAAA
AAgAAAAMAAAACQAAAAoAAAAMAAAACwAAABAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAA
AAAAAAAAAAAAgD8eAAAABAAAAKigmb9OliDBJsUJwFuomb9SmKDAbeUswFuomb9SmKDADOZe
wKigmT9OliDBJsUJwKigmb89VQDBQLGOQKigmb9SmKDAWYlqQFuomT9SmKDADOZewKigmT89
VQDBQLGOQFuomT9SmKDAbeUswKigmT9SmKDAWYlqQDAAAAAAAAAAAQAAAAIAAAAAAAAAAgAA
AAYAAAAAAAAABgAAAAMAAAAAAAAAAwAAAAcAAAAAAAAABwAAAAQAAAAAAAAABAAAAAEAAAAB
AAAABAAAAAUAAAABAAAABQAAAAkAAAABAAAACQAAAAgAAAABAAAACAAAAAYAAAABAAAABgAA
AAIAAAADAAAABgAAAAgAAAADAAAACAAAAAcAAAAEAAAABwAAAAkAAAAEAAAACQAAAAUAAAAH
AAAACAAAAAkAAAA=</SharedString>
		<SharedString md5="yuZpQdnvvUBOTYh1jqZ2cA=="></SharedString>
	</SharedStrings>
</roblox>